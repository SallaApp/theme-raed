/*!
 * Crafted with â¤ by Salla
 */
function _mergeNamespaces(n, m) {
	m.forEach(function (e) {
		e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
			if (k !== 'default' && !(k in n)) {
				var d = Object.getOwnPropertyDescriptor(e, k);
				Object.defineProperty(n, k, d.get ? d : {
					enumerable: true,
					get: function () { return e[k]; }
				});
			}
		});
	});
	return Object.freeze(n);
}

const NAMESPACE = 'twilight';
const BUILD = /* twilight */ { hydratedSelectorName: "hydrated", lazyLoad: true, slotRelocation: true, updatable: true};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */

var isArray_1;
var hasRequiredIsArray;

function requireIsArray () {
	if (hasRequiredIsArray) return isArray_1;
	hasRequiredIsArray = 1;
	var isArray = Array.isArray;

	isArray_1 = isArray;
	return isArray_1;
}

/** Detect free variable `global` from Node.js. */

var _freeGlobal;
var hasRequired_freeGlobal;

function require_freeGlobal () {
	if (hasRequired_freeGlobal) return _freeGlobal;
	hasRequired_freeGlobal = 1;
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	_freeGlobal = freeGlobal;
	return _freeGlobal;
}

var _root;
var hasRequired_root;

function require_root () {
	if (hasRequired_root) return _root;
	hasRequired_root = 1;
	var freeGlobal = require_freeGlobal();

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	_root = root;
	return _root;
}

var _Symbol;
var hasRequired_Symbol;

function require_Symbol () {
	if (hasRequired_Symbol) return _Symbol;
	hasRequired_Symbol = 1;
	var root = require_root();

	/** Built-in value references. */
	var Symbol = root.Symbol;

	_Symbol = Symbol;
	return _Symbol;
}

var _getRawTag;
var hasRequired_getRawTag;

function require_getRawTag () {
	if (hasRequired_getRawTag) return _getRawTag;
	hasRequired_getRawTag = 1;
	var Symbol = require_Symbol();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	_getRawTag = getRawTag;
	return _getRawTag;
}

/** Used for built-in method references. */

var _objectToString;
var hasRequired_objectToString;

function require_objectToString () {
	if (hasRequired_objectToString) return _objectToString;
	hasRequired_objectToString = 1;
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	_objectToString = objectToString;
	return _objectToString;
}

var _baseGetTag;
var hasRequired_baseGetTag;

function require_baseGetTag () {
	if (hasRequired_baseGetTag) return _baseGetTag;
	hasRequired_baseGetTag = 1;
	var Symbol = require_Symbol(),
	    getRawTag = require_getRawTag(),
	    objectToString = require_objectToString();

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	_baseGetTag = baseGetTag;
	return _baseGetTag;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */

var isObjectLike_1;
var hasRequiredIsObjectLike;

function requireIsObjectLike () {
	if (hasRequiredIsObjectLike) return isObjectLike_1;
	hasRequiredIsObjectLike = 1;
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	isObjectLike_1 = isObjectLike;
	return isObjectLike_1;
}

var isSymbol_1;
var hasRequiredIsSymbol;

function requireIsSymbol () {
	if (hasRequiredIsSymbol) return isSymbol_1;
	hasRequiredIsSymbol = 1;
	var baseGetTag = require_baseGetTag(),
	    isObjectLike = requireIsObjectLike();

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	isSymbol_1 = isSymbol;
	return isSymbol_1;
}

var _isKey;
var hasRequired_isKey;

function require_isKey () {
	if (hasRequired_isKey) return _isKey;
	hasRequired_isKey = 1;
	var isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	_isKey = isKey;
	return _isKey;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */

var isObject_1;
var hasRequiredIsObject;

function requireIsObject () {
	if (hasRequiredIsObject) return isObject_1;
	hasRequiredIsObject = 1;
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	isObject_1 = isObject;
	return isObject_1;
}

var isFunction_1;
var hasRequiredIsFunction;

function requireIsFunction () {
	if (hasRequiredIsFunction) return isFunction_1;
	hasRequiredIsFunction = 1;
	var baseGetTag = require_baseGetTag(),
	    isObject = requireIsObject();

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	isFunction_1 = isFunction;
	return isFunction_1;
}

var _coreJsData;
var hasRequired_coreJsData;

function require_coreJsData () {
	if (hasRequired_coreJsData) return _coreJsData;
	hasRequired_coreJsData = 1;
	var root = require_root();

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	_coreJsData = coreJsData;
	return _coreJsData;
}

var _isMasked;
var hasRequired_isMasked;

function require_isMasked () {
	if (hasRequired_isMasked) return _isMasked;
	hasRequired_isMasked = 1;
	var coreJsData = require_coreJsData();

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	_isMasked = isMasked;
	return _isMasked;
}

/** Used for built-in method references. */

var _toSource;
var hasRequired_toSource;

function require_toSource () {
	if (hasRequired_toSource) return _toSource;
	hasRequired_toSource = 1;
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	_toSource = toSource;
	return _toSource;
}

var _baseIsNative;
var hasRequired_baseIsNative;

function require_baseIsNative () {
	if (hasRequired_baseIsNative) return _baseIsNative;
	hasRequired_baseIsNative = 1;
	var isFunction = requireIsFunction(),
	    isMasked = require_isMasked(),
	    isObject = requireIsObject(),
	    toSource = require_toSource();

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	_baseIsNative = baseIsNative;
	return _baseIsNative;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */

var _getValue;
var hasRequired_getValue;

function require_getValue () {
	if (hasRequired_getValue) return _getValue;
	hasRequired_getValue = 1;
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	_getValue = getValue;
	return _getValue;
}

var _getNative;
var hasRequired_getNative;

function require_getNative () {
	if (hasRequired_getNative) return _getNative;
	hasRequired_getNative = 1;
	var baseIsNative = require_baseIsNative(),
	    getValue = require_getValue();

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	_getNative = getNative;
	return _getNative;
}

var _nativeCreate;
var hasRequired_nativeCreate;

function require_nativeCreate () {
	if (hasRequired_nativeCreate) return _nativeCreate;
	hasRequired_nativeCreate = 1;
	var getNative = require_getNative();

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	_nativeCreate = nativeCreate;
	return _nativeCreate;
}

var _hashClear;
var hasRequired_hashClear;

function require_hashClear () {
	if (hasRequired_hashClear) return _hashClear;
	hasRequired_hashClear = 1;
	var nativeCreate = require_nativeCreate();

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	_hashClear = hashClear;
	return _hashClear;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */

var _hashDelete;
var hasRequired_hashDelete;

function require_hashDelete () {
	if (hasRequired_hashDelete) return _hashDelete;
	hasRequired_hashDelete = 1;
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_hashDelete = hashDelete;
	return _hashDelete;
}

var _hashGet;
var hasRequired_hashGet;

function require_hashGet () {
	if (hasRequired_hashGet) return _hashGet;
	hasRequired_hashGet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	_hashGet = hashGet;
	return _hashGet;
}

var _hashHas;
var hasRequired_hashHas;

function require_hashHas () {
	if (hasRequired_hashHas) return _hashHas;
	hasRequired_hashHas = 1;
	var nativeCreate = require_nativeCreate();

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	_hashHas = hashHas;
	return _hashHas;
}

var _hashSet;
var hasRequired_hashSet;

function require_hashSet () {
	if (hasRequired_hashSet) return _hashSet;
	hasRequired_hashSet = 1;
	var nativeCreate = require_nativeCreate();

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	_hashSet = hashSet;
	return _hashSet;
}

var _Hash;
var hasRequired_Hash;

function require_Hash () {
	if (hasRequired_Hash) return _Hash;
	hasRequired_Hash = 1;
	var hashClear = require_hashClear(),
	    hashDelete = require_hashDelete(),
	    hashGet = require_hashGet(),
	    hashHas = require_hashHas(),
	    hashSet = require_hashSet();

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	_Hash = Hash;
	return _Hash;
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */

var _listCacheClear;
var hasRequired_listCacheClear;

function require_listCacheClear () {
	if (hasRequired_listCacheClear) return _listCacheClear;
	hasRequired_listCacheClear = 1;
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	_listCacheClear = listCacheClear;
	return _listCacheClear;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */

var eq_1;
var hasRequiredEq;

function requireEq () {
	if (hasRequiredEq) return eq_1;
	hasRequiredEq = 1;
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	eq_1 = eq;
	return eq_1;
}

var _assocIndexOf;
var hasRequired_assocIndexOf;

function require_assocIndexOf () {
	if (hasRequired_assocIndexOf) return _assocIndexOf;
	hasRequired_assocIndexOf = 1;
	var eq = requireEq();

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	_assocIndexOf = assocIndexOf;
	return _assocIndexOf;
}

var _listCacheDelete;
var hasRequired_listCacheDelete;

function require_listCacheDelete () {
	if (hasRequired_listCacheDelete) return _listCacheDelete;
	hasRequired_listCacheDelete = 1;
	var assocIndexOf = require_assocIndexOf();

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	_listCacheDelete = listCacheDelete;
	return _listCacheDelete;
}

var _listCacheGet;
var hasRequired_listCacheGet;

function require_listCacheGet () {
	if (hasRequired_listCacheGet) return _listCacheGet;
	hasRequired_listCacheGet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	_listCacheGet = listCacheGet;
	return _listCacheGet;
}

var _listCacheHas;
var hasRequired_listCacheHas;

function require_listCacheHas () {
	if (hasRequired_listCacheHas) return _listCacheHas;
	hasRequired_listCacheHas = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	_listCacheHas = listCacheHas;
	return _listCacheHas;
}

var _listCacheSet;
var hasRequired_listCacheSet;

function require_listCacheSet () {
	if (hasRequired_listCacheSet) return _listCacheSet;
	hasRequired_listCacheSet = 1;
	var assocIndexOf = require_assocIndexOf();

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	_listCacheSet = listCacheSet;
	return _listCacheSet;
}

var _ListCache;
var hasRequired_ListCache;

function require_ListCache () {
	if (hasRequired_ListCache) return _ListCache;
	hasRequired_ListCache = 1;
	var listCacheClear = require_listCacheClear(),
	    listCacheDelete = require_listCacheDelete(),
	    listCacheGet = require_listCacheGet(),
	    listCacheHas = require_listCacheHas(),
	    listCacheSet = require_listCacheSet();

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	_ListCache = ListCache;
	return _ListCache;
}

var _Map;
var hasRequired_Map;

function require_Map () {
	if (hasRequired_Map) return _Map;
	hasRequired_Map = 1;
	var getNative = require_getNative(),
	    root = require_root();

	/* Built-in method references that are verified to be native. */
	var Map = getNative(root, 'Map');

	_Map = Map;
	return _Map;
}

var _mapCacheClear;
var hasRequired_mapCacheClear;

function require_mapCacheClear () {
	if (hasRequired_mapCacheClear) return _mapCacheClear;
	hasRequired_mapCacheClear = 1;
	var Hash = require_Hash(),
	    ListCache = require_ListCache(),
	    Map = require_Map();

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	_mapCacheClear = mapCacheClear;
	return _mapCacheClear;
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */

var _isKeyable;
var hasRequired_isKeyable;

function require_isKeyable () {
	if (hasRequired_isKeyable) return _isKeyable;
	hasRequired_isKeyable = 1;
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	_isKeyable = isKeyable;
	return _isKeyable;
}

var _getMapData;
var hasRequired_getMapData;

function require_getMapData () {
	if (hasRequired_getMapData) return _getMapData;
	hasRequired_getMapData = 1;
	var isKeyable = require_isKeyable();

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	_getMapData = getMapData;
	return _getMapData;
}

var _mapCacheDelete;
var hasRequired_mapCacheDelete;

function require_mapCacheDelete () {
	if (hasRequired_mapCacheDelete) return _mapCacheDelete;
	hasRequired_mapCacheDelete = 1;
	var getMapData = require_getMapData();

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	_mapCacheDelete = mapCacheDelete;
	return _mapCacheDelete;
}

var _mapCacheGet;
var hasRequired_mapCacheGet;

function require_mapCacheGet () {
	if (hasRequired_mapCacheGet) return _mapCacheGet;
	hasRequired_mapCacheGet = 1;
	var getMapData = require_getMapData();

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	_mapCacheGet = mapCacheGet;
	return _mapCacheGet;
}

var _mapCacheHas;
var hasRequired_mapCacheHas;

function require_mapCacheHas () {
	if (hasRequired_mapCacheHas) return _mapCacheHas;
	hasRequired_mapCacheHas = 1;
	var getMapData = require_getMapData();

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	_mapCacheHas = mapCacheHas;
	return _mapCacheHas;
}

var _mapCacheSet;
var hasRequired_mapCacheSet;

function require_mapCacheSet () {
	if (hasRequired_mapCacheSet) return _mapCacheSet;
	hasRequired_mapCacheSet = 1;
	var getMapData = require_getMapData();

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	_mapCacheSet = mapCacheSet;
	return _mapCacheSet;
}

var _MapCache;
var hasRequired_MapCache;

function require_MapCache () {
	if (hasRequired_MapCache) return _MapCache;
	hasRequired_MapCache = 1;
	var mapCacheClear = require_mapCacheClear(),
	    mapCacheDelete = require_mapCacheDelete(),
	    mapCacheGet = require_mapCacheGet(),
	    mapCacheHas = require_mapCacheHas(),
	    mapCacheSet = require_mapCacheSet();

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	_MapCache = MapCache;
	return _MapCache;
}

var memoize_1;
var hasRequiredMemoize;

function requireMemoize () {
	if (hasRequiredMemoize) return memoize_1;
	hasRequiredMemoize = 1;
	var MapCache = require_MapCache();

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	memoize_1 = memoize;
	return memoize_1;
}

var _memoizeCapped;
var hasRequired_memoizeCapped;

function require_memoizeCapped () {
	if (hasRequired_memoizeCapped) return _memoizeCapped;
	hasRequired_memoizeCapped = 1;
	var memoize = requireMemoize();

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	_memoizeCapped = memoizeCapped;
	return _memoizeCapped;
}

var _stringToPath;
var hasRequired_stringToPath;

function require_stringToPath () {
	if (hasRequired_stringToPath) return _stringToPath;
	hasRequired_stringToPath = 1;
	var memoizeCapped = require_memoizeCapped();

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	_stringToPath = stringToPath;
	return _stringToPath;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */

var _arrayMap;
var hasRequired_arrayMap;

function require_arrayMap () {
	if (hasRequired_arrayMap) return _arrayMap;
	hasRequired_arrayMap = 1;
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	_arrayMap = arrayMap;
	return _arrayMap;
}

var _baseToString;
var hasRequired_baseToString;

function require_baseToString () {
	if (hasRequired_baseToString) return _baseToString;
	hasRequired_baseToString = 1;
	var Symbol = require_Symbol(),
	    arrayMap = require_arrayMap(),
	    isArray = requireIsArray(),
	    isSymbol = requireIsSymbol();

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_baseToString = baseToString;
	return _baseToString;
}

var toString_1;
var hasRequiredToString;

function requireToString () {
	if (hasRequiredToString) return toString_1;
	hasRequiredToString = 1;
	var baseToString = require_baseToString();

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	toString_1 = toString;
	return toString_1;
}

var _castPath;
var hasRequired_castPath;

function require_castPath () {
	if (hasRequired_castPath) return _castPath;
	hasRequired_castPath = 1;
	var isArray = requireIsArray(),
	    isKey = require_isKey(),
	    stringToPath = require_stringToPath(),
	    toString = requireToString();

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	_castPath = castPath;
	return _castPath;
}

var _toKey;
var hasRequired_toKey;

function require_toKey () {
	if (hasRequired_toKey) return _toKey;
	hasRequired_toKey = 1;
	var isSymbol = requireIsSymbol();

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -Infinity) ? '-0' : result;
	}

	_toKey = toKey;
	return _toKey;
}

var _baseGet;
var hasRequired_baseGet;

function require_baseGet () {
	if (hasRequired_baseGet) return _baseGet;
	hasRequired_baseGet = 1;
	var castPath = require_castPath(),
	    toKey = require_toKey();

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	_baseGet = baseGet;
	return _baseGet;
}

var get_1;
var hasRequiredGet;

function requireGet () {
	if (hasRequiredGet) return get_1;
	hasRequiredGet = 1;
	var baseGet = require_baseGet();

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	get_1 = get;
	return get_1;
}

var getExports = requireGet();
var t$2 = /*@__PURE__*/getDefaultExportFromCjs(getExports);

var eventemitter2 = {exports: {}};

/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */

var hasRequiredEventemitter2;

function requireEventemitter2 () {
	if (hasRequiredEventemitter2) return eventemitter2.exports;
	hasRequiredEventemitter2 = 1;
	(function (module, exports) {
!function(undefined$1) {
		  var hasOwnProperty= Object.hasOwnProperty;
		  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
		    return Object.prototype.toString.call(obj) === "[object Array]";
		  };
		  var defaultMaxListeners = 10;
		  var nextTickSupported= typeof process=='object' && typeof process.nextTick=='function';
		  var symbolsSupported= typeof Symbol==='function';
		  var reflectSupported= typeof Reflect === 'object';
		  var setImmediateSupported= typeof setImmediate === 'function';
		  var _setImmediate= setImmediateSupported ? setImmediate : setTimeout;
		  var ownKeys= symbolsSupported? (reflectSupported && typeof Reflect.ownKeys==='function'? Reflect.ownKeys : function(obj){
		    var arr= Object.getOwnPropertyNames(obj);
		    arr.push.apply(arr, Object.getOwnPropertySymbols(obj));
		    return arr;
		  }) : Object.keys;

		  function init() {
		    this._events = {};
		    if (this._conf) {
		      configure.call(this, this._conf);
		    }
		  }

		  function configure(conf) {
		    if (conf) {
		      this._conf = conf;

		      conf.delimiter && (this.delimiter = conf.delimiter);

		      if(conf.maxListeners!==undefined$1){
		          this._maxListeners= conf.maxListeners;
		      }

		      conf.wildcard && (this.wildcard = conf.wildcard);
		      conf.newListener && (this._newListener = conf.newListener);
		      conf.removeListener && (this._removeListener = conf.removeListener);
		      conf.verboseMemoryLeak && (this.verboseMemoryLeak = conf.verboseMemoryLeak);
		      conf.ignoreErrors && (this.ignoreErrors = conf.ignoreErrors);

		      if (this.wildcard) {
		        this.listenerTree = {};
		      }
		    }
		  }

		  function logPossibleMemoryLeak(count, eventName) {
		    var errorMsg = '(node) warning: possible EventEmitter memory ' +
		        'leak detected. ' + count + ' listeners added. ' +
		        'Use emitter.setMaxListeners() to increase limit.';

		    if(this.verboseMemoryLeak){
		      errorMsg += ' Event name: ' + eventName + '.';
		    }

		    if(typeof process !== 'undefined' && process.emitWarning){
		      var e = new Error(errorMsg);
		      e.name = 'MaxListenersExceededWarning';
		      e.emitter = this;
		      e.count = count;
		      process.emitWarning(e);
		    } else {
		      console.error(errorMsg);

		      if (console.trace){
		        console.trace();
		      }
		    }
		  }

		  var toArray = function (a, b, c) {
		    var n = arguments.length;
		    switch (n) {
		      case 0:
		        return [];
		      case 1:
		        return [a];
		      case 2:
		        return [a, b];
		      case 3:
		        return [a, b, c];
		      default:
		        var arr = new Array(n);
		        while (n--) {
		          arr[n] = arguments[n];
		        }
		        return arr;
		    }
		  };

		  function toObject(keys, values) {
		    var obj = {};
		    var key;
		    var len = keys.length;
		    var valuesCount = 0;
		    for (var i = 0; i < len; i++) {
		      key = keys[i];
		      obj[key] = i < valuesCount ? values[i] : undefined$1;
		    }
		    return obj;
		  }

		  function TargetObserver(emitter, target, options) {
		    this._emitter = emitter;
		    this._target = target;
		    this._listeners = {};
		    this._listenersCount = 0;

		    var on, off;

		    if (options.on || options.off) {
		      on = options.on;
		      off = options.off;
		    }

		    if (target.addEventListener) {
		      on = target.addEventListener;
		      off = target.removeEventListener;
		    } else if (target.addListener) {
		      on = target.addListener;
		      off = target.removeListener;
		    } else if (target.on) {
		      on = target.on;
		      off = target.off;
		    }

		    if (!on && !off) {
		      throw Error('target does not implement any known event API');
		    }

		    if (typeof on !== 'function') {
		      throw TypeError('on method must be a function');
		    }

		    if (typeof off !== 'function') {
		      throw TypeError('off method must be a function');
		    }

		    this._on = on;
		    this._off = off;

		    var _observers= emitter._observers;
		    if(_observers){
		      _observers.push(this);
		    }else {
		      emitter._observers= [this];
		    }
		  }

		  Object.assign(TargetObserver.prototype, {
		    subscribe: function(event, localEvent, reducer){
		      var observer= this;
		      var target= this._target;
		      var emitter= this._emitter;
		      var listeners= this._listeners;
		      var handler= function(){
		        var args= toArray.apply(null, arguments);
		        var eventObj= {
		          data: args,
		          name: localEvent,
		          original: event
		        };
		        if(reducer){
		          var result= reducer.call(target, eventObj);
		          if(result!==false){
		            emitter.emit.apply(emitter, [eventObj.name].concat(args));
		          }
		          return;
		        }
		        emitter.emit.apply(emitter, [localEvent].concat(args));
		      };


		      if(listeners[event]){
		        throw Error('Event \'' + event + '\' is already listening');
		      }

		      this._listenersCount++;

		      if(emitter._newListener && emitter._removeListener && !observer._onNewListener){

		        this._onNewListener = function (_event) {
		          if (_event === localEvent && listeners[event] === null) {
		            listeners[event] = handler;
		            observer._on.call(target, event, handler);
		          }
		        };

		        emitter.on('newListener', this._onNewListener);

		        this._onRemoveListener= function(_event){
		          if(_event === localEvent && !emitter.hasListeners(_event) && listeners[event]){
		            listeners[event]= null;
		            observer._off.call(target, event, handler);
		          }
		        };

		        listeners[event]= null;

		        emitter.on('removeListener', this._onRemoveListener);
		      }else {
		        listeners[event]= handler;
		        observer._on.call(target, event, handler);
		      }
		    },

		    unsubscribe: function(event){
		      var observer= this;
		      var listeners= this._listeners;
		      var emitter= this._emitter;
		      var handler;
		      var events;
		      var off= this._off;
		      var target= this._target;
		      var i;

		      if(event && typeof event!=='string'){
		        throw TypeError('event must be a string');
		      }

		      function clearRefs(){
		        if(observer._onNewListener){
		          emitter.off('newListener', observer._onNewListener);
		          emitter.off('removeListener', observer._onRemoveListener);
		          observer._onNewListener= null;
		          observer._onRemoveListener= null;
		        }
		        var index= findTargetIndex.call(emitter, observer);
		        emitter._observers.splice(index, 1);
		      }

		      if(event){
		        handler= listeners[event];
		        if(!handler) return;
		        off.call(target, event, handler);
		        delete listeners[event];
		        if(!--this._listenersCount){
		          clearRefs();
		        }
		      }else {
		        events= ownKeys(listeners);
		        i= events.length;
		        while(i-->0){
		          event= events[i];
		          off.call(target, event, listeners[event]);
		        }
		        this._listeners= {};
		        this._listenersCount= 0;
		        clearRefs();
		      }
		    }
		  });

		  function resolveOptions(options, schema, reducers, allowUnknown) {
		    var computedOptions = Object.assign({}, schema);

		    if (!options) return computedOptions;

		    if (typeof options !== 'object') {
		      throw TypeError('options must be an object')
		    }

		    var keys = Object.keys(options);
		    var length = keys.length;
		    var option, value;
		    var reducer;

		    function reject(reason) {
		      throw Error('Invalid "' + option + '" option value' + (reason ? '. Reason: ' + reason : ''))
		    }

		    for (var i = 0; i < length; i++) {
		      option = keys[i];
		      if (!hasOwnProperty.call(schema, option)) {
		        throw Error('Unknown "' + option + '" option');
		      }
		      value = options[option];
		      if (value !== undefined$1) {
		        reducer = reducers[option];
		        computedOptions[option] = reducer ? reducer(value, reject) : value;
		      }
		    }
		    return computedOptions;
		  }

		  function constructorReducer(value, reject) {
		    if (typeof value !== 'function' || !value.hasOwnProperty('prototype')) {
		      reject('value must be a constructor');
		    }
		    return value;
		  }

		  function makeTypeReducer(types) {
		    var message= 'value must be type of ' + types.join('|');
		    var len= types.length;
		    var firstType= types[0];
		    var secondType= types[1];

		    if (len === 1) {
		      return function (v, reject) {
		        if (typeof v === firstType) {
		          return v;
		        }
		        reject(message);
		      }
		    }

		    if (len === 2) {
		      return function (v, reject) {
		        var kind= typeof v;
		        if (kind === firstType || kind === secondType) return v;
		        reject(message);
		      }
		    }

		    return function (v, reject) {
		      var kind = typeof v;
		      var i = len;
		      while (i-- > 0) {
		        if (kind === types[i]) return v;
		      }
		      reject(message);
		    }
		  }

		  var functionReducer= makeTypeReducer(['function']);

		  var objectFunctionReducer= makeTypeReducer(['object', 'function']);

		  function makeCancelablePromise(Promise, executor, options) {
		    var isCancelable;
		    var callbacks;
		    var timer= 0;
		    var subscriptionClosed;

		    var promise = new Promise(function (resolve, reject, onCancel) {
		      options= resolveOptions(options, {
		        timeout: 0,
		        overload: false
		      }, {
		        timeout: function(value, reject){
		          value*= 1;
		          if (typeof value !== 'number' || value < 0 || !Number.isFinite(value)) {
		            reject('timeout must be a positive number');
		          }
		          return value;
		        }
		      });

		      isCancelable = !options.overload && typeof Promise.prototype.cancel === 'function' && typeof onCancel === 'function';

		      function cleanup() {
		        if (callbacks) {
		          callbacks = null;
		        }
		        if (timer) {
		          clearTimeout(timer);
		          timer = 0;
		        }
		      }

		      var _resolve= function(value){
		        cleanup();
		        resolve(value);
		      };

		      var _reject= function(err){
		        cleanup();
		        reject(err);
		      };

		      if (isCancelable) {
		        executor(_resolve, _reject, onCancel);
		      } else {
		        callbacks = [function(reason){
		          _reject(reason || Error('canceled'));
		        }];
		        executor(_resolve, _reject, function (cb) {
		          if (subscriptionClosed) {
		            throw Error('Unable to subscribe on cancel event asynchronously')
		          }
		          if (typeof cb !== 'function') {
		            throw TypeError('onCancel callback must be a function');
		          }
		          callbacks.push(cb);
		        });
		        subscriptionClosed= true;
		      }

		      if (options.timeout > 0) {
		        timer= setTimeout(function(){
		          var reason= Error('timeout');
		          reason.code = 'ETIMEDOUT';
		          timer= 0;
		          promise.cancel(reason);
		          reject(reason);
		        }, options.timeout);
		      }
		    });

		    if (!isCancelable) {
		      promise.cancel = function (reason) {
		        if (!callbacks) {
		          return;
		        }
		        var length = callbacks.length;
		        for (var i = 1; i < length; i++) {
		          callbacks[i](reason);
		        }
		        // internal callback to reject the promise
		        callbacks[0](reason);
		        callbacks = null;
		      };
		    }

		    return promise;
		  }

		  function findTargetIndex(observer) {
		    var observers = this._observers;
		    if(!observers){
		      return -1;
		    }
		    var len = observers.length;
		    for (var i = 0; i < len; i++) {
		      if (observers[i]._target === observer) return i;
		    }
		    return -1;
		  }

		  // Attention, function return type now is array, always !
		  // It has zero elements if no any matches found and one or more
		  // elements (leafs) if there are matches
		  //
		  function searchListenerTree(handlers, type, tree, i, typeLength) {
		    if (!tree) {
		      return null;
		    }

		    if (i === 0) {
		      var kind = typeof type;
		      if (kind === 'string') {
		        var ns, n, l = 0, j = 0, delimiter = this.delimiter, dl = delimiter.length;
		        if ((n = type.indexOf(delimiter)) !== -1) {
		          ns = new Array(5);
		          do {
		            ns[l++] = type.slice(j, n);
		            j = n + dl;
		          } while ((n = type.indexOf(delimiter, j)) !== -1);

		          ns[l++] = type.slice(j);
		          type = ns;
		          typeLength = l;
		        } else {
		          type = [type];
		          typeLength = 1;
		        }
		      } else if (kind === 'object') {
		        typeLength = type.length;
		      } else {
		        type = [type];
		        typeLength = 1;
		      }
		    }

		    var listeners= null, branch, xTree, xxTree, isolatedBranch, endReached, currentType = type[i],
		        nextType = type[i + 1], branches, _listeners;

		    if (i === typeLength) {
		      //
		      // If at the end of the event(s) list and the tree has listeners
		      // invoke those listeners.
		      //

		      if(tree._listeners) {
		        if (typeof tree._listeners === 'function') {
		          handlers && handlers.push(tree._listeners);
		          listeners = [tree];
		        } else {
		          handlers && handlers.push.apply(handlers, tree._listeners);
		          listeners = [tree];
		        }
		      }
		    } else {

		      if (currentType === '*') {
		        //
		        // If the event emitted is '*' at this part
		        // or there is a concrete match at this patch
		        //
		        branches = ownKeys(tree);
		        n = branches.length;
		        while (n-- > 0) {
		          branch = branches[n];
		          if (branch !== '_listeners') {
		            _listeners = searchListenerTree(handlers, type, tree[branch], i + 1, typeLength);
		            if (_listeners) {
		              if (listeners) {
		                listeners.push.apply(listeners, _listeners);
		              } else {
		                listeners = _listeners;
		              }
		            }
		          }
		        }
		        return listeners;
		      } else if (currentType === '**') {
		        endReached = (i + 1 === typeLength || (i + 2 === typeLength && nextType === '*'));
		        if (endReached && tree._listeners) {
		          // The next element has a _listeners, add it to the handlers.
		          listeners = searchListenerTree(handlers, type, tree, typeLength, typeLength);
		        }

		        branches = ownKeys(tree);
		        n = branches.length;
		        while (n-- > 0) {
		          branch = branches[n];
		          if (branch !== '_listeners') {
		            if (branch === '*' || branch === '**') {
		              if (tree[branch]._listeners && !endReached) {
		                _listeners = searchListenerTree(handlers, type, tree[branch], typeLength, typeLength);
		                if (_listeners) {
		                  if (listeners) {
		                    listeners.push.apply(listeners, _listeners);
		                  } else {
		                    listeners = _listeners;
		                  }
		                }
		              }
		              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
		            } else if (branch === nextType) {
		              _listeners = searchListenerTree(handlers, type, tree[branch], i + 2, typeLength);
		            } else {
		              // No match on this one, shift into the tree but not in the type array.
		              _listeners = searchListenerTree(handlers, type, tree[branch], i, typeLength);
		            }
		            if (_listeners) {
		              if (listeners) {
		                listeners.push.apply(listeners, _listeners);
		              } else {
		                listeners = _listeners;
		              }
		            }
		          }
		        }
		        return listeners;
		      } else if (tree[currentType]) {
		        listeners = searchListenerTree(handlers, type, tree[currentType], i + 1, typeLength);
		      }
		    }

		      xTree = tree['*'];
		    if (xTree) {
		      //
		      // If the listener tree will allow any match for this part,
		      // then recursively explore all branches of the tree
		      //
		      searchListenerTree(handlers, type, xTree, i + 1, typeLength);
		    }

		    xxTree = tree['**'];
		    if (xxTree) {
		      if (i < typeLength) {
		        if (xxTree._listeners) {
		          // If we have a listener on a '**', it will catch all, so add its handler.
		          searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
		        }

		        // Build arrays of matching next branches and others.
		        branches= ownKeys(xxTree);
		        n= branches.length;
		        while(n-->0){
		          branch= branches[n];
		          if (branch !== '_listeners') {
		            if (branch === nextType) {
		              // We know the next element will match, so jump twice.
		              searchListenerTree(handlers, type, xxTree[branch], i + 2, typeLength);
		            } else if (branch === currentType) {
		              // Current node matches, move into the tree.
		              searchListenerTree(handlers, type, xxTree[branch], i + 1, typeLength);
		            } else {
		              isolatedBranch = {};
		              isolatedBranch[branch] = xxTree[branch];
		              searchListenerTree(handlers, type, {'**': isolatedBranch}, i + 1, typeLength);
		            }
		          }
		        }
		      } else if (xxTree._listeners) {
		        // We have reached the end and still on a '**'
		        searchListenerTree(handlers, type, xxTree, typeLength, typeLength);
		      } else if (xxTree['*'] && xxTree['*']._listeners) {
		        searchListenerTree(handlers, type, xxTree['*'], typeLength, typeLength);
		      }
		    }

		    return listeners;
		  }

		  function growListenerTree(type, listener, prepend) {
		    var len = 0, j = 0, i, delimiter = this.delimiter, dl= delimiter.length, ns;

		    if(typeof type==='string') {
		      if ((i = type.indexOf(delimiter)) !== -1) {
		        ns = new Array(5);
		        do {
		          ns[len++] = type.slice(j, i);
		          j = i + dl;
		        } while ((i = type.indexOf(delimiter, j)) !== -1);

		        ns[len++] = type.slice(j);
		      }else {
		        ns= [type];
		        len= 1;
		      }
		    }else {
		      ns= type;
		      len= type.length;
		    }

		    //
		    // Looks for two consecutive '**', if so, don't add the event at all.
		    //
		    if (len > 1) {
		      for (i = 0; i + 1 < len; i++) {
		        if (ns[i] === '**' && ns[i + 1] === '**') {
		          return;
		        }
		      }
		    }



		    var tree = this.listenerTree, name;

		    for (i = 0; i < len; i++) {
		      name = ns[i];

		      tree = tree[name] || (tree[name] = {});

		      if (i === len - 1) {
		        if (!tree._listeners) {
		          tree._listeners = listener;
		        } else {
		          if (typeof tree._listeners === 'function') {
		            tree._listeners = [tree._listeners];
		          }

		          if (prepend) {
		            tree._listeners.unshift(listener);
		          } else {
		            tree._listeners.push(listener);
		          }

		          if (
		              !tree._listeners.warned &&
		              this._maxListeners > 0 &&
		              tree._listeners.length > this._maxListeners
		          ) {
		            tree._listeners.warned = true;
		            logPossibleMemoryLeak.call(this, tree._listeners.length, name);
		          }
		        }
		        return true;
		      }
		    }

		    return true;
		  }

		  function collectTreeEvents(tree, events, root, asArray){
		     var branches= ownKeys(tree);
		     var i= branches.length;
		     var branch, branchName, path;
		     var hasListeners= tree['_listeners'];
		     var isArrayPath;

		     while(i-->0){
		         branchName= branches[i];

		         branch= tree[branchName];

		         if(branchName==='_listeners'){
		             path= root;
		         }else {
		             path = root ? root.concat(branchName) : [branchName];
		         }

		         isArrayPath= asArray || typeof branchName==='symbol';

		         hasListeners && events.push(isArrayPath? path : path.join(this.delimiter));

		         if(typeof branch==='object'){
		             collectTreeEvents.call(this, branch, events, path, isArrayPath);
		         }
		     }

		     return events;
		  }

		  function recursivelyGarbageCollect(root) {
		    var keys = ownKeys(root);
		    var i= keys.length;
		    var obj, key, flag;
		    while(i-->0){
		      key = keys[i];
		      obj = root[key];

		      if(obj){
		          flag= true;
		          if(key !== '_listeners' && !recursivelyGarbageCollect(obj)){
		             delete root[key];
		          }
		      }
		    }

		    return flag;
		  }

		  function Listener(emitter, event, listener){
		    this.emitter= emitter;
		    this.event= event;
		    this.listener= listener;
		  }

		  Listener.prototype.off= function(){
		    this.emitter.off(this.event, this.listener);
		    return this;
		  };

		  function setupListener(event, listener, options){
		      if (options === true) {
		        promisify = true;
		      } else if (options === false) {
		        async = true;
		      } else {
		        if (!options || typeof options !== 'object') {
		          throw TypeError('options should be an object or true');
		        }
		        var async = options.async;
		        var promisify = options.promisify;
		        var nextTick = options.nextTick;
		        var objectify = options.objectify;
		      }

		      if (async || nextTick || promisify) {
		        var _listener = listener;
		        var _origin = listener._origin || listener;

		        if (nextTick && !nextTickSupported) {
		          throw Error('process.nextTick is not supported');
		        }

		        if (promisify === undefined$1) {
		          promisify = listener.constructor.name === 'AsyncFunction';
		        }

		        listener = function () {
		          var args = arguments;
		          var context = this;
		          var event = this.event;

		          return promisify ? (nextTick ? Promise.resolve() : new Promise(function (resolve) {
		            _setImmediate(resolve);
		          }).then(function () {
		            context.event = event;
		            return _listener.apply(context, args)
		          })) : (nextTick ? process.nextTick : _setImmediate)(function () {
		            context.event = event;
		            _listener.apply(context, args);
		          });
		        };

		        listener._async = true;
		        listener._origin = _origin;
		      }

		    return [listener, objectify? new Listener(this, event, listener): this];
		  }

		  function EventEmitter(conf) {
		    this._events = {};
		    this._newListener = false;
		    this._removeListener = false;
		    this.verboseMemoryLeak = false;
		    configure.call(this, conf);
		  }

		  EventEmitter.EventEmitter2 = EventEmitter; // backwards compatibility for exporting EventEmitter property

		  EventEmitter.prototype.listenTo= function(target, events, options){
		    if(typeof target!=='object'){
		      throw TypeError('target musts be an object');
		    }

		    var emitter= this;

		    options = resolveOptions(options, {
		      on: undefined$1,
		      off: undefined$1,
		      reducers: undefined$1
		    }, {
		      on: functionReducer,
		      off: functionReducer,
		      reducers: objectFunctionReducer
		    });

		    function listen(events){
		      if(typeof events!=='object'){
		        throw TypeError('events must be an object');
		      }

		      var reducers= options.reducers;
		      var index= findTargetIndex.call(emitter, target);
		      var observer;

		      if(index===-1){
		        observer= new TargetObserver(emitter, target, options);
		      }else {
		        observer= emitter._observers[index];
		      }

		      var keys= ownKeys(events);
		      var len= keys.length;
		      var event;
		      var isSingleReducer= typeof reducers==='function';

		      for(var i=0; i<len; i++){
		        event= keys[i];
		        observer.subscribe(
		            event,
		            events[event] || event,
		            isSingleReducer ? reducers : reducers && reducers[event]
		        );
		      }
		    }

		    isArray(events)?
		        listen(toObject(events)) :
		        (typeof events==='string'? listen(toObject(events.split(/\s+/))): listen(events));

		    return this;
		  };

		  EventEmitter.prototype.stopListeningTo = function (target, event) {
		    var observers = this._observers;

		    if(!observers){
		      return false;
		    }

		    var i = observers.length;
		    var observer;
		    var matched= false;

		    if(target && typeof target!=='object'){
		      throw TypeError('target should be an object');
		    }

		    while (i-- > 0) {
		      observer = observers[i];
		      if (!target || observer._target === target) {
		        observer.unsubscribe(event);
		        matched= true;
		      }
		    }

		    return matched;
		  };

		  // By default EventEmitters will print a warning if more than
		  // 10 listeners are added to it. This is a useful default which
		  // helps finding memory leaks.
		  //
		  // Obviously not all Emitters should be limited to 10. This function allows
		  // that to be increased. Set to zero for unlimited.

		  EventEmitter.prototype.delimiter = '.';

		  EventEmitter.prototype.setMaxListeners = function(n) {
		    if (n !== undefined$1) {
		      this._maxListeners = n;
		      if (!this._conf) this._conf = {};
		      this._conf.maxListeners = n;
		    }
		  };

		  EventEmitter.prototype.getMaxListeners = function() {
		    return this._maxListeners;
		  };

		  EventEmitter.prototype.event = '';

		  EventEmitter.prototype.once = function(event, fn, options) {
		    return this._once(event, fn, false, options);
		  };

		  EventEmitter.prototype.prependOnceListener = function(event, fn, options) {
		    return this._once(event, fn, true, options);
		  };

		  EventEmitter.prototype._once = function(event, fn, prepend, options) {
		    return this._many(event, 1, fn, prepend, options);
		  };

		  EventEmitter.prototype.many = function(event, ttl, fn, options) {
		    return this._many(event, ttl, fn, false, options);
		  };

		  EventEmitter.prototype.prependMany = function(event, ttl, fn, options) {
		    return this._many(event, ttl, fn, true, options);
		  };

		  EventEmitter.prototype._many = function(event, ttl, fn, prepend, options) {
		    var self = this;

		    if (typeof fn !== 'function') {
		      throw new Error('many only accepts instances of Function');
		    }

		    function listener() {
		      if (--ttl === 0) {
		        self.off(event, listener);
		      }
		      return fn.apply(this, arguments);
		    }

		    listener._origin = fn;

		    return this._on(event, listener, prepend, options);
		  };

		  EventEmitter.prototype.emit = function() {
		    if (!this._events && !this._all) {
		      return false;
		    }

		    this._events || init.call(this);

		    var type = arguments[0], ns, wildcard= this.wildcard;
		    var args,l,i,j, containsSymbol;

		    if (type === 'newListener' && !this._newListener) {
		      if (!this._events.newListener) {
		        return false;
		      }
		    }

		    if (wildcard) {
		      ns= type;
		      if(type!=='newListener' && type!=='removeListener'){
		        if (typeof type === 'object') {
		          l = type.length;
		          if (symbolsSupported) {
		            for (i = 0; i < l; i++) {
		              if (typeof type[i] === 'symbol') {
		                containsSymbol = true;
		                break;
		              }
		            }
		          }
		          if (!containsSymbol) {
		            type = type.join(this.delimiter);
		          }
		        }
		      }
		    }

		    var al = arguments.length;
		    var handler;

		    if (this._all && this._all.length) {
		      handler = this._all.slice();

		      for (i = 0, l = handler.length; i < l; i++) {
		        this.event = type;
		        switch (al) {
		        case 1:
		          handler[i].call(this, type);
		          break;
		        case 2:
		          handler[i].call(this, type, arguments[1]);
		          break;
		        case 3:
		          handler[i].call(this, type, arguments[1], arguments[2]);
		          break;
		        default:
		          handler[i].apply(this, arguments);
		        }
		      }
		    }

		    if (wildcard) {
		      handler = [];
		      searchListenerTree.call(this, handler, ns, this.listenerTree, 0, l);
		    } else {
		      handler = this._events[type];
		      if (typeof handler === 'function') {
		        this.event = type;
		        switch (al) {
		        case 1:
		          handler.call(this);
		          break;
		        case 2:
		          handler.call(this, arguments[1]);
		          break;
		        case 3:
		          handler.call(this, arguments[1], arguments[2]);
		          break;
		        default:
		          args = new Array(al - 1);
		          for (j = 1; j < al; j++) args[j - 1] = arguments[j];
		          handler.apply(this, args);
		        }
		        return true;
		      } else if (handler) {
		        // need to make copy of handlers because list can change in the middle
		        // of emit call
		        handler = handler.slice();
		      }
		    }

		    if (handler && handler.length) {
		      if (al > 3) {
		        args = new Array(al - 1);
		        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
		      }
		      for (i = 0, l = handler.length; i < l; i++) {
		        this.event = type;
		        switch (al) {
		        case 1:
		          handler[i].call(this);
		          break;
		        case 2:
		          handler[i].call(this, arguments[1]);
		          break;
		        case 3:
		          handler[i].call(this, arguments[1], arguments[2]);
		          break;
		        default:
		          handler[i].apply(this, args);
		        }
		      }
		      return true;
		    } else if (!this.ignoreErrors && !this._all && type === 'error') {
		      if (arguments[1] instanceof Error) {
		        throw arguments[1]; // Unhandled 'error' event
		      } else {
		        throw new Error("Uncaught, unspecified 'error' event.");
		      }
		    }

		    return !!this._all;
		  };

		  EventEmitter.prototype.emitAsync = function() {
		    if (!this._events && !this._all) {
		      return false;
		    }

		    this._events || init.call(this);

		    var type = arguments[0], wildcard= this.wildcard, ns, containsSymbol;
		    var args,l,i,j;

		    if (type === 'newListener' && !this._newListener) {
		        if (!this._events.newListener) { return Promise.resolve([false]); }
		    }

		    if (wildcard) {
		      ns= type;
		      if(type!=='newListener' && type!=='removeListener'){
		        if (typeof type === 'object') {
		          l = type.length;
		          if (symbolsSupported) {
		            for (i = 0; i < l; i++) {
		              if (typeof type[i] === 'symbol') {
		                containsSymbol = true;
		                break;
		              }
		            }
		          }
		          if (!containsSymbol) {
		            type = type.join(this.delimiter);
		          }
		        }
		      }
		    }

		    var promises= [];

		    var al = arguments.length;
		    var handler;

		    if (this._all) {
		      for (i = 0, l = this._all.length; i < l; i++) {
		        this.event = type;
		        switch (al) {
		        case 1:
		          promises.push(this._all[i].call(this, type));
		          break;
		        case 2:
		          promises.push(this._all[i].call(this, type, arguments[1]));
		          break;
		        case 3:
		          promises.push(this._all[i].call(this, type, arguments[1], arguments[2]));
		          break;
		        default:
		          promises.push(this._all[i].apply(this, arguments));
		        }
		      }
		    }

		    if (wildcard) {
		      handler = [];
		      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
		    } else {
		      handler = this._events[type];
		    }

		    if (typeof handler === 'function') {
		      this.event = type;
		      switch (al) {
		      case 1:
		        promises.push(handler.call(this));
		        break;
		      case 2:
		        promises.push(handler.call(this, arguments[1]));
		        break;
		      case 3:
		        promises.push(handler.call(this, arguments[1], arguments[2]));
		        break;
		      default:
		        args = new Array(al - 1);
		        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
		        promises.push(handler.apply(this, args));
		      }
		    } else if (handler && handler.length) {
		      handler = handler.slice();
		      if (al > 3) {
		        args = new Array(al - 1);
		        for (j = 1; j < al; j++) args[j - 1] = arguments[j];
		      }
		      for (i = 0, l = handler.length; i < l; i++) {
		        this.event = type;
		        switch (al) {
		        case 1:
		          promises.push(handler[i].call(this));
		          break;
		        case 2:
		          promises.push(handler[i].call(this, arguments[1]));
		          break;
		        case 3:
		          promises.push(handler[i].call(this, arguments[1], arguments[2]));
		          break;
		        default:
		          promises.push(handler[i].apply(this, args));
		        }
		      }
		    } else if (!this.ignoreErrors && !this._all && type === 'error') {
		      if (arguments[1] instanceof Error) {
		        return Promise.reject(arguments[1]); // Unhandled 'error' event
		      } else {
		        return Promise.reject("Uncaught, unspecified 'error' event.");
		      }
		    }

		    return Promise.all(promises);
		  };

		  EventEmitter.prototype.on = function(type, listener, options) {
		    return this._on(type, listener, false, options);
		  };

		  EventEmitter.prototype.prependListener = function(type, listener, options) {
		    return this._on(type, listener, true, options);
		  };

		  EventEmitter.prototype.onAny = function(fn) {
		    return this._onAny(fn, false);
		  };

		  EventEmitter.prototype.prependAny = function(fn) {
		    return this._onAny(fn, true);
		  };

		  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

		  EventEmitter.prototype._onAny = function(fn, prepend){
		    if (typeof fn !== 'function') {
		      throw new Error('onAny only accepts instances of Function');
		    }

		    if (!this._all) {
		      this._all = [];
		    }

		    // Add the function to the event listener collection.
		    if(prepend){
		      this._all.unshift(fn);
		    }else {
		      this._all.push(fn);
		    }

		    return this;
		  };

		  EventEmitter.prototype._on = function(type, listener, prepend, options) {
		    if (typeof type === 'function') {
		      this._onAny(type, listener);
		      return this;
		    }

		    if (typeof listener !== 'function') {
		      throw new Error('on only accepts instances of Function');
		    }
		    this._events || init.call(this);

		    var returnValue= this, temp;

		    if (options !== undefined$1) {
		      temp = setupListener.call(this, type, listener, options);
		      listener = temp[0];
		      returnValue = temp[1];
		    }

		    // To avoid recursion in the case that type == "newListeners"! Before
		    // adding it to the listeners, first emit "newListeners".
		    if (this._newListener) {
		      this.emit('newListener', type, listener);
		    }

		    if (this.wildcard) {
		      growListenerTree.call(this, type, listener, prepend);
		      return returnValue;
		    }

		    if (!this._events[type]) {
		      // Optimize the case of one listener. Don't need the extra array object.
		      this._events[type] = listener;
		    } else {
		      if (typeof this._events[type] === 'function') {
		        // Change to array.
		        this._events[type] = [this._events[type]];
		      }

		      // If we've already got an array, just add
		      if(prepend){
		        this._events[type].unshift(listener);
		      }else {
		        this._events[type].push(listener);
		      }

		      // Check for listener leak
		      if (
		        !this._events[type].warned &&
		        this._maxListeners > 0 &&
		        this._events[type].length > this._maxListeners
		      ) {
		        this._events[type].warned = true;
		        logPossibleMemoryLeak.call(this, this._events[type].length, type);
		      }
		    }

		    return returnValue;
		  };

		  EventEmitter.prototype.off = function(type, listener) {
		    if (typeof listener !== 'function') {
		      throw new Error('removeListener only takes instances of Function');
		    }

		    var handlers,leafs=[];

		    if(this.wildcard) {
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
		      if(!leafs) return this;
		    } else {
		      // does not use listeners(), so no side effect of creating _events[type]
		      if (!this._events[type]) return this;
		      handlers = this._events[type];
		      leafs.push({_listeners:handlers});
		    }

		    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
		      var leaf = leafs[iLeaf];
		      handlers = leaf._listeners;
		      if (isArray(handlers)) {

		        var position = -1;

		        for (var i = 0, length = handlers.length; i < length; i++) {
		          if (handlers[i] === listener ||
		            (handlers[i].listener && handlers[i].listener === listener) ||
		            (handlers[i]._origin && handlers[i]._origin === listener)) {
		            position = i;
		            break;
		          }
		        }

		        if (position < 0) {
		          continue;
		        }

		        if(this.wildcard) {
		          leaf._listeners.splice(position, 1);
		        }
		        else {
		          this._events[type].splice(position, 1);
		        }

		        if (handlers.length === 0) {
		          if(this.wildcard) {
		            delete leaf._listeners;
		          }
		          else {
		            delete this._events[type];
		          }
		        }
		        if (this._removeListener)
		          this.emit("removeListener", type, listener);

		        return this;
		      }
		      else if (handlers === listener ||
		        (handlers.listener && handlers.listener === listener) ||
		        (handlers._origin && handlers._origin === listener)) {
		        if(this.wildcard) {
		          delete leaf._listeners;
		        }
		        else {
		          delete this._events[type];
		        }
		        if (this._removeListener)
		          this.emit("removeListener", type, listener);
		      }
		    }

		    this.listenerTree && recursivelyGarbageCollect(this.listenerTree);

		    return this;
		  };

		  EventEmitter.prototype.offAny = function(fn) {
		    var i = 0, l = 0, fns;
		    if (fn && this._all && this._all.length > 0) {
		      fns = this._all;
		      for(i = 0, l = fns.length; i < l; i++) {
		        if(fn === fns[i]) {
		          fns.splice(i, 1);
		          if (this._removeListener)
		            this.emit("removeListenerAny", fn);
		          return this;
		        }
		      }
		    } else {
		      fns = this._all;
		      if (this._removeListener) {
		        for(i = 0, l = fns.length; i < l; i++)
		          this.emit("removeListenerAny", fns[i]);
		      }
		      this._all = [];
		    }
		    return this;
		  };

		  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

		  EventEmitter.prototype.removeAllListeners = function (type) {
		    if (type === undefined$1) {
		      !this._events || init.call(this);
		      return this;
		    }

		    if (this.wildcard) {
		      var leafs = searchListenerTree.call(this, null, type, this.listenerTree, 0), leaf, i;
		      if (!leafs) return this;
		      for (i = 0; i < leafs.length; i++) {
		        leaf = leafs[i];
		        leaf._listeners = null;
		      }
		      this.listenerTree && recursivelyGarbageCollect(this.listenerTree);
		    } else if (this._events) {
		      this._events[type] = null;
		    }
		    return this;
		  };

		  EventEmitter.prototype.listeners = function (type) {
		    var _events = this._events;
		    var keys, listeners, allListeners;
		    var i;
		    var listenerTree;

		    if (type === undefined$1) {
		      if (this.wildcard) {
		        throw Error('event name required for wildcard emitter');
		      }

		      if (!_events) {
		        return [];
		      }

		      keys = ownKeys(_events);
		      i = keys.length;
		      allListeners = [];
		      while (i-- > 0) {
		        listeners = _events[keys[i]];
		        if (typeof listeners === 'function') {
		          allListeners.push(listeners);
		        } else {
		          allListeners.push.apply(allListeners, listeners);
		        }
		      }
		      return allListeners;
		    } else {
		      if (this.wildcard) {
		        listenerTree= this.listenerTree;
		        if(!listenerTree) return [];
		        var handlers = [];
		        var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		        searchListenerTree.call(this, handlers, ns, listenerTree, 0);
		        return handlers;
		      }

		      if (!_events) {
		        return [];
		      }

		      listeners = _events[type];

		      if (!listeners) {
		        return [];
		      }
		      return typeof listeners === 'function' ? [listeners] : listeners;
		    }
		  };

		  EventEmitter.prototype.eventNames = function(nsAsArray){
		    var _events= this._events;
		    return this.wildcard? collectTreeEvents.call(this, this.listenerTree, [], null, nsAsArray) : (_events? ownKeys(_events) : []);
		  };

		  EventEmitter.prototype.listenerCount = function(type) {
		    return this.listeners(type).length;
		  };

		  EventEmitter.prototype.hasListeners = function (type) {
		    if (this.wildcard) {
		      var handlers = [];
		      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
		      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
		      return handlers.length > 0;
		    }

		    var _events = this._events;
		    var _all = this._all;

		    return !!(_all && _all.length || _events && (type === undefined$1 ? ownKeys(_events).length : _events[type]));
		  };

		  EventEmitter.prototype.listenersAny = function() {

		    if(this._all) {
		      return this._all;
		    }
		    else {
		      return [];
		    }

		  };

		  EventEmitter.prototype.waitFor = function (event, options) {
		    var self = this;
		    var type = typeof options;
		    if (type === 'number') {
		      options = {timeout: options};
		    } else if (type === 'function') {
		      options = {filter: options};
		    }

		    options= resolveOptions(options, {
		      timeout: 0,
		      filter: undefined$1,
		      handleError: false,
		      Promise: Promise,
		      overload: false
		    }, {
		      filter: functionReducer,
		      Promise: constructorReducer
		    });

		    return makeCancelablePromise(options.Promise, function (resolve, reject, onCancel) {
		      function listener() {
		        var filter= options.filter;
		        if (filter && !filter.apply(self, arguments)) {
		          return;
		        }
		        self.off(event, listener);
		        if (options.handleError) {
		          var err = arguments[0];
		          err ? reject(err) : resolve(toArray.apply(null, arguments).slice(1));
		        } else {
		          resolve(toArray.apply(null, arguments));
		        }
		      }

		      onCancel(function(){
		        self.off(event, listener);
		      });

		      self._on(event, listener, false);
		    }, {
		      timeout: options.timeout,
		      overload: options.overload
		    })
		  };

		  function once(emitter, name, options) {
		    options= resolveOptions(options, {
		      Promise: Promise,
		      timeout: 0,
		      overload: false
		    }, {
		      Promise: constructorReducer
		    });

		    var _Promise= options.Promise;

		    return makeCancelablePromise(_Promise, function(resolve, reject, onCancel){
		      var handler;
		      if (typeof emitter.addEventListener === 'function') {
		        handler=  function () {
		          resolve(toArray.apply(null, arguments));
		        };

		        onCancel(function(){
		          emitter.removeEventListener(name, handler);
		        });

		        emitter.addEventListener(
		            name,
		            handler,
		            {once: true}
		        );
		        return;
		      }

		      var eventListener = function(){
		        errorListener && emitter.removeListener('error', errorListener);
		        resolve(toArray.apply(null, arguments));
		      };

		      var errorListener;

		      if (name !== 'error') {
		        errorListener = function (err){
		          emitter.removeListener(name, eventListener);
		          reject(err);
		        };

		        emitter.once('error', errorListener);
		      }

		      onCancel(function(){
		        errorListener && emitter.removeListener('error', errorListener);
		        emitter.removeListener(name, eventListener);
		      });

		      emitter.once(name, eventListener);
		    }, {
		      timeout: options.timeout,
		      overload: options.overload
		    });
		  }

		  var prototype= EventEmitter.prototype;

		  Object.defineProperties(EventEmitter, {
		    defaultMaxListeners: {
		      get: function () {
		        return prototype._maxListeners;
		      },
		      set: function (n) {
		        if (typeof n !== 'number' || n < 0 || Number.isNaN(n)) {
		          throw TypeError('n must be a non-negative number')
		        }
		        prototype._maxListeners = n;
		      },
		      enumerable: true
		    },
		    once: {
		      value: once,
		      writable: true,
		      configurable: true
		    }
		  });

		  Object.defineProperties(prototype, {
		      _maxListeners: {
		          value: defaultMaxListeners,
		          writable: true,
		          configurable: true
		      },
		      _observers: {value: null, writable: true, configurable: true}
		  });

		  {
		    // CommonJS
		    module.exports = EventEmitter;
		  }
		}(); 
	} (eventemitter2));
	return eventemitter2.exports;
}

var eventemitter2Exports = requireEventemitter2();

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	var assign = make_assign();
	var create = make_create();
	var trim = make_trim();
	var Global = (typeof window !== 'undefined' ? window : commonjsGlobal);

	util = {
		assign: assign,
		create: create,
		trim: trim,
		bind: bind,
		slice: slice,
		each: each,
		map: map,
		pluck: pluck,
		isList: isList,
		isFunction: isFunction,
		isObject: isObject,
		Global: Global
	};

	function make_assign() {
		if (Object.assign) {
			return Object.assign
		} else {
			return function shimAssign(obj, props1, props2, etc) {
				for (var i = 1; i < arguments.length; i++) {
					each(Object(arguments[i]), function(val, key) {
						obj[key] = val;
					});
				}			
				return obj
			}
		}
	}

	function make_create() {
		if (Object.create) {
			return function create(obj, assignProps1, assignProps2, etc) {
				var assignArgsList = slice(arguments, 1);
				return assign.apply(this, [Object.create(obj)].concat(assignArgsList))
			}
		} else {
			function F() {} // eslint-disable-line no-inner-declarations
			return function create(obj, assignProps1, assignProps2, etc) {
				var assignArgsList = slice(arguments, 1);
				F.prototype = obj;
				return assign.apply(this, [new F()].concat(assignArgsList))
			}
		}
	}

	function make_trim() {
		if (String.prototype.trim) {
			return function trim(str) {
				return String.prototype.trim.call(str)
			}
		} else {
			return function trim(str) {
				return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
			}
		}
	}

	function bind(obj, fn) {
		return function() {
			return fn.apply(obj, Array.prototype.slice.call(arguments, 0))
		}
	}

	function slice(arr, index) {
		return Array.prototype.slice.call(arr, index || 0)
	}

	function each(obj, fn) {
		pluck(obj, function(val, key) {
			fn(val, key);
			return false
		});
	}

	function map(obj, fn) {
		var res = (isList(obj) ? [] : {});
		pluck(obj, function(v, k) {
			res[k] = fn(v, k);
			return false
		});
		return res
	}

	function pluck(obj, fn) {
		if (isList(obj)) {
			for (var i=0; i<obj.length; i++) {
				if (fn(obj[i], i)) {
					return obj[i]
				}
			}
		} else {
			for (var key in obj) {
				if (obj.hasOwnProperty(key)) {
					if (fn(obj[key], key)) {
						return obj[key]
					}
				}
			}
		}
	}

	function isList(val) {
		return (val != null && typeof val != 'function' && typeof val.length == 'number')
	}

	function isFunction(val) {
		return val && {}.toString.call(val) === '[object Function]'
	}

	function isObject(val) {
		return val && {}.toString.call(val) === '[object Object]'
	}
	return util;
}

var storeEngine;
var hasRequiredStoreEngine;

function requireStoreEngine () {
	if (hasRequiredStoreEngine) return storeEngine;
	hasRequiredStoreEngine = 1;
	var util = requireUtil();
	var slice = util.slice;
	var pluck = util.pluck;
	var each = util.each;
	var bind = util.bind;
	var create = util.create;
	var isList = util.isList;
	var isFunction = util.isFunction;
	var isObject = util.isObject;

	storeEngine = {
		createStore: createStore
	};

	var storeAPI = {
		version: '2.0.12',
		enabled: false,
		
		// get returns the value of the given key. If that value
		// is undefined, it returns optionalDefaultValue instead.
		get: function(key, optionalDefaultValue) {
			var data = this.storage.read(this._namespacePrefix + key);
			return this._deserialize(data, optionalDefaultValue)
		},

		// set will store the given value at key and returns value.
		// Calling set with value === undefined is equivalent to calling remove.
		set: function(key, value) {
			if (value === undefined) {
				return this.remove(key)
			}
			this.storage.write(this._namespacePrefix + key, this._serialize(value));
			return value
		},

		// remove deletes the key and value stored at the given key.
		remove: function(key) {
			this.storage.remove(this._namespacePrefix + key);
		},

		// each will call the given callback once for each key-value pair
		// in this store.
		each: function(callback) {
			var self = this;
			this.storage.each(function(val, namespacedKey) {
				callback.call(self, self._deserialize(val), (namespacedKey || '').replace(self._namespaceRegexp, ''));
			});
		},

		// clearAll will remove all the stored key-value pairs in this store.
		clearAll: function() {
			this.storage.clearAll();
		},

		// additional functionality that can't live in plugins
		// ---------------------------------------------------

		// hasNamespace returns true if this store instance has the given namespace.
		hasNamespace: function(namespace) {
			return (this._namespacePrefix == '__storejs_'+namespace+'_')
		},

		// createStore creates a store.js instance with the first
		// functioning storage in the list of storage candidates,
		// and applies the the given mixins to the instance.
		createStore: function() {
			return createStore.apply(this, arguments)
		},
		
		addPlugin: function(plugin) {
			this._addPlugin(plugin);
		},
		
		namespace: function(namespace) {
			return createStore(this.storage, this.plugins, namespace)
		}
	};

	function _warn() {
		var _console = (typeof console == 'undefined' ? null : console);
		if (!_console) { return }
		var fn = (_console.warn ? _console.warn : _console.log);
		fn.apply(_console, arguments);
	}

	function createStore(storages, plugins, namespace) {
		if (!namespace) {
			namespace = '';
		}
		if (storages && !isList(storages)) {
			storages = [storages];
		}
		if (plugins && !isList(plugins)) {
			plugins = [plugins];
		}

		var namespacePrefix = (namespace ? '__storejs_'+namespace+'_' : '');
		var namespaceRegexp = (namespace ? new RegExp('^'+namespacePrefix) : null);
		var legalNamespaces = /^[a-zA-Z0-9_\-]*$/; // alpha-numeric + underscore and dash
		if (!legalNamespaces.test(namespace)) {
			throw new Error('store.js namespaces can only have alphanumerics + underscores and dashes')
		}
		
		var _privateStoreProps = {
			_namespacePrefix: namespacePrefix,
			_namespaceRegexp: namespaceRegexp,

			_testStorage: function(storage) {
				try {
					var testStr = '__storejs__test__';
					storage.write(testStr, testStr);
					var ok = (storage.read(testStr) === testStr);
					storage.remove(testStr);
					return ok
				} catch(e) {
					return false
				}
			},

			_assignPluginFnProp: function(pluginFnProp, propName) {
				var oldFn = this[propName];
				this[propName] = function pluginFn() {
					var args = slice(arguments, 0);
					var self = this;

					// super_fn calls the old function which was overwritten by
					// this mixin.
					function super_fn() {
						if (!oldFn) { return }
						each(arguments, function(arg, i) {
							args[i] = arg;
						});
						return oldFn.apply(self, args)
					}

					// Give mixing function access to super_fn by prefixing all mixin function
					// arguments with super_fn.
					var newFnArgs = [super_fn].concat(args);

					return pluginFnProp.apply(self, newFnArgs)
				};
			},

			_serialize: function(obj) {
				return JSON.stringify(obj)
			},

			_deserialize: function(strVal, defaultVal) {
				if (!strVal) { return defaultVal }
				// It is possible that a raw string value has been previously stored
				// in a storage without using store.js, meaning it will be a raw
				// string value instead of a JSON serialized string. By defaulting
				// to the raw string value in case of a JSON parse error, we allow
				// for past stored values to be forwards-compatible with store.js
				var val = '';
				try { val = JSON.parse(strVal); }
				catch(e) { val = strVal; }

				return (val !== undefined ? val : defaultVal)
			},
			
			_addStorage: function(storage) {
				if (this.enabled) { return }
				if (this._testStorage(storage)) {
					this.storage = storage;
					this.enabled = true;
				}
			},

			_addPlugin: function(plugin) {
				var self = this;

				// If the plugin is an array, then add all plugins in the array.
				// This allows for a plugin to depend on other plugins.
				if (isList(plugin)) {
					each(plugin, function(plugin) {
						self._addPlugin(plugin);
					});
					return
				}

				// Keep track of all plugins we've seen so far, so that we
				// don't add any of them twice.
				var seenPlugin = pluck(this.plugins, function(seenPlugin) {
					return (plugin === seenPlugin)
				});
				if (seenPlugin) {
					return
				}
				this.plugins.push(plugin);

				// Check that the plugin is properly formed
				if (!isFunction(plugin)) {
					throw new Error('Plugins must be function values that return objects')
				}

				var pluginProperties = plugin.call(this);
				if (!isObject(pluginProperties)) {
					throw new Error('Plugins must return an object of function properties')
				}

				// Add the plugin function properties to this store instance.
				each(pluginProperties, function(pluginFnProp, propName) {
					if (!isFunction(pluginFnProp)) {
						throw new Error('Bad plugin property: '+propName+' from plugin '+plugin.name+'. Plugins should only return functions.')
					}
					self._assignPluginFnProp(pluginFnProp, propName);
				});
			},
			
			// Put deprecated properties in the private API, so as to not expose it to accidential
			// discovery through inspection of the store object.
			
			// Deprecated: addStorage
			addStorage: function(storage) {
				_warn('store.addStorage(storage) is deprecated. Use createStore([storages])');
				this._addStorage(storage);
			}
		};

		var store = create(_privateStoreProps, storeAPI, {
			plugins: []
		});
		store.raw = {};
		each(store, function(prop, propName) {
			if (isFunction(prop)) {
				store.raw[propName] = bind(store, prop);			
			}
		});
		each(storages, function(storage) {
			store._addStorage(storage);
		});
		each(plugins, function(plugin) {
			store._addPlugin(plugin);
		});
		return store
	}
	return storeEngine;
}

var storeEngineExports = requireStoreEngine();

var localStorage_1;
var hasRequiredLocalStorage;

function requireLocalStorage () {
	if (hasRequiredLocalStorage) return localStorage_1;
	hasRequiredLocalStorage = 1;
	var util = requireUtil();
	var Global = util.Global;

	localStorage_1 = {
		name: 'localStorage',
		read: read,
		write: write,
		each: each,
		remove: remove,
		clearAll: clearAll,
	};

	function localStorage() {
		return Global.localStorage
	}

	function read(key) {
		return localStorage().getItem(key)
	}

	function write(key, data) {
		return localStorage().setItem(key, data)
	}

	function each(fn) {
		for (var i = localStorage().length - 1; i >= 0; i--) {
			var key = localStorage().key(i);
			fn(read(key), key);
		}
	}

	function remove(key) {
		return localStorage().removeItem(key)
	}

	function clearAll() {
		return localStorage().clear()
	}
	return localStorage_1;
}

var localStorageExports = requireLocalStorage();
var localStorage$1 = /*@__PURE__*/getDefaultExportFromCjs(localStorageExports);

var n$3 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: localStorage$1
}, [localStorageExports]);

var sessionStorage_1;
var hasRequiredSessionStorage;

function requireSessionStorage () {
	if (hasRequiredSessionStorage) return sessionStorage_1;
	hasRequiredSessionStorage = 1;
	var util = requireUtil();
	var Global = util.Global;

	sessionStorage_1 = {
		name: 'sessionStorage',
		read: read,
		write: write,
		each: each,
		remove: remove,
		clearAll: clearAll
	};

	function sessionStorage() {
		return Global.sessionStorage
	}

	function read(key) {
		return sessionStorage().getItem(key)
	}

	function write(key, data) {
		return sessionStorage().setItem(key, data)
	}

	function each(fn) {
		for (var i = sessionStorage().length - 1; i >= 0; i--) {
			var key = sessionStorage().key(i);
			fn(read(key), key);
		}
	}

	function remove(key) {
		return sessionStorage().removeItem(key)
	}

	function clearAll() {
		return sessionStorage().clear()
	}
	return sessionStorage_1;
}

var sessionStorageExports = requireSessionStorage();
var sessionStorage$1 = /*@__PURE__*/getDefaultExportFromCjs(sessionStorageExports);

var o$3 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: sessionStorage$1
}, [sessionStorageExports]);

var cookieStorage$2;
var hasRequiredCookieStorage;

function requireCookieStorage () {
	if (hasRequiredCookieStorage) return cookieStorage$2;
	hasRequiredCookieStorage = 1;
	// cookieStorage is useful Safari private browser mode, where localStorage
	// doesn't work but cookies do. This implementation is adopted from
	// https://developer.mozilla.org/en-US/docs/Web/API/Storage/LocalStorage

	var util = requireUtil();
	var Global = util.Global;
	var trim = util.trim;

	cookieStorage$2 = {
		name: 'cookieStorage',
		read: read,
		write: write,
		each: each,
		remove: remove,
		clearAll: clearAll,
	};

	var doc = Global.document;

	function read(key) {
		if (!key || !_has(key)) { return null }
		var regexpStr = "(?:^|.*;\\s*)" +
			escape(key).replace(/[\-\.\+\*]/g, "\\$&") +
			"\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*";
		return unescape(doc.cookie.replace(new RegExp(regexpStr), "$1"))
	}

	function each(callback) {
		var cookies = doc.cookie.split(/; ?/g);
		for (var i = cookies.length - 1; i >= 0; i--) {
			if (!trim(cookies[i])) {
				continue
			}
			var kvp = cookies[i].split('=');
			var key = unescape(kvp[0]);
			var val = unescape(kvp[1]);
			callback(val, key);
		}
	}

	function write(key, data) {
		if(!key) { return }
		doc.cookie = escape(key) + "=" + escape(data) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
	}

	function remove(key) {
		if (!key || !_has(key)) {
			return
		}
		doc.cookie = escape(key) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
	}

	function clearAll() {
		each(function(_, key) {
			remove(key);
		});
	}

	function _has(key) {
		return (new RegExp("(?:^|;\\s*)" + escape(key).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(doc.cookie)
	}
	return cookieStorage$2;
}

var cookieStorageExports = requireCookieStorage();
var cookieStorage$1 = /*@__PURE__*/getDefaultExportFromCjs(cookieStorageExports);

var i$3 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: cookieStorage$1
}, [cookieStorageExports]);

var memoryStorage_1;
var hasRequiredMemoryStorage;

function requireMemoryStorage () {
	if (hasRequiredMemoryStorage) return memoryStorage_1;
	hasRequiredMemoryStorage = 1;
	// memoryStorage is a useful last fallback to ensure that the store
	// is functions (meaning store.get(), store.set(), etc will all function).
	// However, stored values will not persist when the browser navigates to
	// a new page or reloads the current page.

	memoryStorage_1 = {
		name: 'memoryStorage',
		read: read,
		write: write,
		each: each,
		remove: remove,
		clearAll: clearAll,
	};

	var memoryStorage = {};

	function read(key) {
		return memoryStorage[key]
	}

	function write(key, data) {
		memoryStorage[key] = data;
	}

	function each(callback) {
		for (var key in memoryStorage) {
			if (memoryStorage.hasOwnProperty(key)) {
				callback(memoryStorage[key], key);
			}
		}
	}

	function remove(key) {
		delete memoryStorage[key];
	}

	function clearAll(key) {
		memoryStorage = {};
	}
	return memoryStorage_1;
}

var memoryStorageExports = requireMemoryStorage();
var memoryStorage = /*@__PURE__*/getDefaultExportFromCjs(memoryStorageExports);

var a$4 = /*#__PURE__*/_mergeNamespaces({
	__proto__: null,
	default: memoryStorage
}, [memoryStorageExports]);

function s$2(t,e){ void 0===e&&(e=false),t+="";for(var r,n=["Ù ","Ù¡","Ù¢","Ù£","Ù¤","Ù¥","Ù¦","Ù§","Ù¨","Ù©"],o=["0","1","2","3","4","5","6","7","8","9"],i=(e=e||!Salla.config.get("store.settings.arabic_numbers_enabled"))?n:o,a=e?o:n,s=0;s<i.length;s++)r=new RegExp(i[s],"g"),t=t.replace(r,a[s]);return t.replace(e?"Ù«":".",e?".":"Ù«")}function l$2(t){var e=("".concat(t).match(/\./g)||[]).length;return e&&1!==e?l$2(t.replace(/\.(.+)\./g,".$1")):t}function c$3(t){return "".concat(t).startsWith("https://")||"".concat(t).startsWith("http://")}function u$3(t){if(c$3(t))return t;var e=Salla.config.get("store.url");return e||(e=window.location.href.split("/").slice(0,-1).join("/"),Salla.config.set("store.url",e)),e.rtrim("/")+"/"+(null==t?void 0:t.ltrim("/"))}function p$1(t,e,r){if(r=r||window.location.href,!e||!t)return r;var n=new RegExp("([?&])"+t+"=[^&]+[&]?","g");return (r=r.replace(n,"$1").split("#")[0].replace(/&$|\?$/,"")).includes("?")?r+="&":r+=(r.endsWith("/")?"":"/")+"?",(r+t+"="+encodeURIComponent(e)).replace(/&$|\?$/,"")}function f$2(t){return window.location.origin+"/"+(null==t?void 0:t.ltrim("/"))}function d$3(t){return c$3(t)?t:Salla.config.get("theme.assets")?Salla.config.get("theme.assets").replace(":path",null==t?void 0:t.ltrim("/")):f$2("themes/"+Salla.config.get("theme.name")+"/"+(null==t?void 0:t.ltrim("/")))}String.prototype.toStudlyCase=function(){return this.trim().replace(/([^a-zA-Z\d].)/g,(function(t){return t.toUpperCase().replace(/[^a-zA-Z\d]/g,"")}))},String.prototype.toDatasetName=function(){return this.startsWith("data-")?this.substr(5).toStudlyCase():this.toStudlyCase()},String.prototype.toSelector=function(){return this.trim().startsWith(".")||this.trim().startsWith("#")?this.toString():"#"+this.toString()},String.prototype.replaceArray=function(t,e){for(var r,n=this,o=0;o<t.length;o++)r=new RegExp(t[o],"g"),n=n.replace(r,e[o]);return n},String.prototype.rtrim=function(t){return void 0===t&&(t="\\s"),this.replace(new RegExp("["+t+"]*$"),"")},String.prototype.ltrim=function(t){return void 0===t&&(t="\\s"),this.replace(new RegExp("^["+t+"]*"),"")},String.prototype.digitsOnly=function(){return Salla.helpers.digitsOnly(this)};var h$3=Object.freeze({__proto__:null,addParamToUrl:p$1,api:function(t){var e;return (null===(e=Salla.config.get("store.api",u$3("")))||void 0===e?void 0:e.rtrim("/"))+"/"+(null==t?void 0:t.ltrim("/"))},asset:d$3,base:function(t){return c$3(t)?t:"https://"+new URL(u$3("/")).hostname+"/"+(null==t?void 0:t.ltrim("/"))},baseUrl:f$2,cdn:function(t,e,r){var n="https://cdn.salla.network/";return (e||r)&&(e=e?",width=".concat(e):"",r=r?",height=".concat(r):"",n+="cdn-cgi/image/fit=scale-down".concat(e).concat(r,",onerror=redirect,format=auto/")),n+(null==t?void 0:t.ltrim("/"))},create:function(t,e){return "custom"===t?e:u$3("offers"===t?t:"redirect/".concat(t,"/").concat(e))},domain:function(t){return c$3(t)?t:"".concat(Salla.config.get("store.url",window.location.href.split("/").slice(0,-1).join("/")).rtrim("/"),"/").concat(null==t?void 0:t.ltrim("/"))},get:u$3,is_full_url:c$3,is_page:function(t){return t&&Salla.config.get("page.slug")===t},is_placeholder:function(t){return d$3(salla.config.get("theme.settings.placeholder"))===d$3(t)}}),g$3=function(t,e){return g$3=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e;}||function(t,e){for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&(t[r]=e[r]);},g$3(t,e)};var y$3=function(){return y$3=Object.assign||function(t){for(var e,r=1,n=arguments.length;r<n;r++)for(var o in e=arguments[r])Object.prototype.hasOwnProperty.call(e,o)&&(t[o]=e[o]);return t},y$3.apply(this,arguments)};function v$2(t,e,r){if(2===arguments.length)for(var n,o=0,i=e.length;o<i;o++)!n&&o in e||(n||(n=Array.prototype.slice.call(e,0,o)),n[o]=e[o]);return t.concat(n||Array.prototype.slice.call(e))}function m$3(t){return t instanceof FormData}function w$2(t){return t instanceof File}function S$2(t){return t instanceof Blob}"function"==typeof SuppressedError&&SuppressedError;var b$5=function(){function t(t){this.data=t,this.proxy=this.createProxy();}return t.prototype.createProxy=function(){var t=this;return new Proxy(this,{get:function(e,r){return r in e?e[r]:"string"==typeof r?t.get(r):void 0},set:function(e,r,n){return "string"==typeof r&&(t.set(r,n),true)},has:function(e,r){return "string"==typeof r?t.has(r):r in e},deleteProperty:function(e,r){return "string"==typeof r&&t.delete(r)}})},t.prototype.get=function(t){return m$3(this.data)?this.data.get(t):this.data[t]},t.prototype.getAll=function(t){if(m$3(this.data))return this.data.getAll(t);var e=this.data[t];return void 0===e?[]:[e]},t.prototype.set=function(t,e){var r=this;m$3(this.data)?(this.data.delete(t),null!=e&&(Array.isArray(e)?e.forEach((function(e){w$2(e)||S$2(e)?r.data.append(t,e):r.data.append(t,String(e));})):w$2(e)||S$2(e)?this.data.append(t,e):this.data.append(t,String(e)))):this.data[t]=e;},t.prototype.append=function(t,e){if(m$3(this.data))w$2(e)||S$2(e)?this.data.append(t,e):null!=e&&this.data.append(t,String(e));else {var r=this.data[t];void 0===r?this.data[t]=e:Array.isArray(r)?r.push(e):this.data[t]=[r,e];}},t.prototype.setFile=function(t,e){this.set(t,e);},t.prototype.getFile=function(t){var e=this.get(t);return w$2(e)?e:null},t.prototype.getFiles=function(t){return this.getAll(t).filter(w$2)},t.prototype.has=function(t){return m$3(this.data)?this.data.has(t):t in this.data},t.prototype.delete=function(t){return m$3(this.data)?(this.data.delete(t),true):delete this.data[t]},t.prototype.keys=function(){if(!m$3(this.data))return Object.keys(this.data);for(var t=new Set,e=0,r=this.data.entries();e<r.length;e++){var n=r[e][0];t.add(n);}return Array.from(t)},t.prototype.values=function(){if(!m$3(this.data))return Object.values(this.data);for(var t=[],e=0,r=this.data.entries();e<r.length;e++){var n=r[e][1];t.push(n);}return t},t.prototype.entries=function(){return m$3(this.data)?Array.from(this.data.entries()):Object.entries(this.data)},t.prototype.toObject=function(){if(!m$3(this.data))return y$3({},this.data);for(var t={},e=0,r=this.data.entries();e<r.length;e++){var n=r[e],o=n[0],i=n[1];void 0!==t[o]?(Array.isArray(t[o])||(t[o]=[t[o]]),t[o].push(i)):t[o]=i;}return t},t.prototype.getFileInfo=function(t){var e=this.getFiles(t);return 0===e.length?null:e.map((function(t){return {name:t.name,size:t.size,type:t.type}}))},t.prototype.isFile=function(t){var e=this.get(t);return w$2(e)||S$2(e)},t.prototype.getRawData=function(){return this.data},t.prototype.getProxy=function(){return this.proxy},t}();function _$2(t,e,r){var n,o=t[0];return r&&0==t.length?Array.isArray(r)?(r.push(e),r):[r,e]:Array.isArray(r)?(r.push(e),r):"string"==typeof r?[r,e]:r?(r[o]=_$2(t.slice(1),e,r[o]),r):o?((n={})[o]=_$2(t.slice(1),e),n):""===o?[e]:e}function x$3(){return window.self!==window.top}var A$3,E$3,k$3,P$2,O$2={digitsOnly:function(t){return s$2(t,true).replace(/[^0-9.]/g,"").replace("..",".").rtrim(".")},inputDigitsOnly:function t(e,r){if(void 0===r&&(r=false),"string"==typeof e)return document.querySelectorAll(e).forEach((function(e){return t(e,r)}));if(e){var n=Salla.helpers.digitsOnly(e.value);return e.min&&n<parseInt(e.min)?e.value=e.min:e.max&&n>parseInt(e.max)?e.value=e.max:e.maxLength>=1&&n.toString().length>e.maxLength?e.value=n.toString().substring(0,e.maxLength):e.value=r||e.dataset.hasOwnProperty("digitsWithDecimal")?l$2(n):n.replace(/\D/g,"")}Salla.logger.warn("Can't find Object With Id: "+e);},number:s$2,money:function(t,e){ void 0===e&&(e=true);var r=Salla.config.currency(null==t?void 0:t.currency).symbol;return t=s$2(t="object"==typeof t?t.amount:t)+" "+r,e&&["SAR","Ø±.Ø³"].includes(r)&&Salla.config.get("store.settings.use_sar_symbol")&&(t=t.replace(r,"<i class=sicon-sar></i>")),t},isIframe:x$3,isPreview:function(){return x$3()},setNested:function(t,e,r){for(var n=t,o=e.split("."),i=o.length,a=0;a<i-1;a++){var s=o[a];n[s]||(n[s]={}),n=n[s];}return n[o[i-1]]=r,t},getNested:function(e,r,n){var o=t$2.default?t$2.default(e,r):t$2(e,r);return void 0!==o?o:n},inputData:function(t,e,r){if(void 0===r&&(r={}),t.includes("[")){var n=t.split("]").join("").split("["),o=n[0],i=r&&"object"==typeof r?r[o]:void 0;return {name:o,value:_$2(n.slice(1),e,i)}}return {name:t,value:e}},url:h$3,addParamToUrl:p$1,debounce:function(t,e){e=e||100;var r,n=[];return function(){for(var o=[],i=0;i<arguments.length;i++)o[i]=arguments[i];return clearTimeout(r),r=setTimeout((function(){var e=t.apply(void 0,o);n.forEach((function(t){return t(e)})),n=[];}),e),new Promise((function(t){return n.push(t)}))}},hasApplePay:function(){var t;try{return !!(null===(t=window.ApplePaySession)||void 0===t?void 0:t.canMakePayments())}catch(t){return console.error(t),false}},createFormDataWrapper:function(t){return new b$5(t).getProxy()},isAppleDevice:function(){try{var t=navigator.userAgent||"",e=navigator.platform||"",r=/iPhone|iPad|iPod/i.test(t),n=/Mac/i.test(e);return r||n}catch(t){return console.error(t),false}}},j$3=(A$3=console,E$3=[],k$3=[],P$2={log:function(t,e){if(A$3&&salla.config.isDebug()){E$3.push([e,t]),"trace"===salla.config.get("debug")&&(e="trace");var r=A$3.log,n=void 0===e?r:this.__dict__[e]||r,o=["%cTwilight","color: #5cd5c4;font-weight:bold; border:1px solid #5cd5c4; padding: 2px 6px; border-radius: 5px;"];k$3.forEach((function(t){o[0]+=t[0],o.push(t[1]);}));var i={event:"#CFF680",backend:"#7b68ee"}[e];i&&(o[0]+="%c"+e[0].toUpperCase()+e.substring(1),o.push("margin-left: 5px;color: ".concat(i,";font-weight:bold; border:1px solid ").concat(i,"; padding: 2px 6px; border-radius: 5px;"))),n.call.apply(n,v$2([A$3],o.concat.apply(o,t),false));}},__dict__:{trace:A$3.trace,debug:A$3.debug,info:A$3.info,warn:A$3.warn,error:A$3.error}},{event:function(){P$2.log(arguments,"event");},trace:function(){P$2.log(arguments,"trace");},debug:function(){P$2.log(arguments,"debug");},info:function(){P$2.log(arguments,"info");},warn:function(){P$2.log(arguments,"warn");},error:function(){P$2.log(arguments,"error");},log:function(){P$2.log(arguments,void 0);},backend:function(){P$2.log(arguments,"backend");},logs:function(t){[t].flat().forEach((function(t){return t&&P$2.log([t].flat(),"backend")}));},history:function(){return E$3.map((function(t){return A$3.log.apply(A$3,v$2([t[0]],t[1],false))})),E$3},addPrefix:function(t){return Array.isArray(t)?k$3.unshift(t):this.warn("addPrefix receives array only!"),this}}),T$2=function(){function t(t,e){ void 0===t&&(t={}),void 0===e&&(e={}),this.default_properties=e,this.properties_=y$3(y$3({},this.default_properties),t);}return t.prototype.merge=function(t){var e;return this.properties_=y$3(y$3({},this.properties_),t),this.properties_.store=y$3(y$3({},(null===(e=this.default_properties)||void 0===e?void 0:e.store)||{}),this.properties_.store),this},t.prototype.set=function(t,e){return t.includes(".")?(Salla.helpers.setNested(this.properties_,t,e),this):(this.properties_[t]=e,this)},t.prototype.currency=function(t){return void 0===t&&(t=void 0),t=t||this.get("user.currency_code"),this.get("currencies."+t)||Object.values(this.get("currencies"))[0]},t.prototype.get=function(t,e){return void 0===e&&(e=null),t.includes(".")?Salla.helpers.getNested(this.properties_,t,e):this.properties_.hasOwnProperty(t)?this.properties_[t]||e:e||void 0},t.prototype.all=function(){return this.properties_},t.prototype.isDebug=function(){return this.get("debug")||Salla.storage.get("debug")},t}(),L$3=function(t){function e(){var e=this;return (e=t.call(this,{wildcard:true,delimiter:"::",newListener:false,removeListener:false,maxListeners:10,verboseMemoryLeak:false,ignoreErrors:false})||this).delimiter="::","undefined"!=typeof document&&(e.body=document.querySelector("body")),e.logableEvents=["cart::item.added.failed","cart::item.deleted.failed"],e.ingoreLogEvents=["document::click","document::keyup","document::change"],e.noneFireableActions=["document.request"],e.emittedEvents=new Set,e}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Class extends value "+String(e)+" is not a constructor or null");function r(){this.constructor=t;}g$3(t,e),t.prototype=null===e?Object.create(e):(r.prototype=e.prototype,new r);}(e,t),e.prototype.createAndDispatch=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];this.dispatch.apply(this,v$2([t],e,false));},e.prototype.emit=function(e){for(var r,n=[],o=1;o<arguments.length;o++)n[o-1]=arguments[o];this.emittedEvents.add(e);var i=e.replace("::",".");if(!this.noneFireableActions.includes(i)&&Salla.call&&"function"==typeof Salla.call(i))return Salla.log("'Salla.".concat(i,"(...)' triggered using event '").concat(e,"'")),i=i.split("."),Array.isArray(n[0])&&(n=n[0]),void(r=salla[i[0]])[i[1]].apply(r,n);t.prototype.emit.apply(this,v$2([e],n,false)),this.trackEvents.apply(this,v$2([e],n,false));},e.prototype.onlyWhen=function(t,e){var r=this;return e=e||function(){},new Promise((function(n){return r.emittedEvents.has(t)?n(e()):r.once(t,(function(){return n(e())}))}))},e.prototype.emitAsync=function(e){for(var r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];this.emittedEvents.add(e);var o=t.prototype.emitAsync.apply(this,v$2([e],r,false));try{this.trackEvents.apply(this,v$2([e],r,false));}catch(t){Salla.logger.warn("error on tracking event (".concat(e,")"),r,t);}return o},e.prototype.trackEvents=function(t){for(var e,r=[],n=1;n<arguments.length;n++)r[n-1]=arguments[n];if("undefined"!=typeof window)try{window.dataLayer=window.dataLayer||[];var o={event:t};r.map((function(t){return "object"==typeof t&&(o=y$3(y$3({},o),t))})),window.dataLayer.push(o);}catch(t){salla.logger.error(t.message);}Salla.logger&&!this.ingoreLogEvents.includes(t)&&(e=Salla.logger).event.apply(e,v$2([t],r,false)),this.dispatchMobileEvent.apply(this,v$2([t],r,false));},e.prototype.dispatch=function(t){for(var e=[],r=1;r<arguments.length;r++)e[r-1]=arguments[r];return this.emit.apply(this,v$2([t],e,false))},e.prototype.dispatchEvents=function(t){if(t)if("object"!=typeof t||Array.isArray(t))Salla.log("Events object is wrong, it should be object of {event:payload}",t);else for(var e=0,r=Object.entries(t);e<r.length;e++){var n=r[e],o=n[0],i=n[1];this.dispatch(o,i);}else Salla.log("No Events To Dispatch!",t);},e.prototype.addListener=function(t,e,r){return this.on(t,e,r)},e.prototype.addEventListener=function(t,e,r){return this.on(t,e,r)},e.prototype.listen=function(t,e){return this.on(t,e)},e.prototype.registerGlobalListener=function(t,e){return this.onAny(e)},e.prototype.dispatchMobileEvent=function(t,e){var r;if(void 0===e&&(e={}),"undefined"!=typeof window){if(window.webkit)try{return void window.webkit.messageHandlers.callbackHandler.postMessage(JSON.stringify({event:t,details:e}))}catch(t){Salla.log(t,"The native context does not exist yet");}if(null===(r=window.Android)||void 0===r?void 0:r.customEventWithData)try{window.Android.customEventWithData(t,JSON.stringify({details:e}));}catch(t){Salla.log(t,"The native context does not exist yet");}else if(window.flutter_inappwebview)try{window.flutter_inappwebview.callHandler("sallaEvent",{event:t,details:e});}catch(t){Salla.log(t,"The Flutter context does not exist yet");}else;}},e}(eventemitter2Exports.EventEmitter2),D$2=storeEngineExports.createStore([n$3,o$3,i$3,a$4],[]),W$3=storeEngineExports.createStore([o$3],[]),F$3=storeEngineExports.createStore([i$3],[]),C$3=function(){function t(){var t=this;this.clearableItems=["cart","user","salla::wishlist","token"],Salla.event.on("storage::item.remove",(function(e){return t.remove(e)})),Salla.event.on("storage::item.set",(function(e,r){return t.set(e,r)})),this.store=D$2,this.session=W$3,this.cookie=F$3;}return t.prototype.set=function(t,e){var r;if(t.includes(".")){var n=t.split(".")[0],o=((r={})[n]=this.store.get(n),r);return o=Salla.helpers.setNested(o,t,e),this.store.set(n,o[n])}return this.store.set(t,e)},t.prototype.remove=function(t){return this.store.remove(t)},t.prototype.clearAll=function(t){var e=this;if(void 0===t&&(t=false),t)return this.store.clearAll();this.clearableItems.forEach((function(t){e.store.remove(t);}));},t.prototype.get=function(t,e){var r;if(t.includes(".")){var n=t.split(".")[0];return Salla.helpers.getNested(((r={})[n]=this.store.get(n),r),t)}return this.store.get(t,e)},t.prototype.prefixKey=function(t){return "".concat(t,"_").concat(Salla.config.get("store.id"))},t.prototype.setWithTTL=function(t,e,r,n){ void 0===r&&(r=10),void 0===n&&(n="store");var o=this.prefixKey(t),i=(new Date).getTime()+60*r*1e3;return this[n].set(o,{value:e,expiry:i})},t.prototype.getWithTTL=function(t,e,r){ void 0===e&&(e=null),void 0===r&&(r="store");var n=this.prefixKey(t),o=this[r].get(n);return o?(new Date).getTime()>o.expiry?(this[r].remove(n),e):o.value:e},t}(),R$3=function(){function t(){var t=this;this.keysToRemove=["__said","__ssid","theme_edit","ws_port","s-token"],this.dynamicKeysToRemove=["affiliate","cart"],Salla.event.on("cookies::remove",(function(e){return t.remove(e)})),Salla.event.on("cookies::add",(function(e,r){return t.set(e,r)}));}return t.prototype.get=function(t){var e;return null===(e=document.cookie.split("; ").find((function(e){return e.startsWith(t+"=")})))||void 0===e?void 0:e.split("=")[1]},t.prototype.set=function(t,e,r){ void 0===e&&(e=""),void 0===r&&(r=10);var n="";if(r){var o=new Date;o.setTime(o.getTime()+24*r*60*60*1e3),n="; expires="+o.toUTCString();}var i=salla.helpers.isIframe()?"None":"Lax";return document.cookie="".concat(t,"=").concat(e).concat(n,"; path=/; SameSite=").concat(i,"; secure"),this},t.prototype.remove=function(t){var e=salla.helpers.isIframe()?"None":"Lax";return document.cookie="".concat(t,"=; Max-Age=0; path=/; SameSite=").concat(e,"; secure"),this},t.prototype.clearAll=function(t){return void 0===t&&(t=false),this.clean(t)},t.prototype.clean=function(t){var e=this;return document.cookie.split(";").map((function(t){return t.split("=")[0].trim()})).filter((function(r){return t||e.keysToRemove.includes(r)||e.dynamicKeysToRemove.some((function(t){return r.startsWith(t)}))})).forEach((function(t){return e.remove(t)})),this},t.prototype.getCookieByPrefix=function(t){return document.cookie.split("; ").map((function(t){return t.split("=")[0]})).filter((function(e){return e.startsWith(t)}))},t.prototype.clearCookieByPrefix=function(t){var e=this;return this.getCookieByPrefix(t).forEach((function(t){return e.remove(t)}))},t}();"undefined"!=typeof window&&(window.salla=window.salla||window.Salla||{},window.Salla=window.salla),"undefined"!=typeof global&&(global.salla=global.salla||global.Salla||{},global.Salla=global.salla),Salla.status="base",Salla.config=new T$2,Salla.logger=j$3,Salla.event=new L$3,Salla.helpers=O$2,Salla.storage=new C$3,Salla.cookie=new R$3,Salla.log=Salla.logger.log,Salla.money=Salla.helpers.money,Salla.url=Salla.helpers.url,Salla.versions={base:"2.14.310"};var N$3=Salla;

var js = {exports: {}};

var core = {exports: {}};

var evEmitter$1 = {exports: {}};

/**
 * EvEmitter v2.1.1
 * Lil' event emitter
 * MIT License
 */
var evEmitter = evEmitter$1.exports;

var hasRequiredEvEmitter;

function requireEvEmitter () {
	if (hasRequiredEvEmitter) return evEmitter$1.exports;
	hasRequiredEvEmitter = 1;
	(function (module) {
		( function( global, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS - Browserify, Webpack
		    module.exports = factory();
		  } else {
		    // Browser globals
		    global.EvEmitter = factory();
		  }

		}( typeof window != 'undefined' ? window : evEmitter, function() {

		function EvEmitter() {}

		let proto = EvEmitter.prototype;

		proto.on = function( eventName, listener ) {
		  if ( !eventName || !listener ) return this;

		  // set events hash
		  let events = this._events = this._events || {};
		  // set listeners array
		  let listeners = events[ eventName ] = events[ eventName ] || [];
		  // only add once
		  if ( !listeners.includes( listener ) ) {
		    listeners.push( listener );
		  }

		  return this;
		};

		proto.once = function( eventName, listener ) {
		  if ( !eventName || !listener ) return this;

		  // add event
		  this.on( eventName, listener );
		  // set once flag
		  // set onceEvents hash
		  let onceEvents = this._onceEvents = this._onceEvents || {};
		  // set onceListeners object
		  let onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};
		  // set flag
		  onceListeners[ listener ] = true;

		  return this;
		};

		proto.off = function( eventName, listener ) {
		  let listeners = this._events && this._events[ eventName ];
		  if ( !listeners || !listeners.length ) return this;

		  let index = listeners.indexOf( listener );
		  if ( index != -1 ) {
		    listeners.splice( index, 1 );
		  }

		  return this;
		};

		proto.emitEvent = function( eventName, args ) {
		  let listeners = this._events && this._events[ eventName ];
		  if ( !listeners || !listeners.length ) return this;

		  // copy over to avoid interference if .off() in listener
		  listeners = listeners.slice( 0 );
		  args = args || [];
		  // once stuff
		  let onceListeners = this._onceEvents && this._onceEvents[ eventName ];

		  for ( let listener of listeners ) {
		    let isOnce = onceListeners && onceListeners[ listener ];
		    if ( isOnce ) {
		      // remove listener
		      // remove before trigger to prevent recursion
		      this.off( eventName, listener );
		      // unset once flag
		      delete onceListeners[ listener ];
		    }
		    // trigger listener
		    listener.apply( this, args );
		  }

		  return this;
		};

		proto.allOff = function() {
		  delete this._events;
		  delete this._onceEvents;
		  return this;
		};

		return EvEmitter;

		} ) ); 
	} (evEmitter$1));
	return evEmitter$1.exports;
}

var utils$1 = {exports: {}};

/**
 * Fizzy UI utils v3.0.0
 * MIT license
 */
var utils = utils$1.exports;

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils$1.exports;
	hasRequiredUtils = 1;
	(function (module) {
		( function( global, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory( global );
		  } else {
		    // browser global
		    global.fizzyUIUtils = factory( global );
		  }

		}( utils, function factory( global ) {

		let utils = {};

		// ----- extend ----- //

		// extends objects
		utils.extend = function( a, b ) {
		  return Object.assign( a, b );
		};

		// ----- modulo ----- //

		utils.modulo = function( num, div ) {
		  return ( ( num % div ) + div ) % div;
		};

		// ----- makeArray ----- //

		// turn element or nodeList into an array
		utils.makeArray = function( obj ) {
		  // use object if already an array
		  if ( Array.isArray( obj ) ) return obj;

		  // return empty array if undefined or null. #6
		  if ( obj === null || obj === undefined ) return [];

		  let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';
		  // convert nodeList to array
		  if ( isArrayLike ) return [ ...obj ];

		  // array of single index
		  return [ obj ];
		};

		// ----- removeFrom ----- //

		utils.removeFrom = function( ary, obj ) {
		  let index = ary.indexOf( obj );
		  if ( index != -1 ) {
		    ary.splice( index, 1 );
		  }
		};

		// ----- getParent ----- //

		utils.getParent = function( elem, selector ) {
		  while ( elem.parentNode && elem != document.body ) {
		    elem = elem.parentNode;
		    if ( elem.matches( selector ) ) return elem;
		  }
		};

		// ----- getQueryElement ----- //

		// use element as selector string
		utils.getQueryElement = function( elem ) {
		  if ( typeof elem == 'string' ) {
		    return document.querySelector( elem );
		  }
		  return elem;
		};

		// ----- handleEvent ----- //

		// enable .ontype to trigger from .addEventListener( elem, 'type' )
		utils.handleEvent = function( event ) {
		  let method = 'on' + event.type;
		  if ( this[ method ] ) {
		    this[ method ]( event );
		  }
		};

		// ----- filterFindElements ----- //

		utils.filterFindElements = function( elems, selector ) {
		  // make array of elems
		  elems = utils.makeArray( elems );

		  return elems
		    // check that elem is an actual element
		    .filter( ( elem ) => elem instanceof HTMLElement )
		    .reduce( ( ffElems, elem ) => {
		      // add elem if no selector
		      if ( !selector ) {
		        ffElems.push( elem );
		        return ffElems;
		      }
		      // filter & find items if we have a selector
		      // filter
		      if ( elem.matches( selector ) ) {
		        ffElems.push( elem );
		      }
		      // find children
		      let childElems = elem.querySelectorAll( selector );
		      // concat childElems to filterFound array
		      ffElems = ffElems.concat( ...childElems );
		      return ffElems;
		    }, [] );
		};

		// ----- debounceMethod ----- //

		utils.debounceMethod = function( _class, methodName, threshold ) {
		  threshold = threshold || 100;
		  // original method
		  let method = _class.prototype[ methodName ];
		  let timeoutName = methodName + 'Timeout';

		  _class.prototype[ methodName ] = function() {
		    clearTimeout( this[ timeoutName ] );

		    let args = arguments;
		    this[ timeoutName ] = setTimeout( () => {
		      method.apply( this, args );
		      delete this[ timeoutName ];
		    }, threshold );
		  };
		};

		// ----- docReady ----- //

		utils.docReady = function( onDocReady ) {
		  let readyState = document.readyState;
		  if ( readyState == 'complete' || readyState == 'interactive' ) {
		    // do async to allow for other scripts to run. metafizzy/flickity#441
		    setTimeout( onDocReady );
		  } else {
		    document.addEventListener( 'DOMContentLoaded', onDocReady );
		  }
		};

		// ----- htmlInit ----- //

		// http://bit.ly/3oYLusc
		utils.toDashed = function( str ) {
		  return str.replace( /(.)([A-Z])/g, function( match, $1, $2 ) {
		    return $1 + '-' + $2;
		  } ).toLowerCase();
		};

		let console = global.console;

		// allow user to initialize classes via [data-namespace] or .js-namespace class
		// htmlInit( Widget, 'widgetName' )
		// options are parsed from data-namespace-options
		utils.htmlInit = function( WidgetClass, namespace ) {
		  utils.docReady( function() {
		    let dashedNamespace = utils.toDashed( namespace );
		    let dataAttr = 'data-' + dashedNamespace;
		    let dataAttrElems = document.querySelectorAll( `[${dataAttr}]` );
		    let jQuery = global.jQuery;

		    [ ...dataAttrElems ].forEach( ( elem ) => {
		      let attr = elem.getAttribute( dataAttr );
		      let options;
		      try {
		        options = attr && JSON.parse( attr );
		      } catch ( error ) {
		        // log error, do not initialize
		        if ( console ) {
		          console.error( `Error parsing ${dataAttr} on ${elem.className}: ${error}` );
		        }
		        return;
		      }
		      // initialize
		      let instance = new WidgetClass( elem, options );
		      // make available via $().data('namespace')
		      if ( jQuery ) {
		        jQuery.data( elem, namespace, instance );
		      }
		    } );

		  } );
		};

		// -----  ----- //

		return utils;

		} ) ); 
	} (utils$1));
	return utils$1.exports;
}

var hasRequiredCore;

function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module) {
		// core
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireEvEmitter(),
		        requireUtils(),
		    );
		  } else {
		    // browser global
		    window.InfiniteScroll = factory(
		        window,
		        window.EvEmitter,
		        window.fizzyUIUtils,
		    );
		  }

		}( window, function factory( window, EvEmitter, utils ) {

		let jQuery = window.jQuery;
		// internal store of all InfiniteScroll intances
		let instances = {};

		function InfiniteScroll( element, options ) {
		  let queryElem = utils.getQueryElement( element );

		  if ( !queryElem ) {
		    console.error( 'Bad element for InfiniteScroll: ' + ( queryElem || element ) );
		    return;
		  }
		  element = queryElem;
		  // do not initialize twice on same element
		  if ( element.infiniteScrollGUID ) {
		    let instance = instances[ element.infiniteScrollGUID ];
		    instance.option( options );
		    return instance;
		  }

		  this.element = element;
		  // options
		  this.options = { ...InfiniteScroll.defaults };
		  this.option( options );
		  // add jQuery
		  if ( jQuery ) {
		    this.$element = jQuery( this.element );
		  }

		  this.create();
		}

		// defaults
		InfiniteScroll.defaults = {
		  // path: null,
		  // hideNav: null,
		  // debug: false,
		};

		// create & destroy methods
		InfiniteScroll.create = {};
		InfiniteScroll.destroy = {};

		let proto = InfiniteScroll.prototype;
		// inherit EvEmitter
		Object.assign( proto, EvEmitter.prototype );

		// --------------------------  -------------------------- //

		// globally unique identifiers
		let GUID = 0;

		proto.create = function() {
		  // create core
		  // add id for InfiniteScroll.data
		  let id = this.guid = ++GUID;
		  this.element.infiniteScrollGUID = id; // expando
		  instances[ id ] = this; // associate via id
		  // properties
		  this.pageIndex = 1; // default to first page
		  this.loadCount = 0;
		  this.updateGetPath();
		  // bail if getPath not set, or returns falsey #776
		  let hasPath = this.getPath && this.getPath();
		  if ( !hasPath ) {
		    console.error('Disabling InfiniteScroll');
		    return;
		  }
		  this.updateGetAbsolutePath();
		  this.log( 'initialized', [ this.element.className ] );
		  this.callOnInit();
		  // create features
		  for ( let method in InfiniteScroll.create ) {
		    InfiniteScroll.create[ method ].call( this );
		  }
		};

		proto.option = function( opts ) {
		  Object.assign( this.options, opts );
		};

		// call onInit option, used for binding events on init
		proto.callOnInit = function() {
		  let onInit = this.options.onInit;
		  if ( onInit ) {
		    onInit.call( this, this );
		  }
		};

		// ----- events ----- //

		proto.dispatchEvent = function( type, event, args ) {
		  this.log( type, args );
		  let emitArgs = event ? [ event ].concat( args ) : args;
		  this.emitEvent( type, emitArgs );
		  // trigger jQuery event
		  if ( !jQuery || !this.$element ) {
		    return;
		  }
		  // namespace jQuery event
		  type += '.infiniteScroll';
		  let $event = type;
		  if ( event ) {
		    // create jQuery event
		    /* eslint-disable-next-line new-cap */
		    let jQEvent = jQuery.Event( event );
		    jQEvent.type = type;
		    $event = jQEvent;
		  }
		  this.$element.trigger( $event, args );
		};

		let loggers = {
		  initialized: ( className ) => `on ${className}`,
		  request: ( path ) => `URL: ${path}`,
		  load: ( response, path ) => `${response.title || ''}. URL: ${path}`,
		  error: ( error, path ) => `${error}. URL: ${path}`,
		  append: ( response, path, items ) => `${items.length} items. URL: ${path}`,
		  last: ( response, path ) => `URL: ${path}`,
		  history: ( title, path ) => `URL: ${path}`,
		  pageIndex: function( index, origin ) {
		    return `current page determined to be: ${index} from ${origin}`;
		  },
		};

		// log events
		proto.log = function( type, args ) {
		  if ( !this.options.debug ) return;

		  let message = `[InfiniteScroll] ${type}`;
		  let logger = loggers[ type ];
		  if ( logger ) message += '. ' + logger.apply( this, args );
		  console.log( message );
		};

		// -------------------------- methods used amoung features -------------------------- //

		proto.updateMeasurements = function() {
		  this.windowHeight = window.innerHeight;
		  let rect = this.element.getBoundingClientRect();
		  this.top = rect.top + window.scrollY;
		};

		proto.updateScroller = function() {
		  let elementScroll = this.options.elementScroll;
		  if ( !elementScroll ) {
		    // default, use window
		    this.scroller = window;
		    return;
		  }
		  // if true, set to element, otherwise use option
		  this.scroller = elementScroll === true ? this.element :
		    utils.getQueryElement( elementScroll );
		  if ( !this.scroller ) {
		    throw new Error(`Unable to find elementScroll: ${elementScroll}`);
		  }
		};

		// -------------------------- page path -------------------------- //

		proto.updateGetPath = function() {
		  let optPath = this.options.path;
		  if ( !optPath ) {
		    console.error(`InfiniteScroll path option required. Set as: ${optPath}`);
		    return;
		  }
		  // function
		  let type = typeof optPath;
		  if ( type == 'function' ) {
		    this.getPath = optPath;
		    return;
		  }
		  // template string: '/pages/{{#}}.html'
		  let templateMatch = type == 'string' && optPath.match('{{#}}');
		  if ( templateMatch ) {
		    this.updateGetPathTemplate( optPath );
		    return;
		  }
		  // selector: '.next-page-selector'
		  this.updateGetPathSelector( optPath );
		};

		proto.updateGetPathTemplate = function( optPath ) {
		  // set getPath with template string
		  this.getPath = () => {
		    let nextIndex = this.pageIndex + 1;
		    return optPath.replace( '{{#}}', nextIndex );
		  };
		  // get pageIndex from location
		  // convert path option into regex to look for pattern in location
		  // escape query (?) in url, allows for parsing GET parameters
		  let regexString = optPath
		    .replace( /(\\\?|\?)/, '\\?' )
		    .replace( '{{#}}', '(\\d\\d?\\d?)' );
		  let templateRe = new RegExp( regexString );
		  let match = location.href.match( templateRe );

		  if ( match ) {
		    this.pageIndex = parseInt( match[1], 10 );
		    this.log( 'pageIndex', [ this.pageIndex, 'template string' ] );
		  }
		};

		let pathRegexes = [
		  // WordPress & Tumblr - example.com/page/2
		  // Jekyll - example.com/page2
		  /^(.*?\/?page\/?)(\d\d?\d?)(.*?$)/,
		  // Drupal - example.com/?page=1
		  /^(.*?\/?\?page=)(\d\d?\d?)(.*?$)/,
		  // catch all, last occurence of a number
		  /(.*?)(\d\d?\d?)(?!.*\d)(.*?$)/,
		];

		// try matching href to pathRegexes patterns
		let getPathParts = InfiniteScroll.getPathParts = function( href ) {
		  if ( !href ) return;
		  for ( let regex of pathRegexes ) {
		    let match = href.match( regex );
		    if ( match ) {
		      let [ , begin, index, end ] = match;
		      return { begin, index, end };
		    }
		  }
		};

		proto.updateGetPathSelector = function( optPath ) {
		  // parse href of link: '.next-page-link'
		  let hrefElem = document.querySelector( optPath );
		  if ( !hrefElem ) {
		    console.error(`Bad InfiniteScroll path option. Next link not found: ${optPath}`);
		    return;
		  }

		  let href = hrefElem.getAttribute('href');
		  let pathParts = getPathParts( href );
		  if ( !pathParts ) {
		    console.error(`InfiniteScroll unable to parse next link href: ${href}`);
		    return;
		  }

		  let { begin, index, end } = pathParts;
		  this.isPathSelector = true; // flag for checkLastPage()
		  this.getPath = () => begin + ( this.pageIndex + 1 ) + end;
		  // get pageIndex from href
		  this.pageIndex = parseInt( index, 10 ) - 1;
		  this.log( 'pageIndex', [ this.pageIndex, 'next link' ] );
		};

		proto.updateGetAbsolutePath = function() {
		  let path = this.getPath();
		  // path doesn't start with http or /
		  let isAbsolute = path.match( /^http/ ) || path.match( /^\// );
		  if ( isAbsolute ) {
		    this.getAbsolutePath = this.getPath;
		    return;
		  }

		  let { pathname } = location;
		  // query parameter #829. example.com/?pg=2
		  let isQuery = path.match( /^\?/ );
		  // /foo/bar/index.html => /foo/bar
		  let directory = pathname.substring( 0, pathname.lastIndexOf('/') );
		  let pathStart = isQuery ? pathname : directory + '/';

		  this.getAbsolutePath = () => pathStart + this.getPath();
		};

		// -------------------------- nav -------------------------- //

		// hide navigation
		InfiniteScroll.create.hideNav = function() {
		  let nav = utils.getQueryElement( this.options.hideNav );
		  if ( !nav ) return;

		  nav.style.display = 'none';
		  this.nav = nav;
		};

		InfiniteScroll.destroy.hideNav = function() {
		  if ( this.nav ) this.nav.style.display = '';
		};

		// -------------------------- destroy -------------------------- //

		proto.destroy = function() {
		  this.allOff(); // remove all event listeners
		  // call destroy methods
		  for ( let method in InfiniteScroll.destroy ) {
		    InfiniteScroll.destroy[ method ].call( this );
		  }

		  delete this.element.infiniteScrollGUID;
		  delete instances[ this.guid ];
		  // remove jQuery data. #807
		  if ( jQuery && this.$element ) {
		    jQuery.removeData( this.element, 'infiniteScroll' );
		  }
		};

		// -------------------------- utilities -------------------------- //

		// https://remysharp.com/2010/07/21/throttling-function-calls
		InfiniteScroll.throttle = function( fn, threshold ) {
		  threshold = threshold || 200;
		  let last, timeout;

		  return function() {
		    let now = +new Date();
		    let args = arguments;
		    let trigger = () => {
		      last = now;
		      fn.apply( this, args );
		    };
		    if ( last && now < last + threshold ) {
		      // hold on to it
		      clearTimeout( timeout );
		      timeout = setTimeout( trigger, threshold );
		    } else {
		      trigger();
		    }
		  };
		};

		InfiniteScroll.data = function( elem ) {
		  elem = utils.getQueryElement( elem );
		  let id = elem && elem.infiniteScrollGUID;
		  return id && instances[ id ];
		};

		// set internal jQuery, for Webpack + jQuery v3
		InfiniteScroll.setJQuery = function( jqry ) {
		  jQuery = jqry;
		};

		// -------------------------- setup -------------------------- //

		utils.htmlInit( InfiniteScroll, 'infinite-scroll' );

		// add noop _init method for jQuery Bridget. #768
		proto._init = function() {};

		let { jQueryBridget } = window;
		if ( jQuery && jQueryBridget ) {
		  jQueryBridget( 'infiniteScroll', InfiniteScroll, jQuery );
		}

		// --------------------------  -------------------------- //

		return InfiniteScroll;

		} ) ); 
	} (core));
	return core.exports;
}

var pageLoad = {exports: {}};

var hasRequiredPageLoad;

function requirePageLoad () {
	if (hasRequiredPageLoad) return pageLoad.exports;
	hasRequiredPageLoad = 1;
	(function (module) {
		// page-load
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireCore(),
		    );
		  } else {
		    // browser global
		    factory(
		        window,
		        window.InfiniteScroll,
		    );
		  }

		}( window, function factory( window, InfiniteScroll ) {

		let proto = InfiniteScroll.prototype;

		Object.assign( InfiniteScroll.defaults, {
		  // append: false,
		  loadOnScroll: true,
		  checkLastPage: true,
		  responseBody: 'text',
		  domParseResponse: true,
		  // prefill: false,
		  // outlayer: null,
		} );

		InfiniteScroll.create.pageLoad = function() {
		  this.canLoad = true;
		  this.on( 'scrollThreshold', this.onScrollThresholdLoad );
		  this.on( 'load', this.checkLastPage );
		  if ( this.options.outlayer ) {
		    this.on( 'append', this.onAppendOutlayer );
		  }
		};

		proto.onScrollThresholdLoad = function() {
		  if ( this.options.loadOnScroll ) this.loadNextPage();
		};

		let domParser = new DOMParser();

		proto.loadNextPage = function() {
		  if ( this.isLoading || !this.canLoad ) return;

		  let { responseBody, domParseResponse, fetchOptions } = this.options;
		  let path = this.getAbsolutePath();
		  this.isLoading = true;
		  if ( typeof fetchOptions == 'function' ) fetchOptions = fetchOptions();

		  let fetchPromise = fetch( path, fetchOptions )
		    .then( ( response ) => {
		      if ( !response.ok ) {
		        let error = new Error( response.statusText );
		        this.onPageError( error, path, response );
		        return { response };
		      }

		      return response[ responseBody ]().then( ( body ) => {
		        let canDomParse = responseBody == 'text' && domParseResponse;
		        if ( canDomParse ) {
		          body = domParser.parseFromString( body, 'text/html' );
		        }
		        if ( response.status == 204 ) {
		          this.lastPageReached( body, path );
		          return { body, response };
		        } else {
		          return this.onPageLoad( body, path, response );
		        }
		      } );
		    } )
		    .catch( ( error ) => {
		      this.onPageError( error, path );
		    } );

		  this.dispatchEvent( 'request', null, [ path, fetchPromise ] );

		  return fetchPromise;
		};

		proto.onPageLoad = function( body, path, response ) {
		  // done loading if not appending
		  if ( !this.options.append ) {
		    this.isLoading = false;
		  }
		  this.pageIndex++;
		  this.loadCount++;
		  this.dispatchEvent( 'load', null, [ body, path, response ] );
		  return this.appendNextPage( body, path, response );
		};

		proto.appendNextPage = function( body, path, response ) {
		  let { append, responseBody, domParseResponse } = this.options;
		  // do not append json
		  let isDocument = responseBody == 'text' && domParseResponse;
		  if ( !isDocument || !append ) return { body, response };

		  let items = body.querySelectorAll( append );
		  let promiseValue = { body, response, items };
		  // last page hit if no items. #840
		  if ( !items || !items.length ) {
		    this.lastPageReached( body, path );
		    return promiseValue;
		  }

		  let fragment = getItemsFragment( items );
		  let appendReady = () => {
		    this.appendItems( items, fragment );
		    this.isLoading = false;
		    this.dispatchEvent( 'append', null, [ body, path, items, response ] );
		    return promiseValue;
		  };

		  // TODO add hook for option to trigger appendReady
		  if ( this.options.outlayer ) {
		    return this.appendOutlayerItems( fragment, appendReady );
		  } else {
		    return appendReady();
		  }
		};

		proto.appendItems = function( items, fragment ) {
		  if ( !items || !items.length ) return;

		  // get fragment if not provided
		  fragment = fragment || getItemsFragment( items );
		  refreshScripts( fragment );
		  this.element.appendChild( fragment );
		};

		function getItemsFragment( items ) {
		  // add items to fragment
		  let fragment = document.createDocumentFragment();
		  if ( items ) fragment.append( ...items );
		  return fragment;
		}

		// replace <script>s with copies so they load
		// <script>s added by InfiniteScroll will not load
		// similar to https://stackoverflow.com/questions/610995
		function refreshScripts( fragment ) {
		  let scripts = fragment.querySelectorAll('script');
		  for ( let script of scripts ) {
		    let freshScript = document.createElement('script');
		    // copy attributes
		    let attrs = script.attributes;
		    for ( let attr of attrs ) {
		      freshScript.setAttribute( attr.name, attr.value );
		    }
		    // copy inner script code. #718, #782
		    freshScript.innerHTML = script.innerHTML;
		    script.parentNode.replaceChild( freshScript, script );
		  }
		}

		// ----- outlayer ----- //

		proto.appendOutlayerItems = function( fragment, appendReady ) {
		  let imagesLoaded = InfiniteScroll.imagesLoaded || window.imagesLoaded;
		  if ( !imagesLoaded ) {
		    console.error('[InfiniteScroll] imagesLoaded required for outlayer option');
		    this.isLoading = false;
		    return;
		  }
		  // append once images loaded
		  return new Promise( function( resolve ) {
		    imagesLoaded( fragment, function() {
		      let bodyResponse = appendReady();
		      resolve( bodyResponse );
		    } );
		  } );
		};

		proto.onAppendOutlayer = function( response, path, items ) {
		  this.options.outlayer.appended( items );
		};

		// ----- checkLastPage ----- //

		// check response for next element
		proto.checkLastPage = function( body, path ) {
		  let { checkLastPage, path: pathOpt } = this.options;
		  if ( !checkLastPage ) return;

		  // if path is function, check if next path is truthy
		  if ( typeof pathOpt == 'function' ) {
		    let nextPath = this.getPath();
		    if ( !nextPath ) {
		      this.lastPageReached( body, path );
		      return;
		    }
		  }
		  // get selector from checkLastPage or path option
		  let selector;
		  if ( typeof checkLastPage == 'string' ) {
		    selector = checkLastPage;
		  } else if ( this.isPathSelector ) {
		    // path option is selector string
		    selector = pathOpt;
		  }
		  // check last page for selector
		  // bail if no selector or not document response
		  if ( !selector || !body.querySelector ) return;

		  // check if response has selector
		  let nextElem = body.querySelector( selector );
		  if ( !nextElem ) this.lastPageReached( body, path );
		};

		proto.lastPageReached = function( body, path ) {
		  this.canLoad = false;
		  this.dispatchEvent( 'last', null, [ body, path ] );
		};

		// ----- error ----- //

		proto.onPageError = function( error, path, response ) {
		  this.isLoading = false;
		  this.canLoad = false;
		  this.dispatchEvent( 'error', null, [ error, path, response ] );
		  return error;
		};

		// -------------------------- prefill -------------------------- //

		InfiniteScroll.create.prefill = function() {
		  if ( !this.options.prefill ) return;

		  let append = this.options.append;
		  if ( !append ) {
		    console.error(`append option required for prefill. Set as :${append}`);
		    return;
		  }
		  this.updateMeasurements();
		  this.updateScroller();
		  this.isPrefilling = true;
		  this.on( 'append', this.prefill );
		  this.once( 'error', this.stopPrefill );
		  this.once( 'last', this.stopPrefill );
		  this.prefill();
		};

		proto.prefill = function() {
		  let distance = this.getPrefillDistance();
		  this.isPrefilling = distance >= 0;
		  if ( this.isPrefilling ) {
		    this.log('prefill');
		    this.loadNextPage();
		  } else {
		    this.stopPrefill();
		  }
		};

		proto.getPrefillDistance = function() {
		  // element scroll
		  if ( this.options.elementScroll ) {
		    return this.scroller.clientHeight - this.scroller.scrollHeight;
		  }
		  // window
		  return this.windowHeight - this.element.clientHeight;
		};

		proto.stopPrefill = function() {
		  this.log('stopPrefill');
		  this.off( 'append', this.prefill );
		};

		// --------------------------  -------------------------- //

		return InfiniteScroll;

		} ) ); 
	} (pageLoad));
	return pageLoad.exports;
}

var scrollWatch = {exports: {}};

var hasRequiredScrollWatch;

function requireScrollWatch () {
	if (hasRequiredScrollWatch) return scrollWatch.exports;
	hasRequiredScrollWatch = 1;
	(function (module) {
		// scroll-watch
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireCore(),
		        requireUtils(),
		    );
		  } else {
		    // browser global
		    factory(
		        window,
		        window.InfiniteScroll,
		        window.fizzyUIUtils,
		    );
		  }

		}( window, function factory( window, InfiniteScroll, utils ) {

		let proto = InfiniteScroll.prototype;

		// default options
		Object.assign( InfiniteScroll.defaults, {
		  scrollThreshold: 400,
		  // elementScroll: null,
		} );

		InfiniteScroll.create.scrollWatch = function() {
		  // events
		  this.pageScrollHandler = this.onPageScroll.bind( this );
		  this.resizeHandler = this.onResize.bind( this );

		  let scrollThreshold = this.options.scrollThreshold;
		  let isEnable = scrollThreshold || scrollThreshold === 0;
		  if ( isEnable ) this.enableScrollWatch();
		};

		InfiniteScroll.destroy.scrollWatch = function() {
		  this.disableScrollWatch();
		};

		proto.enableScrollWatch = function() {
		  if ( this.isScrollWatching ) return;

		  this.isScrollWatching = true;
		  this.updateMeasurements();
		  this.updateScroller();
		  // TODO disable after error?
		  this.on( 'last', this.disableScrollWatch );
		  this.bindScrollWatchEvents( true );
		};

		proto.disableScrollWatch = function() {
		  if ( !this.isScrollWatching ) return;

		  this.bindScrollWatchEvents( false );
		  delete this.isScrollWatching;
		};

		proto.bindScrollWatchEvents = function( isBind ) {
		  let addRemove = isBind ? 'addEventListener' : 'removeEventListener';
		  this.scroller[ addRemove ]( 'scroll', this.pageScrollHandler );
		  window[ addRemove ]( 'resize', this.resizeHandler );
		};

		proto.onPageScroll = InfiniteScroll.throttle( function() {
		  let distance = this.getBottomDistance();
		  if ( distance <= this.options.scrollThreshold ) {
		    this.dispatchEvent('scrollThreshold');
		  }
		} );

		proto.getBottomDistance = function() {
		  let bottom, scrollY;
		  if ( this.options.elementScroll ) {
		    bottom = this.scroller.scrollHeight;
		    scrollY = this.scroller.scrollTop + this.scroller.clientHeight;
		  } else {
		    bottom = this.top + this.element.clientHeight;
		    scrollY = window.scrollY + this.windowHeight;
		  }
		  return bottom - scrollY;
		};

		proto.onResize = function() {
		  this.updateMeasurements();
		};

		utils.debounceMethod( InfiniteScroll, 'onResize', 150 );

		// --------------------------  -------------------------- //

		return InfiniteScroll;

		} ) ); 
	} (scrollWatch));
	return scrollWatch.exports;
}

var history$1 = {exports: {}};

var hasRequiredHistory;

function requireHistory () {
	if (hasRequiredHistory) return history$1.exports;
	hasRequiredHistory = 1;
	(function (module) {
		// history
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireCore(),
		        requireUtils(),
		    );
		  } else {
		    // browser global
		    factory(
		        window,
		        window.InfiniteScroll,
		        window.fizzyUIUtils,
		    );
		  }

		}( window, function factory( window, InfiniteScroll, utils ) {

		let proto = InfiniteScroll.prototype;

		Object.assign( InfiniteScroll.defaults, {
		  history: 'replace',
		  // historyTitle: false,
		} );

		let link = document.createElement('a');

		// ----- create/destroy ----- //

		InfiniteScroll.create.history = function() {
		  if ( !this.options.history ) return;

		  // check for same origin
		  link.href = this.getAbsolutePath();
		  // MS Edge does not have origin on link
		  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12236493/
		  let linkOrigin = link.origin || link.protocol + '//' + link.host;
		  let isSameOrigin = linkOrigin == location.origin;
		  if ( !isSameOrigin ) {
		    console.error( '[InfiniteScroll] cannot set history with different origin: ' +
		      `${link.origin} on ${location.origin} . History behavior disabled.` );
		    return;
		  }

		  // two ways to handle changing history
		  if ( this.options.append ) {
		    this.createHistoryAppend();
		  } else {
		    this.createHistoryPageLoad();
		  }
		};

		proto.createHistoryAppend = function() {
		  this.updateMeasurements();
		  this.updateScroller();
		  // array of scroll positions of appended pages
		  this.scrollPages = [
		    // first page
		    {
		      top: 0,
		      path: location.href,
		      title: document.title,
		    },
		  ];
		  this.scrollPage = this.scrollPages[0];
		  // events
		  this.scrollHistoryHandler = this.onScrollHistory.bind( this );
		  this.unloadHandler = this.onUnload.bind( this );
		  this.scroller.addEventListener( 'scroll', this.scrollHistoryHandler );
		  this.on( 'append', this.onAppendHistory );
		  this.bindHistoryAppendEvents( true );
		};

		proto.bindHistoryAppendEvents = function( isBind ) {
		  let addRemove = isBind ? 'addEventListener' : 'removeEventListener';
		  this.scroller[ addRemove ]( 'scroll', this.scrollHistoryHandler );
		  window[ addRemove ]( 'unload', this.unloadHandler );
		};

		proto.createHistoryPageLoad = function() {
		  this.on( 'load', this.onPageLoadHistory );
		};

		InfiniteScroll.destroy.history =
		proto.destroyHistory = function() {
		  let isHistoryAppend = this.options.history && this.options.append;
		  if ( isHistoryAppend ) {
		    this.bindHistoryAppendEvents( false );
		  }
		};

		// ----- append history ----- //

		proto.onAppendHistory = function( response, path, items ) {
		  // do not proceed if no items. #779
		  if ( !items || !items.length ) return;

		  let firstItem = items[0];
		  let elemScrollY = this.getElementScrollY( firstItem );
		  // resolve path
		  link.href = path;
		  // add page data to hash
		  this.scrollPages.push({
		    top: elemScrollY,
		    path: link.href,
		    title: response.title,
		  });
		};

		proto.getElementScrollY = function( elem ) {
		  if ( this.options.elementScroll ) {
		    return elem.offsetTop - this.top;
		  } else {
		    let rect = elem.getBoundingClientRect();
		    return rect.top + window.scrollY;
		  }
		};

		proto.onScrollHistory = function() {
		  // cycle through positions, find biggest without going over
		  let scrollPage = this.getClosestScrollPage();
		  // set history if changed
		  if ( scrollPage != this.scrollPage ) {
		    this.scrollPage = scrollPage;
		    this.setHistory( scrollPage.title, scrollPage.path );
		  }
		};

		utils.debounceMethod( InfiniteScroll, 'onScrollHistory', 150 );

		proto.getClosestScrollPage = function() {
		  let scrollViewY;
		  if ( this.options.elementScroll ) {
		    scrollViewY = this.scroller.scrollTop + this.scroller.clientHeight / 2;
		  } else {
		    scrollViewY = window.scrollY + this.windowHeight / 2;
		  }

		  let scrollPage;
		  for ( let page of this.scrollPages ) {
		    if ( page.top >= scrollViewY ) break;

		    scrollPage = page;
		  }
		  return scrollPage;
		};

		proto.setHistory = function( title, path ) {
		  let optHistory = this.options.history;
		  let historyMethod = optHistory && history[ optHistory + 'State' ];
		  if ( !historyMethod ) return;

		  history[ optHistory + 'State' ]( null, title, path );
		  if ( this.options.historyTitle ) document.title = title;
		  this.dispatchEvent( 'history', null, [ title, path ] );
		};

		// scroll to top to prevent initial scroll-reset after page refresh
		// https://stackoverflow.com/a/18633915/182183
		proto.onUnload = function() {
		  if ( this.scrollPage.top === 0 ) return;

		  // calculate where scroll position would be on refresh
		  let scrollY = window.scrollY - this.scrollPage.top + this.top;
		  // disable scroll event before setting scroll #679
		  this.destroyHistory();
		  scrollTo( 0, scrollY );
		};

		// ----- load history ----- //

		// update URL
		proto.onPageLoadHistory = function( response, path ) {
		  this.setHistory( response.title, path );
		};

		// --------------------------  -------------------------- //

		return InfiniteScroll;

		} ) ); 
	} (history$1));
	return history$1.exports;
}

var button = {exports: {}};

var hasRequiredButton;

function requireButton () {
	if (hasRequiredButton) return button.exports;
	hasRequiredButton = 1;
	(function (module) {
		// button
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireCore(),
		        requireUtils(),
		    );
		  } else {
		    // browser global
		    factory(
		        window,
		        window.InfiniteScroll,
		        window.fizzyUIUtils,
		    );
		  }

		}( window, function factory( window, InfiniteScroll, utils ) {

		// -------------------------- InfiniteScrollButton -------------------------- //

		class InfiniteScrollButton {
		  constructor( element, infScroll ) {
		    this.element = element;
		    this.infScroll = infScroll;
		    // events
		    this.clickHandler = this.onClick.bind( this );
		    this.element.addEventListener( 'click', this.clickHandler );
		    infScroll.on( 'request', this.disable.bind( this ) );
		    infScroll.on( 'load', this.enable.bind( this ) );
		    infScroll.on( 'error', this.hide.bind( this ) );
		    infScroll.on( 'last', this.hide.bind( this ) );
		  }

		  onClick( event ) {
		    event.preventDefault();
		    this.infScroll.loadNextPage();
		  }

		  enable() {
		    this.element.removeAttribute('disabled');
		  }

		  disable() {
		    this.element.disabled = 'disabled';
		  }

		  hide() {
		    this.element.style.display = 'none';
		  }

		  destroy() {
		    this.element.removeEventListener( 'click', this.clickHandler );
		  }

		}

		// -------------------------- InfiniteScroll methods -------------------------- //

		// InfiniteScroll.defaults.button = null;

		InfiniteScroll.create.button = function() {
		  let buttonElem = utils.getQueryElement( this.options.button );
		  if ( buttonElem ) {
		    this.button = new InfiniteScrollButton( buttonElem, this );
		  }
		};

		InfiniteScroll.destroy.button = function() {
		  if ( this.button ) this.button.destroy();
		};

		// --------------------------  -------------------------- //

		InfiniteScroll.Button = InfiniteScrollButton;

		return InfiniteScroll;

		} ) ); 
	} (button));
	return button.exports;
}

var status = {exports: {}};

var hasRequiredStatus;

function requireStatus () {
	if (hasRequiredStatus) return status.exports;
	hasRequiredStatus = 1;
	(function (module) {
		// status
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        window,
		        requireCore(),
		        requireUtils(),
		    );
		  } else {
		    // browser global
		    factory(
		        window,
		        window.InfiniteScroll,
		        window.fizzyUIUtils,
		    );
		  }

		}( window, function factory( window, InfiniteScroll, utils ) {

		let proto = InfiniteScroll.prototype;

		// InfiniteScroll.defaults.status = null;

		InfiniteScroll.create.status = function() {
		  let statusElem = utils.getQueryElement( this.options.status );
		  if ( !statusElem ) return;

		  // elements
		  this.statusElement = statusElem;
		  this.statusEventElements = {
		    request: statusElem.querySelector('.infinite-scroll-request'),
		    error: statusElem.querySelector('.infinite-scroll-error'),
		    last: statusElem.querySelector('.infinite-scroll-last'),
		  };
		  // events
		  this.on( 'request', this.showRequestStatus );
		  this.on( 'error', this.showErrorStatus );
		  this.on( 'last', this.showLastStatus );
		  this.bindHideStatus('on');
		};

		proto.bindHideStatus = function( bindMethod ) {
		  let hideEvent = this.options.append ? 'append' : 'load';
		  this[ bindMethod ]( hideEvent, this.hideAllStatus );
		};

		proto.showRequestStatus = function() {
		  this.showStatus('request');
		};

		proto.showErrorStatus = function() {
		  this.showStatus('error');
		};

		proto.showLastStatus = function() {
		  this.showStatus('last');
		  // prevent last then append event race condition from showing last status #706
		  this.bindHideStatus('off');
		};

		proto.showStatus = function( eventName ) {
		  show( this.statusElement );
		  this.hideStatusEventElements();
		  let eventElem = this.statusEventElements[ eventName ];
		  show( eventElem );
		};

		proto.hideAllStatus = function() {
		  hide( this.statusElement );
		  this.hideStatusEventElements();
		};

		proto.hideStatusEventElements = function() {
		  for ( let type in this.statusEventElements ) {
		    let eventElem = this.statusEventElements[ type ];
		    hide( eventElem );
		  }
		};

		// --------------------------  -------------------------- //

		function hide( elem ) {
		  setDisplay( elem, 'none' );
		}

		function show( elem ) {
		  setDisplay( elem, 'block' );
		}

		function setDisplay( elem, value ) {
		  if ( elem ) {
		    elem.style.display = value;
		  }
		}

		// --------------------------  -------------------------- //

		return InfiniteScroll;

		} ) ); 
	} (status));
	return status.exports;
}

/*!
 * Infinite Scroll v4.0.1
 * Automatically add next page
 *
 * Licensed GPLv3 for open source use
 * or Infinite Scroll Commercial License for commercial use
 *
 * https://infinite-scroll.com
 * Copyright 2018-2020 Metafizzy
 */

var hasRequiredJs;

function requireJs () {
	if (hasRequiredJs) return js.exports;
	hasRequiredJs = 1;
	(function (module) {
		( function( window, factory ) {
		  // universal module definition
		  if ( module.exports ) {
		    // CommonJS
		    module.exports = factory(
		        requireCore(),
		        requirePageLoad(),
		        requireScrollWatch(),
		        requireHistory(),
		        requireButton(),
		        requireStatus(),
		    );
		  }

		} )( window, function factory( InfiniteScroll ) {
		  return InfiniteScroll;
		} ); 
	} (js));
	return js.exports;
}

var jsExports = requireJs();
var t$1 = /*@__PURE__*/getDefaultExportFromCjs(jsExports);

var lang$1 = {exports: {}};

/*!
 *  Lang.js for Laravel localization in JavaScript.
 *
 *  @version 1.1.12
 *  @license MIT https://github.com/rmariuzzo/Lang.js/blob/master/LICENSE
 *  @site    https://github.com/rmariuzzo/Lang.js
 *  @author  Rubens Mariuzzo <rubens@mariuzzo.com>
 */
var lang = lang$1.exports;

var hasRequiredLang;

function requireLang () {
	if (hasRequiredLang) return lang$1.exports;
	hasRequiredLang = 1;
	(function (module, exports) {
		(function(root, factory) {

		    {
		        // NodeJS support.
		        module.exports = factory();
		    }

		}(lang, function() {

		    function inferLocale() {
		        if (typeof document !== 'undefined' && document.documentElement) {
		            return document.documentElement.lang;
		        }
		    }
		    function convertNumber(str) {
		        if (str === '-Inf') {
		            return -Infinity;
		        } else if (str === '+Inf' || str === 'Inf' || str === '*') {
		            return Infinity;
		        }
		        return parseInt(str, 10);
		    }

		    // Derived from: https://github.com/symfony/translation/blob/460390765eb7bb9338a4a323b8a4e815a47541ba/Interval.php
		    var intervalRegexp = /^({\s*(\-?\d+(\.\d+)?[\s*,\s*\-?\d+(\.\d+)?]*)\s*})|([\[\]])\s*(-Inf|\*|\-?\d+(\.\d+)?)\s*,\s*(\+?Inf|\*|\-?\d+(\.\d+)?)\s*([\[\]])$/;
		    var anyIntervalRegexp = /({\s*(\-?\d+(\.\d+)?[\s*,\s*\-?\d+(\.\d+)?]*)\s*})|([\[\]])\s*(-Inf|\*|\-?\d+(\.\d+)?)\s*,\s*(\+?Inf|\*|\-?\d+(\.\d+)?)\s*([\[\]])/;

		    // Default options //

		    var defaults = {
		        locale: 'en'/** The default locale if not set. */
		    };

		    // Constructor //

		    var Lang = function(options) {
		        options = options || {};
		        this.locale = options.locale || inferLocale() || defaults.locale;
		        this.fallback = options.fallback;
		        this.messages = options.messages;
		    };

		    // Methods //

		    /**
		     * Set messages source.
		     *
		     * @param messages {object} The messages source.
		     *
		     * @return void
		     */
		    Lang.prototype.setMessages = function(messages) {
		        this.messages = messages;
		    };

		    /**
		     * Get the current locale.
		     *
		     * @return {string} The current locale.
		     */
		    Lang.prototype.getLocale = function() {
		        return this.locale || this.fallback;
		    };

		    /**
		     * Set the current locale.
		     *
		     * @param locale {string} The locale to set.
		     *
		     * @return void
		     */
		    Lang.prototype.setLocale = function(locale) {
		        this.locale = locale;
		    };

		    /**
		     * Get the fallback locale being used.
		     *
		     * @return void
		     */
		    Lang.prototype.getFallback = function() {
		        return this.fallback;
		    };

		    /**
		     * Set the fallback locale being used.
		     *
		     * @param fallback {string} The fallback locale.
		     *
		     * @return void
		     */
		    Lang.prototype.setFallback = function(fallback) {
		        this.fallback = fallback;
		    };

		    /**
		     * This method act as an alias to get() method.
		     *
		     * @param key {string} The key of the message.
		     * @param locale {string} The locale of the message
		     *
		     * @return {boolean} true if the given key is defined on the messages source, otherwise false.
		     */
		    Lang.prototype.has = function(key, locale) {
		        if (typeof key !== 'string' || !this.messages) {
		            return false;
		        }

		        return this._getMessage(key, locale) !== null;
		    };

		    /**
		     * Get a translation message.
		     *
		     * @param key {string} The key of the message.
		     * @param replacements {object} The replacements to be done in the message.
		     * @param locale {string} The locale to use, if not passed use the default locale.
		     *
		     * @return {string} The translation message, if not found the given key.
		     */
		    Lang.prototype.get = function(key, replacements, locale) {
		        if (!this.has(key, locale)) {
		            return key;
		        }

		        var message = this._getMessage(key, locale);
		        if (message === null) {
		            return key;
		        }

		        if (replacements) {
		            message = this._applyReplacements(message, replacements);
		        }

		        return message;
		    };

		    /**
		     * This method act as an alias to get() method.
		     *
		     * @param key {string} The key of the message.
		     * @param replacements {object} The replacements to be done in the message.
		     *
		     * @return {string} The translation message, if not found the given key.
		     */
		    Lang.prototype.trans = function(key, replacements) {
		        return this.get(key, replacements);
		    };

		    /**
		     * Gets the plural or singular form of the message specified based on an integer value.
		     *
		     * @param key {string} The key of the message.
		     * @param count {number} The number of elements.
		     * @param replacements {object} The replacements to be done in the message.
		     * @param locale {string} The locale to use, if not passed use the default locale.
		     *
		     * @return {string} The translation message according to an integer value.
		     */
		    Lang.prototype.choice = function(key, number, replacements, locale) {
		        // Set default values for parameters replace and locale
		        replacements = typeof replacements !== 'undefined'
		            ? replacements
		            : {};

		        // The count must be replaced if found in the message
		        replacements.count = number;

		        // Message to get the plural or singular
		        var message = this.get(key, replacements, locale);

		        // Check if message is not null or undefined
		        if (message === null || message === undefined) {
		            return message;
		        }

		        // Separate the plural from the singular, if any
		        var messageParts = message.split('|');

		        // Get the explicit rules, If any
		        var explicitRules = [];

		        for (var i = 0; i < messageParts.length; i++) {
		            messageParts[i] = messageParts[i].trim();

		            if (anyIntervalRegexp.test(messageParts[i])) {
		                var messageSpaceSplit = messageParts[i].split(/\s/);
		                explicitRules.push(messageSpaceSplit.shift());
		                messageParts[i] = messageSpaceSplit.join(' ');
		            }
		        }

		        // Check if there's only one message
		        if (messageParts.length === 1) {
		            // Nothing to do here
		            return message;
		        }

		        // Check the explicit rules
		        for (var j = 0; j < explicitRules.length; j++) {
		            if (this._testInterval(number, explicitRules[j])) {
		                return messageParts[j];
		            }
		        }

		        locale = locale || this._getLocale(key);
		        var pluralForm = this._getPluralForm(number, locale);

		        return messageParts[pluralForm];
		    };

		    /**
		     * This method act as an alias to choice() method.
		     *
		     * @param key {string} The key of the message.
		     * @param count {number} The number of elements.
		     * @param replacements {object} The replacements to be done in the message.
		     *
		     * @return {string} The translation message according to an integer value.
		     */
		    Lang.prototype.transChoice = function(key, count, replacements) {
		        return this.choice(key, count, replacements);
		    };

		    /**
		     * Parse a message key into components.
		     *
		     * @param key {string} The message key to parse.
		     * @param key {string} The message locale to parse
		     * @return {object} A key object with source and entries properties.
		     */
		    Lang.prototype._parseKey = function(key, locale) {
		        if (typeof key !== 'string' || typeof locale !== 'string') {
		            return null;
		        }

		        var segments = key.split('.');
		        var source = segments[0].replace(/\//g, '.');

		        return {
		            source: locale + '.' + source,
		            sourceFallback: this.getFallback() + '.' + source,
		            entries: segments.slice(1)
		        };
		    };

		    /**
		     * Returns a translation message. Use `Lang.get()` method instead, this methods assumes the key exists.
		     *
		     * @param key {string} The key of the message.
		     * @param locale {string} The locale of the message
		     *
		     * @return {string} The translation message for the given key.
		     */
		    Lang.prototype._getMessage = function(key, locale) {
		        locale = locale || this.getLocale();
		        
		        key = this._parseKey(key, locale);

		        // Ensure message source exists.
		        if (this.messages[key.source] === undefined && this.messages[key.sourceFallback] === undefined) {
		            return null;
		        }

		        // Get message from default locale.
		        var message = this.messages[key.source];
		        var entries = key.entries.slice();
		        var subKey = entries.join('.');
		        message = message !== undefined ? this._getValueInKey(message, subKey) : undefined;


		        // Get message from fallback locale.
		        if (typeof message !== 'string' && this.messages[key.sourceFallback]) {
		            message = this.messages[key.sourceFallback];
		            entries = key.entries.slice();
		            subKey = '';
		            while (entries.length && message !== undefined) {
		                var subKey = !subKey ? entries.shift() : subKey.concat('.', entries.shift());
		                if (message[subKey]) {
		                    message = message[subKey];
		                    subKey = '';
		                }
		            }
		        }

		        if (typeof message !== 'string') {
		            return null;
		        }

		        return message;
		    };

		    Lang.prototype._getValueInKey = function(obj, str) {
		        // If the full key exists just return the value
		        if (typeof obj[str] === 'string') {
		            return obj[str]
		        }

		        str = str.replace(/\[(\w+)\]/g, '.$1'); // convert indexes to properties
		        str = str.replace(/^\./, '');           // strip a leading dot

		        var parts = str.split('.');

		        for (var i = 0, n = parts.length; i < n; ++i) {
		            var currentKey = parts.slice(0, i + 1).join('.');
		            var restOfTheKey = parts.slice(i + 1, parts.length).join('.');
		            
		            if (obj[currentKey]) {
		                return this._getValueInKey(obj[currentKey], restOfTheKey)
		            }
		        }

		        return obj;
		    };

		    /**
		     * Return the locale to be used between default and fallback.
		     * @param {String} key
		     * @return {String}
		     */
		    Lang.prototype._getLocale = function(key) {
		        key = this._parseKey(key, this.locale);
		        if (this.messages[key.source]) {
		            return this.locale;
		        }
		        if (this.messages[key.sourceFallback]) {
		            return this.fallback;
		        }
		        return null;
		    };

		    /**
		     * Find a message in a translation tree using both dotted keys and regular ones
		     *
		     * @param pathSegments {array} An array of path segments such as ['family', 'father']
		     * @param tree {object} The translation tree
		     */
		    Lang.prototype._findMessageInTree = function(pathSegments, tree) {
		        while (pathSegments.length && tree !== undefined) {
		            var dottedKey = pathSegments.join('.');
		            if (tree[dottedKey]) {
		                tree = tree[dottedKey];
		                break;
		            }

		            tree = tree[pathSegments.shift()];
		        }

		        return tree;
		    };

		    /**
		     * Sort replacement keys by length in descending order.
		     *
		     * @param a {string} Replacement key
		     * @param b {string} Sibling replacement key
		     * @return {number}
		     * @private
		     */
		    Lang.prototype._sortReplacementKeys = function(a, b) {
		        return b.length - a.length;
		    };

		    /**
		     * Apply replacements to a string message containing placeholders.
		     *
		     * @param message {string} The text message.
		     * @param replacements {object} The replacements to be done in the message.
		     *
		     * @return {string} The string message with replacements applied.
		     */
		    Lang.prototype._applyReplacements = function(message, replacements) {
		        var keys = Object.keys(replacements).sort(this._sortReplacementKeys);

		        keys.forEach(function(replace) {
		            message = message.replace(new RegExp(':' + replace, 'gi'), function (match) {
		                var value = replacements[replace];

		                // Capitalize all characters.
		                var allCaps = match === match.toUpperCase();
		                if (allCaps) {
		                    return value.toUpperCase();
		                }

		                // Capitalize first letter.
		                var firstCap = match === match.replace(/\w/i, function(letter) {
		                    return letter.toUpperCase();
		                });
		                if (firstCap) {
		                    return value.charAt(0).toUpperCase() + value.slice(1);
		                }

		                return value;
		            });
		        });
		        return message;
		    };

		    /**
		     * Checks if the given `count` is within the interval defined by the {string} `interval`
		     *
		     * @param  count     {int}    The amount of items.
		     * @param  interval  {string} The interval to be compared with the count.
		     * @return {boolean}          Returns true if count is within interval; false otherwise.
		     */
		    Lang.prototype._testInterval = function(count, interval) {
		        /**
		         * From the Symfony\Component\Translation\Interval Docs
		         *
		         * Tests if a given number belongs to a given math interval.
		         *
		         * An interval can represent a finite set of numbers:
		         *
		         *  {1,2,3,4}
		         *
		         * An interval can represent numbers between two numbers:
		         *
		         *  [1, +Inf]
		         *  ]-1,2[
		         *
		         * The left delimiter can be [ (inclusive) or ] (exclusive).
		         * The right delimiter can be [ (exclusive) or ] (inclusive).
		         * Beside numbers, you can use -Inf and +Inf for the infinite.
		         */

		        if (typeof interval !== 'string') {
		            throw 'Invalid interval: should be a string.';
		        }

		        interval = interval.trim();

		        var matches = interval.match(intervalRegexp);
		        if (!matches) {
		            throw 'Invalid interval: ' + interval;
		        }

		        if (matches[2]) {
		            var items = matches[2].split(',');
		            for (var i = 0; i < items.length; i++) {
		                if (parseInt(items[i], 10) === count) {
		                    return true;
		                }
		            }
		        } else {
		            // Remove falsy values.
		            matches = matches.filter(function(match) {
		                return !!match;
		            });

		            var leftDelimiter = matches[1];
		            var leftNumber = convertNumber(matches[2]);
		            if (leftNumber === Infinity) {
		                leftNumber = -Infinity;
		            }
		            var rightNumber = convertNumber(matches[3]);
		            var rightDelimiter = matches[4];

		            return (leftDelimiter === '[' ? count >= leftNumber : count > leftNumber)
		                && (rightDelimiter === ']' ? count <= rightNumber : count < rightNumber);
		        }

		        return false;
		    };

		    /**
		     * Returns the plural position to use for the given locale and number.
		     *
		     * The plural rules are derived from code of the Zend Framework (2010-09-25),
		     * which is subject to the new BSD license (http://framework.zend.com/license/new-bsd).
		     * Copyright (c) 2005-2010 Zend Technologies USA Inc. (http://www.zend.com)
		     *
		     * @param {Number} count
		     * @param {String} locale
		     * @return {Number}
		     */
		    Lang.prototype._getPluralForm = function(count, locale) {
		        switch (locale) {
		            case 'az':
		            case 'bo':
		            case 'dz':
		            case 'id':
		            case 'ja':
		            case 'jv':
		            case 'ka':
		            case 'km':
		            case 'kn':
		            case 'ko':
		            case 'ms':
		            case 'th':
		            case 'tr':
		            case 'vi':
		            case 'zh':
		                return 0;

		            case 'af':
		            case 'bn':
		            case 'bg':
		            case 'ca':
		            case 'da':
		            case 'de':
		            case 'el':
		            case 'en':
		            case 'eo':
		            case 'es':
		            case 'et':
		            case 'eu':
		            case 'fa':
		            case 'fi':
		            case 'fo':
		            case 'fur':
		            case 'fy':
		            case 'gl':
		            case 'gu':
		            case 'ha':
		            case 'he':
		            case 'hu':
		            case 'is':
		            case 'it':
		            case 'ku':
		            case 'lb':
		            case 'ml':
		            case 'mn':
		            case 'mr':
		            case 'nah':
		            case 'nb':
		            case 'ne':
		            case 'nl':
		            case 'nn':
		            case 'no':
		            case 'om':
		            case 'or':
		            case 'pa':
		            case 'pap':
		            case 'ps':
		            case 'pt':
		            case 'so':
		            case 'sq':
		            case 'sv':
		            case 'sw':
		            case 'ta':
		            case 'te':
		            case 'tk':
		            case 'ur':
		            case 'zu':
		                return (count == 1)
		                    ? 0
		                    : 1;

		            case 'am':
		            case 'bh':
		            case 'fil':
		            case 'fr':
		            case 'gun':
		            case 'hi':
		            case 'hy':
		            case 'ln':
		            case 'mg':
		            case 'nso':
		            case 'xbr':
		            case 'ti':
		            case 'wa':
		                return ((count === 0) || (count === 1))
		                    ? 0
		                    : 1;

		            case 'be':
		            case 'bs':
		            case 'hr':
		            case 'ru':
		            case 'sr':
		            case 'uk':
		                return ((count % 10 == 1) && (count % 100 != 11))
		                    ? 0
		                    : (((count % 10 >= 2) && (count % 10 <= 4) && ((count % 100 < 10) || (count % 100 >= 20)))
		                        ? 1
		                        : 2);

		            case 'cs':
		            case 'sk':
		                return (count == 1)
		                    ? 0
		                    : (((count >= 2) && (count <= 4))
		                        ? 1
		                        : 2);

		            case 'ga':
		                return (count == 1)
		                    ? 0
		                    : ((count == 2)
		                        ? 1
		                        : 2);

		            case 'lt':
		                return ((count % 10 == 1) && (count % 100 != 11))
		                    ? 0
		                    : (((count % 10 >= 2) && ((count % 100 < 10) || (count % 100 >= 20)))
		                        ? 1
		                        : 2);

		            case 'sl':
		                return (count % 100 == 1)
		                    ? 0
		                    : ((count % 100 == 2)
		                        ? 1
		                        : (((count % 100 == 3) || (count % 100 == 4))
		                            ? 2
		                            : 3));

		            case 'mk':
		                return (count % 10 == 1)
		                    ? 0
		                    : 1;

		            case 'mt':
		                return (count == 1)
		                    ? 0
		                    : (((count === 0) || ((count % 100 > 1) && (count % 100 < 11)))
		                        ? 1
		                        : (((count % 100 > 10) && (count % 100 < 20))
		                            ? 2
		                            : 3));

		            case 'lv':
		                return (count === 0)
		                    ? 0
		                    : (((count % 10 == 1) && (count % 100 != 11))
		                        ? 1
		                        : 2);

		            case 'pl':
		                return (count == 1)
		                    ? 0
		                    : (((count % 10 >= 2) && (count % 10 <= 4) && ((count % 100 < 12) || (count % 100 > 14)))
		                        ? 1
		                        : 2);

		            case 'cy':
		                return (count == 1)
		                    ? 0
		                    : ((count == 2)
		                        ? 1
		                        : (((count == 8) || (count == 11))
		                            ? 2
		                            : 3));

		            case 'ro':
		                return (count == 1)
		                    ? 0
		                    : (((count === 0) || ((count % 100 > 0) && (count % 100 < 20)))
		                        ? 1
		                        : 2);

		            case 'ar':
		                return (count === 0)
		                    ? 0
		                    : ((count == 1)
		                        ? 1
		                        : ((count == 2)
		                            ? 2
		                            : (((count % 100 >= 3) && (count % 100 <= 10))
		                                ? 3
		                                : (((count % 100 >= 11) && (count % 100 <= 99))
		                                    ? 4
		                                    : 5))));

		            default:
		                return 0;
		        }
		    };

		    return Lang;

		})); 
	} (lang$1));
	return lang$1.exports;
}

var langExports = requireLang();
var a$3 = /*@__PURE__*/getDefaultExportFromCjs(langExports);

/*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors */

var axios_1;
var hasRequiredAxios;

function requireAxios () {
	if (hasRequiredAxios) return axios_1;
	hasRequiredAxios = 1;

	function bind(fn, thisArg) {
	  return function wrap() {
	    return fn.apply(thisArg, arguments);
	  };
	}

	// utils is a library of generic helper functions non-specific to axios

	const {toString} = Object.prototype;
	const {getPrototypeOf} = Object;
	const {iterator, toStringTag} = Symbol;

	const kindOf = (cache => thing => {
	    const str = toString.call(thing);
	    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
	})(Object.create(null));

	const kindOfTest = (type) => {
	  type = type.toLowerCase();
	  return (thing) => kindOf(thing) === type
	};

	const typeOfTest = type => thing => typeof thing === type;

	/**
	 * Determine if a value is an Array
	 *
	 * @param {Object} val The value to test
	 *
	 * @returns {boolean} True if value is an Array, otherwise false
	 */
	const {isArray} = Array;

	/**
	 * Determine if a value is undefined
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if the value is undefined, otherwise false
	 */
	const isUndefined = typeOfTest('undefined');

	/**
	 * Determine if a value is a Buffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Buffer, otherwise false
	 */
	function isBuffer(val) {
	  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
	    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
	}

	/**
	 * Determine if a value is an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
	 */
	const isArrayBuffer = kindOfTest('ArrayBuffer');


	/**
	 * Determine if a value is a view on an ArrayBuffer
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
	 */
	function isArrayBufferView(val) {
	  let result;
	  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
	    result = ArrayBuffer.isView(val);
	  } else {
	    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
	  }
	  return result;
	}

	/**
	 * Determine if a value is a String
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a String, otherwise false
	 */
	const isString = typeOfTest('string');

	/**
	 * Determine if a value is a Function
	 *
	 * @param {*} val The value to test
	 * @returns {boolean} True if value is a Function, otherwise false
	 */
	const isFunction = typeOfTest('function');

	/**
	 * Determine if a value is a Number
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Number, otherwise false
	 */
	const isNumber = typeOfTest('number');

	/**
	 * Determine if a value is an Object
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an Object, otherwise false
	 */
	const isObject = (thing) => thing !== null && typeof thing === 'object';

	/**
	 * Determine if a value is a Boolean
	 *
	 * @param {*} thing The value to test
	 * @returns {boolean} True if value is a Boolean, otherwise false
	 */
	const isBoolean = thing => thing === true || thing === false;

	/**
	 * Determine if a value is a plain Object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a plain Object, otherwise false
	 */
	const isPlainObject = (val) => {
	  if (kindOf(val) !== 'object') {
	    return false;
	  }

	  const prototype = getPrototypeOf(val);
	  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
	};

	/**
	 * Determine if a value is a Date
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Date, otherwise false
	 */
	const isDate = kindOfTest('Date');

	/**
	 * Determine if a value is a File
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFile = kindOfTest('File');

	/**
	 * Determine if a value is a Blob
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Blob, otherwise false
	 */
	const isBlob = kindOfTest('Blob');

	/**
	 * Determine if a value is a FileList
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a File, otherwise false
	 */
	const isFileList = kindOfTest('FileList');

	/**
	 * Determine if a value is a Stream
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a Stream, otherwise false
	 */
	const isStream = (val) => isObject(val) && isFunction(val.pipe);

	/**
	 * Determine if a value is a FormData
	 *
	 * @param {*} thing The value to test
	 *
	 * @returns {boolean} True if value is an FormData, otherwise false
	 */
	const isFormData = (thing) => {
	  let kind;
	  return thing && (
	    (typeof FormData === 'function' && thing instanceof FormData) || (
	      isFunction(thing.append) && (
	        (kind = kindOf(thing)) === 'formdata' ||
	        // detect form-data instance
	        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
	      )
	    )
	  )
	};

	/**
	 * Determine if a value is a URLSearchParams object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
	 */
	const isURLSearchParams = kindOfTest('URLSearchParams');

	const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

	/**
	 * Trim excess whitespace off the beginning and end of a string
	 *
	 * @param {String} str The String to trim
	 *
	 * @returns {String} The String freed of excess whitespace
	 */
	const trim = (str) => str.trim ?
	  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

	/**
	 * Iterate over an Array or an Object invoking a function for each item.
	 *
	 * If `obj` is an Array callback will be called passing
	 * the value, index, and complete array for each item.
	 *
	 * If 'obj' is an Object callback will be called passing
	 * the value, key, and complete object for each property.
	 *
	 * @param {Object|Array} obj The object to iterate
	 * @param {Function} fn The callback to invoke for each item
	 *
	 * @param {Boolean} [allOwnKeys = false]
	 * @returns {any}
	 */
	function forEach(obj, fn, {allOwnKeys = false} = {}) {
	  // Don't bother if no value provided
	  if (obj === null || typeof obj === 'undefined') {
	    return;
	  }

	  let i;
	  let l;

	  // Force an array if not already something iterable
	  if (typeof obj !== 'object') {
	    /*eslint no-param-reassign:0*/
	    obj = [obj];
	  }

	  if (isArray(obj)) {
	    // Iterate over array values
	    for (i = 0, l = obj.length; i < l; i++) {
	      fn.call(null, obj[i], i, obj);
	    }
	  } else {
	    // Iterate over object keys
	    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
	    const len = keys.length;
	    let key;

	    for (i = 0; i < len; i++) {
	      key = keys[i];
	      fn.call(null, obj[key], key, obj);
	    }
	  }
	}

	function findKey(obj, key) {
	  key = key.toLowerCase();
	  const keys = Object.keys(obj);
	  let i = keys.length;
	  let _key;
	  while (i-- > 0) {
	    _key = keys[i];
	    if (key === _key.toLowerCase()) {
	      return _key;
	    }
	  }
	  return null;
	}

	const _global = (() => {
	  /*eslint no-undef:0*/
	  if (typeof globalThis !== "undefined") return globalThis;
	  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : commonjsGlobal)
	})();

	const isContextDefined = (context) => !isUndefined(context) && context !== _global;

	/**
	 * Accepts varargs expecting each argument to be an object, then
	 * immutably merges the properties of each object and returns result.
	 *
	 * When multiple objects contain the same key the later object in
	 * the arguments list will take precedence.
	 *
	 * Example:
	 *
	 * ```js
	 * var result = merge({foo: 123}, {foo: 456});
	 * console.log(result.foo); // outputs 456
	 * ```
	 *
	 * @param {Object} obj1 Object to merge
	 *
	 * @returns {Object} Result of all merge properties
	 */
	function merge(/* obj1, obj2, obj3, ... */) {
	  const {caseless} = isContextDefined(this) && this || {};
	  const result = {};
	  const assignValue = (val, key) => {
	    const targetKey = caseless && findKey(result, key) || key;
	    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
	      result[targetKey] = merge(result[targetKey], val);
	    } else if (isPlainObject(val)) {
	      result[targetKey] = merge({}, val);
	    } else if (isArray(val)) {
	      result[targetKey] = val.slice();
	    } else {
	      result[targetKey] = val;
	    }
	  };

	  for (let i = 0, l = arguments.length; i < l; i++) {
	    arguments[i] && forEach(arguments[i], assignValue);
	  }
	  return result;
	}

	/**
	 * Extends object a by mutably adding to it the properties of object b.
	 *
	 * @param {Object} a The object to be extended
	 * @param {Object} b The object to copy properties from
	 * @param {Object} thisArg The object to bind function to
	 *
	 * @param {Boolean} [allOwnKeys]
	 * @returns {Object} The resulting value of object a
	 */
	const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
	  forEach(b, (val, key) => {
	    if (thisArg && isFunction(val)) {
	      a[key] = bind(val, thisArg);
	    } else {
	      a[key] = val;
	    }
	  }, {allOwnKeys});
	  return a;
	};

	/**
	 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
	 *
	 * @param {string} content with BOM
	 *
	 * @returns {string} content value without BOM
	 */
	const stripBOM = (content) => {
	  if (content.charCodeAt(0) === 0xFEFF) {
	    content = content.slice(1);
	  }
	  return content;
	};

	/**
	 * Inherit the prototype methods from one constructor into another
	 * @param {function} constructor
	 * @param {function} superConstructor
	 * @param {object} [props]
	 * @param {object} [descriptors]
	 *
	 * @returns {void}
	 */
	const inherits = (constructor, superConstructor, props, descriptors) => {
	  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
	  constructor.prototype.constructor = constructor;
	  Object.defineProperty(constructor, 'super', {
	    value: superConstructor.prototype
	  });
	  props && Object.assign(constructor.prototype, props);
	};

	/**
	 * Resolve object with deep prototype chain to a flat object
	 * @param {Object} sourceObj source object
	 * @param {Object} [destObj]
	 * @param {Function|Boolean} [filter]
	 * @param {Function} [propFilter]
	 *
	 * @returns {Object}
	 */
	const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
	  let props;
	  let i;
	  let prop;
	  const merged = {};

	  destObj = destObj || {};
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  if (sourceObj == null) return destObj;

	  do {
	    props = Object.getOwnPropertyNames(sourceObj);
	    i = props.length;
	    while (i-- > 0) {
	      prop = props[i];
	      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
	        destObj[prop] = sourceObj[prop];
	        merged[prop] = true;
	      }
	    }
	    sourceObj = filter !== false && getPrototypeOf(sourceObj);
	  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

	  return destObj;
	};

	/**
	 * Determines whether a string ends with the characters of a specified string
	 *
	 * @param {String} str
	 * @param {String} searchString
	 * @param {Number} [position= 0]
	 *
	 * @returns {boolean}
	 */
	const endsWith = (str, searchString, position) => {
	  str = String(str);
	  if (position === undefined || position > str.length) {
	    position = str.length;
	  }
	  position -= searchString.length;
	  const lastIndex = str.indexOf(searchString, position);
	  return lastIndex !== -1 && lastIndex === position;
	};


	/**
	 * Returns new array from array like object or null if failed
	 *
	 * @param {*} [thing]
	 *
	 * @returns {?Array}
	 */
	const toArray = (thing) => {
	  if (!thing) return null;
	  if (isArray(thing)) return thing;
	  let i = thing.length;
	  if (!isNumber(i)) return null;
	  const arr = new Array(i);
	  while (i-- > 0) {
	    arr[i] = thing[i];
	  }
	  return arr;
	};

	/**
	 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
	 * thing passed in is an instance of Uint8Array
	 *
	 * @param {TypedArray}
	 *
	 * @returns {Array}
	 */
	// eslint-disable-next-line func-names
	const isTypedArray = (TypedArray => {
	  // eslint-disable-next-line func-names
	  return thing => {
	    return TypedArray && thing instanceof TypedArray;
	  };
	})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

	/**
	 * For each entry in the object, call the function with the key and value.
	 *
	 * @param {Object<any, any>} obj - The object to iterate over.
	 * @param {Function} fn - The function to call for each entry.
	 *
	 * @returns {void}
	 */
	const forEachEntry = (obj, fn) => {
	  const generator = obj && obj[iterator];

	  const _iterator = generator.call(obj);

	  let result;

	  while ((result = _iterator.next()) && !result.done) {
	    const pair = result.value;
	    fn.call(obj, pair[0], pair[1]);
	  }
	};

	/**
	 * It takes a regular expression and a string, and returns an array of all the matches
	 *
	 * @param {string} regExp - The regular expression to match against.
	 * @param {string} str - The string to search.
	 *
	 * @returns {Array<boolean>}
	 */
	const matchAll = (regExp, str) => {
	  let matches;
	  const arr = [];

	  while ((matches = regExp.exec(str)) !== null) {
	    arr.push(matches);
	  }

	  return arr;
	};

	/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
	const isHTMLForm = kindOfTest('HTMLFormElement');

	const toCamelCase = str => {
	  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
	    function replacer(m, p1, p2) {
	      return p1.toUpperCase() + p2;
	    }
	  );
	};

	/* Creating a function that will check if an object has a property. */
	const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

	/**
	 * Determine if a value is a RegExp object
	 *
	 * @param {*} val The value to test
	 *
	 * @returns {boolean} True if value is a RegExp object, otherwise false
	 */
	const isRegExp = kindOfTest('RegExp');

	const reduceDescriptors = (obj, reducer) => {
	  const descriptors = Object.getOwnPropertyDescriptors(obj);
	  const reducedDescriptors = {};

	  forEach(descriptors, (descriptor, name) => {
	    let ret;
	    if ((ret = reducer(descriptor, name, obj)) !== false) {
	      reducedDescriptors[name] = ret || descriptor;
	    }
	  });

	  Object.defineProperties(obj, reducedDescriptors);
	};

	/**
	 * Makes all methods read-only
	 * @param {Object} obj
	 */

	const freezeMethods = (obj) => {
	  reduceDescriptors(obj, (descriptor, name) => {
	    // skip restricted props in strict mode
	    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
	      return false;
	    }

	    const value = obj[name];

	    if (!isFunction(value)) return;

	    descriptor.enumerable = false;

	    if ('writable' in descriptor) {
	      descriptor.writable = false;
	      return;
	    }

	    if (!descriptor.set) {
	      descriptor.set = () => {
	        throw Error('Can not rewrite read-only method \'' + name + '\'');
	      };
	    }
	  });
	};

	const toObjectSet = (arrayOrString, delimiter) => {
	  const obj = {};

	  const define = (arr) => {
	    arr.forEach(value => {
	      obj[value] = true;
	    });
	  };

	  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

	  return obj;
	};

	const noop = () => {};

	const toFiniteNumber = (value, defaultValue) => {
	  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
	};

	/**
	 * If the thing is a FormData object, return true, otherwise return false.
	 *
	 * @param {unknown} thing - The thing to check.
	 *
	 * @returns {boolean}
	 */
	function isSpecCompliantForm(thing) {
	  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
	}

	const toJSONObject = (obj) => {
	  const stack = new Array(10);

	  const visit = (source, i) => {

	    if (isObject(source)) {
	      if (stack.indexOf(source) >= 0) {
	        return;
	      }

	      if(!('toJSON' in source)) {
	        stack[i] = source;
	        const target = isArray(source) ? [] : {};

	        forEach(source, (value, key) => {
	          const reducedValue = visit(value, i + 1);
	          !isUndefined(reducedValue) && (target[key] = reducedValue);
	        });

	        stack[i] = undefined;

	        return target;
	      }
	    }

	    return source;
	  };

	  return visit(obj, 0);
	};

	const isAsyncFn = kindOfTest('AsyncFunction');

	const isThenable = (thing) =>
	  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

	// original code
	// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

	const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
	  if (setImmediateSupported) {
	    return setImmediate;
	  }

	  return postMessageSupported ? ((token, callbacks) => {
	    _global.addEventListener("message", ({source, data}) => {
	      if (source === _global && data === token) {
	        callbacks.length && callbacks.shift()();
	      }
	    }, false);

	    return (cb) => {
	      callbacks.push(cb);
	      _global.postMessage(token, "*");
	    }
	  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
	})(
	  typeof setImmediate === 'function',
	  isFunction(_global.postMessage)
	);

	const asap = typeof queueMicrotask !== 'undefined' ?
	  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

	// *********************


	const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


	var utils$1 = {
	  isArray,
	  isArrayBuffer,
	  isBuffer,
	  isFormData,
	  isArrayBufferView,
	  isString,
	  isNumber,
	  isBoolean,
	  isObject,
	  isPlainObject,
	  isReadableStream,
	  isRequest,
	  isResponse,
	  isHeaders,
	  isUndefined,
	  isDate,
	  isFile,
	  isBlob,
	  isRegExp,
	  isFunction,
	  isStream,
	  isURLSearchParams,
	  isTypedArray,
	  isFileList,
	  forEach,
	  merge,
	  extend,
	  trim,
	  stripBOM,
	  inherits,
	  toFlatObject,
	  kindOf,
	  kindOfTest,
	  endsWith,
	  toArray,
	  forEachEntry,
	  matchAll,
	  isHTMLForm,
	  hasOwnProperty,
	  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
	  reduceDescriptors,
	  freezeMethods,
	  toObjectSet,
	  toCamelCase,
	  noop,
	  toFiniteNumber,
	  findKey,
	  global: _global,
	  isContextDefined,
	  isSpecCompliantForm,
	  toJSONObject,
	  isAsyncFn,
	  isThenable,
	  setImmediate: _setImmediate,
	  asap,
	  isIterable
	};

	/**
	 * Create an Error with the specified message, config, error code, request and response.
	 *
	 * @param {string} message The error message.
	 * @param {string} [code] The error code (for example, 'ECONNABORTED').
	 * @param {Object} [config] The config.
	 * @param {Object} [request] The request.
	 * @param {Object} [response] The response.
	 *
	 * @returns {Error} The created error.
	 */
	function AxiosError(message, code, config, request, response) {
	  Error.call(this);

	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    this.stack = (new Error()).stack;
	  }

	  this.message = message;
	  this.name = 'AxiosError';
	  code && (this.code = code);
	  config && (this.config = config);
	  request && (this.request = request);
	  if (response) {
	    this.response = response;
	    this.status = response.status ? response.status : null;
	  }
	}

	utils$1.inherits(AxiosError, Error, {
	  toJSON: function toJSON() {
	    return {
	      // Standard
	      message: this.message,
	      name: this.name,
	      // Microsoft
	      description: this.description,
	      number: this.number,
	      // Mozilla
	      fileName: this.fileName,
	      lineNumber: this.lineNumber,
	      columnNumber: this.columnNumber,
	      stack: this.stack,
	      // Axios
	      config: utils$1.toJSONObject(this.config),
	      code: this.code,
	      status: this.status
	    };
	  }
	});

	const prototype$1 = AxiosError.prototype;
	const descriptors = {};

	[
	  'ERR_BAD_OPTION_VALUE',
	  'ERR_BAD_OPTION',
	  'ECONNABORTED',
	  'ETIMEDOUT',
	  'ERR_NETWORK',
	  'ERR_FR_TOO_MANY_REDIRECTS',
	  'ERR_DEPRECATED',
	  'ERR_BAD_RESPONSE',
	  'ERR_BAD_REQUEST',
	  'ERR_CANCELED',
	  'ERR_NOT_SUPPORT',
	  'ERR_INVALID_URL'
	// eslint-disable-next-line func-names
	].forEach(code => {
	  descriptors[code] = {value: code};
	});

	Object.defineProperties(AxiosError, descriptors);
	Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

	// eslint-disable-next-line func-names
	AxiosError.from = (error, code, config, request, response, customProps) => {
	  const axiosError = Object.create(prototype$1);

	  utils$1.toFlatObject(error, axiosError, function filter(obj) {
	    return obj !== Error.prototype;
	  }, prop => {
	    return prop !== 'isAxiosError';
	  });

	  AxiosError.call(axiosError, error.message, code, config, request, response);

	  axiosError.cause = error;

	  axiosError.name = error.name;

	  customProps && Object.assign(axiosError, customProps);

	  return axiosError;
	};

	// eslint-disable-next-line strict
	var httpAdapter = null;

	/**
	 * Determines if the given thing is a array or js object.
	 *
	 * @param {string} thing - The object or array to be visited.
	 *
	 * @returns {boolean}
	 */
	function isVisitable(thing) {
	  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
	}

	/**
	 * It removes the brackets from the end of a string
	 *
	 * @param {string} key - The key of the parameter.
	 *
	 * @returns {string} the key without the brackets.
	 */
	function removeBrackets(key) {
	  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
	}

	/**
	 * It takes a path, a key, and a boolean, and returns a string
	 *
	 * @param {string} path - The path to the current key.
	 * @param {string} key - The key of the current object being iterated over.
	 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
	 *
	 * @returns {string} The path to the current key.
	 */
	function renderKey(path, key, dots) {
	  if (!path) return key;
	  return path.concat(key).map(function each(token, i) {
	    // eslint-disable-next-line no-param-reassign
	    token = removeBrackets(token);
	    return !dots && i ? '[' + token + ']' : token;
	  }).join(dots ? '.' : '');
	}

	/**
	 * If the array is an array and none of its elements are visitable, then it's a flat array.
	 *
	 * @param {Array<any>} arr - The array to check
	 *
	 * @returns {boolean}
	 */
	function isFlatArray(arr) {
	  return utils$1.isArray(arr) && !arr.some(isVisitable);
	}

	const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
	  return /^is[A-Z]/.test(prop);
	});

	/**
	 * Convert a data object to FormData
	 *
	 * @param {Object} obj
	 * @param {?Object} [formData]
	 * @param {?Object} [options]
	 * @param {Function} [options.visitor]
	 * @param {Boolean} [options.metaTokens = true]
	 * @param {Boolean} [options.dots = false]
	 * @param {?Boolean} [options.indexes = false]
	 *
	 * @returns {Object}
	 **/

	/**
	 * It converts an object into a FormData object
	 *
	 * @param {Object<any, any>} obj - The object to convert to form data.
	 * @param {string} formData - The FormData object to append to.
	 * @param {Object<string, any>} options
	 *
	 * @returns
	 */
	function toFormData(obj, formData, options) {
	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('target must be an object');
	  }

	  // eslint-disable-next-line no-param-reassign
	  formData = formData || new (FormData)();

	  // eslint-disable-next-line no-param-reassign
	  options = utils$1.toFlatObject(options, {
	    metaTokens: true,
	    dots: false,
	    indexes: false
	  }, false, function defined(option, source) {
	    // eslint-disable-next-line no-eq-null,eqeqeq
	    return !utils$1.isUndefined(source[option]);
	  });

	  const metaTokens = options.metaTokens;
	  // eslint-disable-next-line no-use-before-define
	  const visitor = options.visitor || defaultVisitor;
	  const dots = options.dots;
	  const indexes = options.indexes;
	  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
	  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

	  if (!utils$1.isFunction(visitor)) {
	    throw new TypeError('visitor must be a function');
	  }

	  function convertValue(value) {
	    if (value === null) return '';

	    if (utils$1.isDate(value)) {
	      return value.toISOString();
	    }

	    if (utils$1.isBoolean(value)) {
	      return value.toString();
	    }

	    if (!useBlob && utils$1.isBlob(value)) {
	      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
	    }

	    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
	      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
	    }

	    return value;
	  }

	  /**
	   * Default visitor.
	   *
	   * @param {*} value
	   * @param {String|Number} key
	   * @param {Array<String|Number>} path
	   * @this {FormData}
	   *
	   * @returns {boolean} return true to visit the each prop of the value recursively
	   */
	  function defaultVisitor(value, key, path) {
	    let arr = value;

	    if (value && !path && typeof value === 'object') {
	      if (utils$1.endsWith(key, '{}')) {
	        // eslint-disable-next-line no-param-reassign
	        key = metaTokens ? key : key.slice(0, -2);
	        // eslint-disable-next-line no-param-reassign
	        value = JSON.stringify(value);
	      } else if (
	        (utils$1.isArray(value) && isFlatArray(value)) ||
	        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
	        )) {
	        // eslint-disable-next-line no-param-reassign
	        key = removeBrackets(key);

	        arr.forEach(function each(el, index) {
	          !(utils$1.isUndefined(el) || el === null) && formData.append(
	            // eslint-disable-next-line no-nested-ternary
	            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
	            convertValue(el)
	          );
	        });
	        return false;
	      }
	    }

	    if (isVisitable(value)) {
	      return true;
	    }

	    formData.append(renderKey(path, key, dots), convertValue(value));

	    return false;
	  }

	  const stack = [];

	  const exposedHelpers = Object.assign(predicates, {
	    defaultVisitor,
	    convertValue,
	    isVisitable
	  });

	  function build(value, path) {
	    if (utils$1.isUndefined(value)) return;

	    if (stack.indexOf(value) !== -1) {
	      throw Error('Circular reference detected in ' + path.join('.'));
	    }

	    stack.push(value);

	    utils$1.forEach(value, function each(el, key) {
	      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
	        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
	      );

	      if (result === true) {
	        build(el, path ? path.concat(key) : [key]);
	      }
	    });

	    stack.pop();
	  }

	  if (!utils$1.isObject(obj)) {
	    throw new TypeError('data must be an object');
	  }

	  build(obj);

	  return formData;
	}

	/**
	 * It encodes a string by replacing all characters that are not in the unreserved set with
	 * their percent-encoded equivalents
	 *
	 * @param {string} str - The string to encode.
	 *
	 * @returns {string} The encoded string.
	 */
	function encode$1(str) {
	  const charMap = {
	    '!': '%21',
	    "'": '%27',
	    '(': '%28',
	    ')': '%29',
	    '~': '%7E',
	    '%20': '+',
	    '%00': '\x00'
	  };
	  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
	    return charMap[match];
	  });
	}

	/**
	 * It takes a params object and converts it to a FormData object
	 *
	 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
	 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
	 *
	 * @returns {void}
	 */
	function AxiosURLSearchParams(params, options) {
	  this._pairs = [];

	  params && toFormData(params, this, options);
	}

	const prototype = AxiosURLSearchParams.prototype;

	prototype.append = function append(name, value) {
	  this._pairs.push([name, value]);
	};

	prototype.toString = function toString(encoder) {
	  const _encode = encoder ? function(value) {
	    return encoder.call(this, value, encode$1);
	  } : encode$1;

	  return this._pairs.map(function each(pair) {
	    return _encode(pair[0]) + '=' + _encode(pair[1]);
	  }, '').join('&');
	};

	/**
	 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
	 * URI encoded counterparts
	 *
	 * @param {string} val The value to be encoded.
	 *
	 * @returns {string} The encoded value.
	 */
	function encode(val) {
	  return encodeURIComponent(val).
	    replace(/%3A/gi, ':').
	    replace(/%24/g, '$').
	    replace(/%2C/gi, ',').
	    replace(/%20/g, '+').
	    replace(/%5B/gi, '[').
	    replace(/%5D/gi, ']');
	}

	/**
	 * Build a URL by appending params to the end
	 *
	 * @param {string} url The base of the url (e.g., http://www.google.com)
	 * @param {object} [params] The params to be appended
	 * @param {?(object|Function)} options
	 *
	 * @returns {string} The formatted url
	 */
	function buildURL(url, params, options) {
	  /*eslint no-param-reassign:0*/
	  if (!params) {
	    return url;
	  }
	  
	  const _encode = options && options.encode || encode;

	  if (utils$1.isFunction(options)) {
	    options = {
	      serialize: options
	    };
	  } 

	  const serializeFn = options && options.serialize;

	  let serializedParams;

	  if (serializeFn) {
	    serializedParams = serializeFn(params, options);
	  } else {
	    serializedParams = utils$1.isURLSearchParams(params) ?
	      params.toString() :
	      new AxiosURLSearchParams(params, options).toString(_encode);
	  }

	  if (serializedParams) {
	    const hashmarkIndex = url.indexOf("#");

	    if (hashmarkIndex !== -1) {
	      url = url.slice(0, hashmarkIndex);
	    }
	    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
	  }

	  return url;
	}

	class InterceptorManager {
	  constructor() {
	    this.handlers = [];
	  }

	  /**
	   * Add a new interceptor to the stack
	   *
	   * @param {Function} fulfilled The function to handle `then` for a `Promise`
	   * @param {Function} rejected The function to handle `reject` for a `Promise`
	   *
	   * @return {Number} An ID used to remove interceptor later
	   */
	  use(fulfilled, rejected, options) {
	    this.handlers.push({
	      fulfilled,
	      rejected,
	      synchronous: options ? options.synchronous : false,
	      runWhen: options ? options.runWhen : null
	    });
	    return this.handlers.length - 1;
	  }

	  /**
	   * Remove an interceptor from the stack
	   *
	   * @param {Number} id The ID that was returned by `use`
	   *
	   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
	   */
	  eject(id) {
	    if (this.handlers[id]) {
	      this.handlers[id] = null;
	    }
	  }

	  /**
	   * Clear all interceptors from the stack
	   *
	   * @returns {void}
	   */
	  clear() {
	    if (this.handlers) {
	      this.handlers = [];
	    }
	  }

	  /**
	   * Iterate over all the registered interceptors
	   *
	   * This method is particularly useful for skipping over any
	   * interceptors that may have become `null` calling `eject`.
	   *
	   * @param {Function} fn The function to call for each interceptor
	   *
	   * @returns {void}
	   */
	  forEach(fn) {
	    utils$1.forEach(this.handlers, function forEachHandler(h) {
	      if (h !== null) {
	        fn(h);
	      }
	    });
	  }
	}

	var InterceptorManager$1 = InterceptorManager;

	var transitionalDefaults = {
	  silentJSONParsing: true,
	  forcedJSONParsing: true,
	  clarifyTimeoutError: false
	};

	var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

	var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

	var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

	var platform$1 = {
	  isBrowser: true,
	  classes: {
	    URLSearchParams: URLSearchParams$1,
	    FormData: FormData$1,
	    Blob: Blob$1
	  },
	  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
	};

	const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

	const _navigator = typeof navigator === 'object' && navigator || undefined;

	/**
	 * Determine if we're running in a standard browser environment
	 *
	 * This allows axios to run in a web worker, and react-native.
	 * Both environments support XMLHttpRequest, but not fully standard globals.
	 *
	 * web workers:
	 *  typeof window -> undefined
	 *  typeof document -> undefined
	 *
	 * react-native:
	 *  navigator.product -> 'ReactNative'
	 * nativescript
	 *  navigator.product -> 'NativeScript' or 'NS'
	 *
	 * @returns {boolean}
	 */
	const hasStandardBrowserEnv = hasBrowserEnv &&
	  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

	/**
	 * Determine if we're running in a standard browser webWorker environment
	 *
	 * Although the `isStandardBrowserEnv` method indicates that
	 * `allows axios to run in a web worker`, the WebWorker will still be
	 * filtered out due to its judgment standard
	 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
	 * This leads to a problem when axios post `FormData` in webWorker
	 */
	const hasStandardBrowserWebWorkerEnv = (() => {
	  return (
	    typeof WorkerGlobalScope !== 'undefined' &&
	    // eslint-disable-next-line no-undef
	    self instanceof WorkerGlobalScope &&
	    typeof self.importScripts === 'function'
	  );
	})();

	const origin = hasBrowserEnv && window.location.href || 'http://localhost';

	var utils = /*#__PURE__*/Object.freeze({
	  __proto__: null,
	  hasBrowserEnv: hasBrowserEnv,
	  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
	  hasStandardBrowserEnv: hasStandardBrowserEnv,
	  navigator: _navigator,
	  origin: origin
	});

	var platform = {
	  ...utils,
	  ...platform$1
	};

	function toURLEncodedForm(data, options) {
	  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
	    visitor: function(value, key, path, helpers) {
	      if (platform.isNode && utils$1.isBuffer(value)) {
	        this.append(key, value.toString('base64'));
	        return false;
	      }

	      return helpers.defaultVisitor.apply(this, arguments);
	    }
	  }, options));
	}

	/**
	 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
	 *
	 * @param {string} name - The name of the property to get.
	 *
	 * @returns An array of strings.
	 */
	function parsePropPath(name) {
	  // foo[x][y][z]
	  // foo.x.y.z
	  // foo-x-y-z
	  // foo x y z
	  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
	    return match[0] === '[]' ? '' : match[1] || match[0];
	  });
	}

	/**
	 * Convert an array to an object.
	 *
	 * @param {Array<any>} arr - The array to convert to an object.
	 *
	 * @returns An object with the same keys and values as the array.
	 */
	function arrayToObject(arr) {
	  const obj = {};
	  const keys = Object.keys(arr);
	  let i;
	  const len = keys.length;
	  let key;
	  for (i = 0; i < len; i++) {
	    key = keys[i];
	    obj[key] = arr[key];
	  }
	  return obj;
	}

	/**
	 * It takes a FormData object and returns a JavaScript object
	 *
	 * @param {string} formData The FormData object to convert to JSON.
	 *
	 * @returns {Object<string, any> | null} The converted object.
	 */
	function formDataToJSON(formData) {
	  function buildPath(path, value, target, index) {
	    let name = path[index++];

	    if (name === '__proto__') return true;

	    const isNumericKey = Number.isFinite(+name);
	    const isLast = index >= path.length;
	    name = !name && utils$1.isArray(target) ? target.length : name;

	    if (isLast) {
	      if (utils$1.hasOwnProp(target, name)) {
	        target[name] = [target[name], value];
	      } else {
	        target[name] = value;
	      }

	      return !isNumericKey;
	    }

	    if (!target[name] || !utils$1.isObject(target[name])) {
	      target[name] = [];
	    }

	    const result = buildPath(path, value, target[name], index);

	    if (result && utils$1.isArray(target[name])) {
	      target[name] = arrayToObject(target[name]);
	    }

	    return !isNumericKey;
	  }

	  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
	    const obj = {};

	    utils$1.forEachEntry(formData, (name, value) => {
	      buildPath(parsePropPath(name), value, obj, 0);
	    });

	    return obj;
	  }

	  return null;
	}

	/**
	 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
	 * of the input
	 *
	 * @param {any} rawValue - The value to be stringified.
	 * @param {Function} parser - A function that parses a string into a JavaScript object.
	 * @param {Function} encoder - A function that takes a value and returns a string.
	 *
	 * @returns {string} A stringified version of the rawValue.
	 */
	function stringifySafely(rawValue, parser, encoder) {
	  if (utils$1.isString(rawValue)) {
	    try {
	      (0, JSON.parse)(rawValue);
	      return utils$1.trim(rawValue);
	    } catch (e) {
	      if (e.name !== 'SyntaxError') {
	        throw e;
	      }
	    }
	  }

	  return (encoder || JSON.stringify)(rawValue);
	}

	const defaults = {

	  transitional: transitionalDefaults,

	  adapter: ['xhr', 'http', 'fetch'],

	  transformRequest: [function transformRequest(data, headers) {
	    const contentType = headers.getContentType() || '';
	    const hasJSONContentType = contentType.indexOf('application/json') > -1;
	    const isObjectPayload = utils$1.isObject(data);

	    if (isObjectPayload && utils$1.isHTMLForm(data)) {
	      data = new FormData(data);
	    }

	    const isFormData = utils$1.isFormData(data);

	    if (isFormData) {
	      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
	    }

	    if (utils$1.isArrayBuffer(data) ||
	      utils$1.isBuffer(data) ||
	      utils$1.isStream(data) ||
	      utils$1.isFile(data) ||
	      utils$1.isBlob(data) ||
	      utils$1.isReadableStream(data)
	    ) {
	      return data;
	    }
	    if (utils$1.isArrayBufferView(data)) {
	      return data.buffer;
	    }
	    if (utils$1.isURLSearchParams(data)) {
	      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
	      return data.toString();
	    }

	    let isFileList;

	    if (isObjectPayload) {
	      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
	        return toURLEncodedForm(data, this.formSerializer).toString();
	      }

	      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
	        const _FormData = this.env && this.env.FormData;

	        return toFormData(
	          isFileList ? {'files[]': data} : data,
	          _FormData && new _FormData(),
	          this.formSerializer
	        );
	      }
	    }

	    if (isObjectPayload || hasJSONContentType ) {
	      headers.setContentType('application/json', false);
	      return stringifySafely(data);
	    }

	    return data;
	  }],

	  transformResponse: [function transformResponse(data) {
	    const transitional = this.transitional || defaults.transitional;
	    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
	    const JSONRequested = this.responseType === 'json';

	    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
	      return data;
	    }

	    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
	      const silentJSONParsing = transitional && transitional.silentJSONParsing;
	      const strictJSONParsing = !silentJSONParsing && JSONRequested;

	      try {
	        return JSON.parse(data);
	      } catch (e) {
	        if (strictJSONParsing) {
	          if (e.name === 'SyntaxError') {
	            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
	          }
	          throw e;
	        }
	      }
	    }

	    return data;
	  }],

	  /**
	   * A timeout in milliseconds to abort a request. If set to 0 (default) a
	   * timeout is not created.
	   */
	  timeout: 0,

	  xsrfCookieName: 'XSRF-TOKEN',
	  xsrfHeaderName: 'X-XSRF-TOKEN',

	  maxContentLength: -1,
	  maxBodyLength: -1,

	  env: {
	    FormData: platform.classes.FormData,
	    Blob: platform.classes.Blob
	  },

	  validateStatus: function validateStatus(status) {
	    return status >= 200 && status < 300;
	  },

	  headers: {
	    common: {
	      'Accept': 'application/json, text/plain, */*',
	      'Content-Type': undefined
	    }
	  }
	};

	utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
	  defaults.headers[method] = {};
	});

	var defaults$1 = defaults;

	// RawAxiosHeaders whose duplicates are ignored by node
	// c.f. https://nodejs.org/api/http.html#http_message_headers
	const ignoreDuplicateOf = utils$1.toObjectSet([
	  'age', 'authorization', 'content-length', 'content-type', 'etag',
	  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
	  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
	  'referer', 'retry-after', 'user-agent'
	]);

	/**
	 * Parse headers into an object
	 *
	 * ```
	 * Date: Wed, 27 Aug 2014 08:58:49 GMT
	 * Content-Type: application/json
	 * Connection: keep-alive
	 * Transfer-Encoding: chunked
	 * ```
	 *
	 * @param {String} rawHeaders Headers needing to be parsed
	 *
	 * @returns {Object} Headers parsed into an object
	 */
	var parseHeaders = rawHeaders => {
	  const parsed = {};
	  let key;
	  let val;
	  let i;

	  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
	    i = line.indexOf(':');
	    key = line.substring(0, i).trim().toLowerCase();
	    val = line.substring(i + 1).trim();

	    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
	      return;
	    }

	    if (key === 'set-cookie') {
	      if (parsed[key]) {
	        parsed[key].push(val);
	      } else {
	        parsed[key] = [val];
	      }
	    } else {
	      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
	    }
	  });

	  return parsed;
	};

	const $internals = Symbol('internals');

	function normalizeHeader(header) {
	  return header && String(header).trim().toLowerCase();
	}

	function normalizeValue(value) {
	  if (value === false || value == null) {
	    return value;
	  }

	  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
	}

	function parseTokens(str) {
	  const tokens = Object.create(null);
	  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
	  let match;

	  while ((match = tokensRE.exec(str))) {
	    tokens[match[1]] = match[2];
	  }

	  return tokens;
	}

	const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

	function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
	  if (utils$1.isFunction(filter)) {
	    return filter.call(this, value, header);
	  }

	  if (isHeaderNameFilter) {
	    value = header;
	  }

	  if (!utils$1.isString(value)) return;

	  if (utils$1.isString(filter)) {
	    return value.indexOf(filter) !== -1;
	  }

	  if (utils$1.isRegExp(filter)) {
	    return filter.test(value);
	  }
	}

	function formatHeader(header) {
	  return header.trim()
	    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
	      return char.toUpperCase() + str;
	    });
	}

	function buildAccessors(obj, header) {
	  const accessorName = utils$1.toCamelCase(' ' + header);

	  ['get', 'set', 'has'].forEach(methodName => {
	    Object.defineProperty(obj, methodName + accessorName, {
	      value: function(arg1, arg2, arg3) {
	        return this[methodName].call(this, header, arg1, arg2, arg3);
	      },
	      configurable: true
	    });
	  });
	}

	class AxiosHeaders {
	  constructor(headers) {
	    headers && this.set(headers);
	  }

	  set(header, valueOrRewrite, rewrite) {
	    const self = this;

	    function setHeader(_value, _header, _rewrite) {
	      const lHeader = normalizeHeader(_header);

	      if (!lHeader) {
	        throw new Error('header name must be a non-empty string');
	      }

	      const key = utils$1.findKey(self, lHeader);

	      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
	        self[key || _header] = normalizeValue(_value);
	      }
	    }

	    const setHeaders = (headers, _rewrite) =>
	      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

	    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
	      setHeaders(header, valueOrRewrite);
	    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
	      setHeaders(parseHeaders(header), valueOrRewrite);
	    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
	      let obj = {}, dest, key;
	      for (const entry of header) {
	        if (!utils$1.isArray(entry)) {
	          throw TypeError('Object iterator must return a key-value pair');
	        }

	        obj[key = entry[0]] = (dest = obj[key]) ?
	          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
	      }

	      setHeaders(obj, valueOrRewrite);
	    } else {
	      header != null && setHeader(valueOrRewrite, header, rewrite);
	    }

	    return this;
	  }

	  get(header, parser) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      if (key) {
	        const value = this[key];

	        if (!parser) {
	          return value;
	        }

	        if (parser === true) {
	          return parseTokens(value);
	        }

	        if (utils$1.isFunction(parser)) {
	          return parser.call(this, value, key);
	        }

	        if (utils$1.isRegExp(parser)) {
	          return parser.exec(value);
	        }

	        throw new TypeError('parser must be boolean|regexp|function');
	      }
	    }
	  }

	  has(header, matcher) {
	    header = normalizeHeader(header);

	    if (header) {
	      const key = utils$1.findKey(this, header);

	      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
	    }

	    return false;
	  }

	  delete(header, matcher) {
	    const self = this;
	    let deleted = false;

	    function deleteHeader(_header) {
	      _header = normalizeHeader(_header);

	      if (_header) {
	        const key = utils$1.findKey(self, _header);

	        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
	          delete self[key];

	          deleted = true;
	        }
	      }
	    }

	    if (utils$1.isArray(header)) {
	      header.forEach(deleteHeader);
	    } else {
	      deleteHeader(header);
	    }

	    return deleted;
	  }

	  clear(matcher) {
	    const keys = Object.keys(this);
	    let i = keys.length;
	    let deleted = false;

	    while (i--) {
	      const key = keys[i];
	      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
	        delete this[key];
	        deleted = true;
	      }
	    }

	    return deleted;
	  }

	  normalize(format) {
	    const self = this;
	    const headers = {};

	    utils$1.forEach(this, (value, header) => {
	      const key = utils$1.findKey(headers, header);

	      if (key) {
	        self[key] = normalizeValue(value);
	        delete self[header];
	        return;
	      }

	      const normalized = format ? formatHeader(header) : String(header).trim();

	      if (normalized !== header) {
	        delete self[header];
	      }

	      self[normalized] = normalizeValue(value);

	      headers[normalized] = true;
	    });

	    return this;
	  }

	  concat(...targets) {
	    return this.constructor.concat(this, ...targets);
	  }

	  toJSON(asStrings) {
	    const obj = Object.create(null);

	    utils$1.forEach(this, (value, header) => {
	      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
	    });

	    return obj;
	  }

	  [Symbol.iterator]() {
	    return Object.entries(this.toJSON())[Symbol.iterator]();
	  }

	  toString() {
	    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
	  }

	  getSetCookie() {
	    return this.get("set-cookie") || [];
	  }

	  get [Symbol.toStringTag]() {
	    return 'AxiosHeaders';
	  }

	  static from(thing) {
	    return thing instanceof this ? thing : new this(thing);
	  }

	  static concat(first, ...targets) {
	    const computed = new this(first);

	    targets.forEach((target) => computed.set(target));

	    return computed;
	  }

	  static accessor(header) {
	    const internals = this[$internals] = (this[$internals] = {
	      accessors: {}
	    });

	    const accessors = internals.accessors;
	    const prototype = this.prototype;

	    function defineAccessor(_header) {
	      const lHeader = normalizeHeader(_header);

	      if (!accessors[lHeader]) {
	        buildAccessors(prototype, _header);
	        accessors[lHeader] = true;
	      }
	    }

	    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

	    return this;
	  }
	}

	AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

	// reserved names hotfix
	utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
	  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
	  return {
	    get: () => value,
	    set(headerValue) {
	      this[mapped] = headerValue;
	    }
	  }
	});

	utils$1.freezeMethods(AxiosHeaders);

	var AxiosHeaders$1 = AxiosHeaders;

	/**
	 * Transform the data for a request or a response
	 *
	 * @param {Array|Function} fns A single function or Array of functions
	 * @param {?Object} response The response object
	 *
	 * @returns {*} The resulting transformed data
	 */
	function transformData(fns, response) {
	  const config = this || defaults$1;
	  const context = response || config;
	  const headers = AxiosHeaders$1.from(context.headers);
	  let data = context.data;

	  utils$1.forEach(fns, function transform(fn) {
	    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
	  });

	  headers.normalize();

	  return data;
	}

	function isCancel(value) {
	  return !!(value && value.__CANCEL__);
	}

	/**
	 * A `CanceledError` is an object that is thrown when an operation is canceled.
	 *
	 * @param {string=} message The message.
	 * @param {Object=} config The config.
	 * @param {Object=} request The request.
	 *
	 * @returns {CanceledError} The created error.
	 */
	function CanceledError(message, config, request) {
	  // eslint-disable-next-line no-eq-null,eqeqeq
	  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
	  this.name = 'CanceledError';
	}

	utils$1.inherits(CanceledError, AxiosError, {
	  __CANCEL__: true
	});

	/**
	 * Resolve or reject a Promise based on response status.
	 *
	 * @param {Function} resolve A function that resolves the promise.
	 * @param {Function} reject A function that rejects the promise.
	 * @param {object} response The response.
	 *
	 * @returns {object} The response.
	 */
	function settle(resolve, reject, response) {
	  const validateStatus = response.config.validateStatus;
	  if (!response.status || !validateStatus || validateStatus(response.status)) {
	    resolve(response);
	  } else {
	    reject(new AxiosError(
	      'Request failed with status code ' + response.status,
	      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
	      response.config,
	      response.request,
	      response
	    ));
	  }
	}

	function parseProtocol(url) {
	  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
	  return match && match[1] || '';
	}

	/**
	 * Calculate data maxRate
	 * @param {Number} [samplesCount= 10]
	 * @param {Number} [min= 1000]
	 * @returns {Function}
	 */
	function speedometer(samplesCount, min) {
	  samplesCount = samplesCount || 10;
	  const bytes = new Array(samplesCount);
	  const timestamps = new Array(samplesCount);
	  let head = 0;
	  let tail = 0;
	  let firstSampleTS;

	  min = min !== undefined ? min : 1000;

	  return function push(chunkLength) {
	    const now = Date.now();

	    const startedAt = timestamps[tail];

	    if (!firstSampleTS) {
	      firstSampleTS = now;
	    }

	    bytes[head] = chunkLength;
	    timestamps[head] = now;

	    let i = tail;
	    let bytesCount = 0;

	    while (i !== head) {
	      bytesCount += bytes[i++];
	      i = i % samplesCount;
	    }

	    head = (head + 1) % samplesCount;

	    if (head === tail) {
	      tail = (tail + 1) % samplesCount;
	    }

	    if (now - firstSampleTS < min) {
	      return;
	    }

	    const passed = startedAt && now - startedAt;

	    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
	  };
	}

	/**
	 * Throttle decorator
	 * @param {Function} fn
	 * @param {Number} freq
	 * @return {Function}
	 */
	function throttle(fn, freq) {
	  let timestamp = 0;
	  let threshold = 1000 / freq;
	  let lastArgs;
	  let timer;

	  const invoke = (args, now = Date.now()) => {
	    timestamp = now;
	    lastArgs = null;
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	    fn.apply(null, args);
	  };

	  const throttled = (...args) => {
	    const now = Date.now();
	    const passed = now - timestamp;
	    if ( passed >= threshold) {
	      invoke(args, now);
	    } else {
	      lastArgs = args;
	      if (!timer) {
	        timer = setTimeout(() => {
	          timer = null;
	          invoke(lastArgs);
	        }, threshold - passed);
	      }
	    }
	  };

	  const flush = () => lastArgs && invoke(lastArgs);

	  return [throttled, flush];
	}

	const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
	  let bytesNotified = 0;
	  const _speedometer = speedometer(50, 250);

	  return throttle(e => {
	    const loaded = e.loaded;
	    const total = e.lengthComputable ? e.total : undefined;
	    const progressBytes = loaded - bytesNotified;
	    const rate = _speedometer(progressBytes);
	    const inRange = loaded <= total;

	    bytesNotified = loaded;

	    const data = {
	      loaded,
	      total,
	      progress: total ? (loaded / total) : undefined,
	      bytes: progressBytes,
	      rate: rate ? rate : undefined,
	      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
	      event: e,
	      lengthComputable: total != null,
	      [isDownloadStream ? 'download' : 'upload']: true
	    };

	    listener(data);
	  }, freq);
	};

	const progressEventDecorator = (total, throttled) => {
	  const lengthComputable = total != null;

	  return [(loaded) => throttled[0]({
	    lengthComputable,
	    total,
	    loaded
	  }), throttled[1]];
	};

	const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

	var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
	  url = new URL(url, platform.origin);

	  return (
	    origin.protocol === url.protocol &&
	    origin.host === url.host &&
	    (isMSIE || origin.port === url.port)
	  );
	})(
	  new URL(platform.origin),
	  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
	) : () => true;

	var cookies = platform.hasStandardBrowserEnv ?

	  // Standard browser envs support document.cookie
	  {
	    write(name, value, expires, path, domain, secure) {
	      const cookie = [name + '=' + encodeURIComponent(value)];

	      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

	      utils$1.isString(path) && cookie.push('path=' + path);

	      utils$1.isString(domain) && cookie.push('domain=' + domain);

	      secure === true && cookie.push('secure');

	      document.cookie = cookie.join('; ');
	    },

	    read(name) {
	      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
	      return (match ? decodeURIComponent(match[3]) : null);
	    },

	    remove(name) {
	      this.write(name, '', Date.now() - 86400000);
	    }
	  }

	  :

	  // Non-standard browser env (web workers, react-native) lack needed support.
	  {
	    write() {},
	    read() {
	      return null;
	    },
	    remove() {}
	  };

	/**
	 * Determines whether the specified URL is absolute
	 *
	 * @param {string} url The URL to test
	 *
	 * @returns {boolean} True if the specified URL is absolute, otherwise false
	 */
	function isAbsoluteURL(url) {
	  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
	  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
	  // by any combination of letters, digits, plus, period, or hyphen.
	  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
	}

	/**
	 * Creates a new URL by combining the specified URLs
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} relativeURL The relative URL
	 *
	 * @returns {string} The combined URL
	 */
	function combineURLs(baseURL, relativeURL) {
	  return relativeURL
	    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
	    : baseURL;
	}

	/**
	 * Creates a new URL by combining the baseURL with the requestedURL,
	 * only when the requestedURL is not already an absolute URL.
	 * If the requestURL is absolute, this function returns the requestedURL untouched.
	 *
	 * @param {string} baseURL The base URL
	 * @param {string} requestedURL Absolute or relative URL to combine
	 *
	 * @returns {string} The combined full path
	 */
	function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
	  let isRelativeUrl = !isAbsoluteURL(requestedURL);
	  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
	    return combineURLs(baseURL, requestedURL);
	  }
	  return requestedURL;
	}

	const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

	/**
	 * Config-specific merge-function which creates a new config-object
	 * by merging two configuration objects together.
	 *
	 * @param {Object} config1
	 * @param {Object} config2
	 *
	 * @returns {Object} New object resulting from merging config2 to config1
	 */
	function mergeConfig(config1, config2) {
	  // eslint-disable-next-line no-param-reassign
	  config2 = config2 || {};
	  const config = {};

	  function getMergedValue(target, source, prop, caseless) {
	    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
	      return utils$1.merge.call({caseless}, target, source);
	    } else if (utils$1.isPlainObject(source)) {
	      return utils$1.merge({}, source);
	    } else if (utils$1.isArray(source)) {
	      return source.slice();
	    }
	    return source;
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDeepProperties(a, b, prop , caseless) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(a, b, prop , caseless);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a, prop , caseless);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function valueFromConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function defaultToConfig2(a, b) {
	    if (!utils$1.isUndefined(b)) {
	      return getMergedValue(undefined, b);
	    } else if (!utils$1.isUndefined(a)) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  // eslint-disable-next-line consistent-return
	  function mergeDirectKeys(a, b, prop) {
	    if (prop in config2) {
	      return getMergedValue(a, b);
	    } else if (prop in config1) {
	      return getMergedValue(undefined, a);
	    }
	  }

	  const mergeMap = {
	    url: valueFromConfig2,
	    method: valueFromConfig2,
	    data: valueFromConfig2,
	    baseURL: defaultToConfig2,
	    transformRequest: defaultToConfig2,
	    transformResponse: defaultToConfig2,
	    paramsSerializer: defaultToConfig2,
	    timeout: defaultToConfig2,
	    timeoutMessage: defaultToConfig2,
	    withCredentials: defaultToConfig2,
	    withXSRFToken: defaultToConfig2,
	    adapter: defaultToConfig2,
	    responseType: defaultToConfig2,
	    xsrfCookieName: defaultToConfig2,
	    xsrfHeaderName: defaultToConfig2,
	    onUploadProgress: defaultToConfig2,
	    onDownloadProgress: defaultToConfig2,
	    decompress: defaultToConfig2,
	    maxContentLength: defaultToConfig2,
	    maxBodyLength: defaultToConfig2,
	    beforeRedirect: defaultToConfig2,
	    transport: defaultToConfig2,
	    httpAgent: defaultToConfig2,
	    httpsAgent: defaultToConfig2,
	    cancelToken: defaultToConfig2,
	    socketPath: defaultToConfig2,
	    responseEncoding: defaultToConfig2,
	    validateStatus: mergeDirectKeys,
	    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
	  };

	  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
	    const merge = mergeMap[prop] || mergeDeepProperties;
	    const configValue = merge(config1[prop], config2[prop], prop);
	    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
	  });

	  return config;
	}

	var resolveConfig = (config) => {
	  const newConfig = mergeConfig({}, config);

	  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

	  newConfig.headers = headers = AxiosHeaders$1.from(headers);

	  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

	  // HTTP basic authentication
	  if (auth) {
	    headers.set('Authorization', 'Basic ' +
	      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
	    );
	  }

	  let contentType;

	  if (utils$1.isFormData(data)) {
	    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
	      headers.setContentType(undefined); // Let the browser set it
	    } else if ((contentType = headers.getContentType()) !== false) {
	      // fix semicolon duplication issue for ReactNative FormData implementation
	      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
	      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
	    }
	  }

	  // Add xsrf header
	  // This is only done if running in a standard browser environment.
	  // Specifically not if we're in a web worker, or react-native.

	  if (platform.hasStandardBrowserEnv) {
	    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

	    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
	      // Add xsrf header
	      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

	      if (xsrfValue) {
	        headers.set(xsrfHeaderName, xsrfValue);
	      }
	    }
	  }

	  return newConfig;
	};

	const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

	var xhrAdapter = isXHRAdapterSupported && function (config) {
	  return new Promise(function dispatchXhrRequest(resolve, reject) {
	    const _config = resolveConfig(config);
	    let requestData = _config.data;
	    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
	    let {responseType, onUploadProgress, onDownloadProgress} = _config;
	    let onCanceled;
	    let uploadThrottled, downloadThrottled;
	    let flushUpload, flushDownload;

	    function done() {
	      flushUpload && flushUpload(); // flush events
	      flushDownload && flushDownload(); // flush events

	      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

	      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
	    }

	    let request = new XMLHttpRequest();

	    request.open(_config.method.toUpperCase(), _config.url, true);

	    // Set the request timeout in MS
	    request.timeout = _config.timeout;

	    function onloadend() {
	      if (!request) {
	        return;
	      }
	      // Prepare the response
	      const responseHeaders = AxiosHeaders$1.from(
	        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
	      );
	      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
	        request.responseText : request.response;
	      const response = {
	        data: responseData,
	        status: request.status,
	        statusText: request.statusText,
	        headers: responseHeaders,
	        config,
	        request
	      };

	      settle(function _resolve(value) {
	        resolve(value);
	        done();
	      }, function _reject(err) {
	        reject(err);
	        done();
	      }, response);

	      // Clean up request
	      request = null;
	    }

	    if ('onloadend' in request) {
	      // Use onloadend if available
	      request.onloadend = onloadend;
	    } else {
	      // Listen for ready state to emulate onloadend
	      request.onreadystatechange = function handleLoad() {
	        if (!request || request.readyState !== 4) {
	          return;
	        }

	        // The request errored out and we didn't get a response, this will be
	        // handled by onerror instead
	        // With one exception: request that using file: protocol, most browsers
	        // will return status as 0 even though it's a successful request
	        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
	          return;
	        }
	        // readystate handler is calling before onerror or ontimeout handlers,
	        // so we should call onloadend on the next 'tick'
	        setTimeout(onloadend);
	      };
	    }

	    // Handle browser request cancellation (as opposed to a manual cancellation)
	    request.onabort = function handleAbort() {
	      if (!request) {
	        return;
	      }

	      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle low level network errors
	    request.onerror = function handleError() {
	      // Real errors are hidden from us by the browser
	      // onerror should only fire if it's a network error
	      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

	      // Clean up request
	      request = null;
	    };

	    // Handle timeout
	    request.ontimeout = function handleTimeout() {
	      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
	      const transitional = _config.transitional || transitionalDefaults;
	      if (_config.timeoutErrorMessage) {
	        timeoutErrorMessage = _config.timeoutErrorMessage;
	      }
	      reject(new AxiosError(
	        timeoutErrorMessage,
	        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
	        config,
	        request));

	      // Clean up request
	      request = null;
	    };

	    // Remove Content-Type if data is undefined
	    requestData === undefined && requestHeaders.setContentType(null);

	    // Add headers to the request
	    if ('setRequestHeader' in request) {
	      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
	        request.setRequestHeader(key, val);
	      });
	    }

	    // Add withCredentials to request if needed
	    if (!utils$1.isUndefined(_config.withCredentials)) {
	      request.withCredentials = !!_config.withCredentials;
	    }

	    // Add responseType to request if needed
	    if (responseType && responseType !== 'json') {
	      request.responseType = _config.responseType;
	    }

	    // Handle progress if needed
	    if (onDownloadProgress) {
	      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
	      request.addEventListener('progress', downloadThrottled);
	    }

	    // Not all browsers support upload events
	    if (onUploadProgress && request.upload) {
	      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

	      request.upload.addEventListener('progress', uploadThrottled);

	      request.upload.addEventListener('loadend', flushUpload);
	    }

	    if (_config.cancelToken || _config.signal) {
	      // Handle cancellation
	      // eslint-disable-next-line func-names
	      onCanceled = cancel => {
	        if (!request) {
	          return;
	        }
	        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
	        request.abort();
	        request = null;
	      };

	      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
	      if (_config.signal) {
	        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
	      }
	    }

	    const protocol = parseProtocol(_config.url);

	    if (protocol && platform.protocols.indexOf(protocol) === -1) {
	      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
	      return;
	    }


	    // Send the request
	    request.send(requestData || null);
	  });
	};

	const composeSignals = (signals, timeout) => {
	  const {length} = (signals = signals ? signals.filter(Boolean) : []);

	  if (timeout || length) {
	    let controller = new AbortController();

	    let aborted;

	    const onabort = function (reason) {
	      if (!aborted) {
	        aborted = true;
	        unsubscribe();
	        const err = reason instanceof Error ? reason : this.reason;
	        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
	      }
	    };

	    let timer = timeout && setTimeout(() => {
	      timer = null;
	      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
	    }, timeout);

	    const unsubscribe = () => {
	      if (signals) {
	        timer && clearTimeout(timer);
	        timer = null;
	        signals.forEach(signal => {
	          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
	        });
	        signals = null;
	      }
	    };

	    signals.forEach((signal) => signal.addEventListener('abort', onabort));

	    const {signal} = controller;

	    signal.unsubscribe = () => utils$1.asap(unsubscribe);

	    return signal;
	  }
	};

	var composeSignals$1 = composeSignals;

	const streamChunk = function* (chunk, chunkSize) {
	  let len = chunk.byteLength;

	  if (len < chunkSize) {
	    yield chunk;
	    return;
	  }

	  let pos = 0;
	  let end;

	  while (pos < len) {
	    end = pos + chunkSize;
	    yield chunk.slice(pos, end);
	    pos = end;
	  }
	};

	const readBytes = async function* (iterable, chunkSize) {
	  for await (const chunk of readStream(iterable)) {
	    yield* streamChunk(chunk, chunkSize);
	  }
	};

	const readStream = async function* (stream) {
	  if (stream[Symbol.asyncIterator]) {
	    yield* stream;
	    return;
	  }

	  const reader = stream.getReader();
	  try {
	    for (;;) {
	      const {done, value} = await reader.read();
	      if (done) {
	        break;
	      }
	      yield value;
	    }
	  } finally {
	    await reader.cancel();
	  }
	};

	const trackStream = (stream, chunkSize, onProgress, onFinish) => {
	  const iterator = readBytes(stream, chunkSize);

	  let bytes = 0;
	  let done;
	  let _onFinish = (e) => {
	    if (!done) {
	      done = true;
	      onFinish && onFinish(e);
	    }
	  };

	  return new ReadableStream({
	    async pull(controller) {
	      try {
	        const {done, value} = await iterator.next();

	        if (done) {
	         _onFinish();
	          controller.close();
	          return;
	        }

	        let len = value.byteLength;
	        if (onProgress) {
	          let loadedBytes = bytes += len;
	          onProgress(loadedBytes);
	        }
	        controller.enqueue(new Uint8Array(value));
	      } catch (err) {
	        _onFinish(err);
	        throw err;
	      }
	    },
	    cancel(reason) {
	      _onFinish(reason);
	      return iterator.return();
	    }
	  }, {
	    highWaterMark: 2
	  })
	};

	const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
	const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

	// used only inside the fetch adapter
	const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
	    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
	    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
	);

	const test = (fn, ...args) => {
	  try {
	    return !!fn(...args);
	  } catch (e) {
	    return false
	  }
	};

	const supportsRequestStream = isReadableStreamSupported && test(() => {
	  let duplexAccessed = false;

	  const hasContentType = new Request(platform.origin, {
	    body: new ReadableStream(),
	    method: 'POST',
	    get duplex() {
	      duplexAccessed = true;
	      return 'half';
	    },
	  }).headers.has('Content-Type');

	  return duplexAccessed && !hasContentType;
	});

	const DEFAULT_CHUNK_SIZE = 64 * 1024;

	const supportsResponseStream = isReadableStreamSupported &&
	  test(() => utils$1.isReadableStream(new Response('').body));


	const resolvers = {
	  stream: supportsResponseStream && ((res) => res.body)
	};

	isFetchSupported && (((res) => {
	  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
	    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
	      (_, config) => {
	        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
	      });
	  });
	})(new Response));

	const getBodyLength = async (body) => {
	  if (body == null) {
	    return 0;
	  }

	  if(utils$1.isBlob(body)) {
	    return body.size;
	  }

	  if(utils$1.isSpecCompliantForm(body)) {
	    const _request = new Request(platform.origin, {
	      method: 'POST',
	      body,
	    });
	    return (await _request.arrayBuffer()).byteLength;
	  }

	  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
	    return body.byteLength;
	  }

	  if(utils$1.isURLSearchParams(body)) {
	    body = body + '';
	  }

	  if(utils$1.isString(body)) {
	    return (await encodeText(body)).byteLength;
	  }
	};

	const resolveBodyLength = async (headers, body) => {
	  const length = utils$1.toFiniteNumber(headers.getContentLength());

	  return length == null ? getBodyLength(body) : length;
	};

	var fetchAdapter = isFetchSupported && (async (config) => {
	  let {
	    url,
	    method,
	    data,
	    signal,
	    cancelToken,
	    timeout,
	    onDownloadProgress,
	    onUploadProgress,
	    responseType,
	    headers,
	    withCredentials = 'same-origin',
	    fetchOptions
	  } = resolveConfig(config);

	  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

	  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

	  let request;

	  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
	      composedSignal.unsubscribe();
	  });

	  let requestContentLength;

	  try {
	    if (
	      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
	      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
	    ) {
	      let _request = new Request(url, {
	        method: 'POST',
	        body: data,
	        duplex: "half"
	      });

	      let contentTypeHeader;

	      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
	        headers.setContentType(contentTypeHeader);
	      }

	      if (_request.body) {
	        const [onProgress, flush] = progressEventDecorator(
	          requestContentLength,
	          progressEventReducer(asyncDecorator(onUploadProgress))
	        );

	        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
	      }
	    }

	    if (!utils$1.isString(withCredentials)) {
	      withCredentials = withCredentials ? 'include' : 'omit';
	    }

	    // Cloudflare Workers throws when credentials are defined
	    // see https://github.com/cloudflare/workerd/issues/902
	    const isCredentialsSupported = "credentials" in Request.prototype;
	    request = new Request(url, {
	      ...fetchOptions,
	      signal: composedSignal,
	      method: method.toUpperCase(),
	      headers: headers.normalize().toJSON(),
	      body: data,
	      duplex: "half",
	      credentials: isCredentialsSupported ? withCredentials : undefined
	    });

	    let response = await fetch(request, fetchOptions);

	    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

	    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
	      const options = {};

	      ['status', 'statusText', 'headers'].forEach(prop => {
	        options[prop] = response[prop];
	      });

	      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

	      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
	        responseContentLength,
	        progressEventReducer(asyncDecorator(onDownloadProgress), true)
	      ) || [];

	      response = new Response(
	        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
	          flush && flush();
	          unsubscribe && unsubscribe();
	        }),
	        options
	      );
	    }

	    responseType = responseType || 'text';

	    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

	    !isStreamResponse && unsubscribe && unsubscribe();

	    return await new Promise((resolve, reject) => {
	      settle(resolve, reject, {
	        data: responseData,
	        headers: AxiosHeaders$1.from(response.headers),
	        status: response.status,
	        statusText: response.statusText,
	        config,
	        request
	      });
	    })
	  } catch (err) {
	    unsubscribe && unsubscribe();

	    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
	      throw Object.assign(
	        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
	        {
	          cause: err.cause || err
	        }
	      )
	    }

	    throw AxiosError.from(err, err && err.code, config, request);
	  }
	});

	const knownAdapters = {
	  http: httpAdapter,
	  xhr: xhrAdapter,
	  fetch: fetchAdapter
	};

	utils$1.forEach(knownAdapters, (fn, value) => {
	  if (fn) {
	    try {
	      Object.defineProperty(fn, 'name', {value});
	    } catch (e) {
	      // eslint-disable-next-line no-empty
	    }
	    Object.defineProperty(fn, 'adapterName', {value});
	  }
	});

	const renderReason = (reason) => `- ${reason}`;

	const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

	var adapters = {
	  getAdapter: (adapters) => {
	    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

	    const {length} = adapters;
	    let nameOrAdapter;
	    let adapter;

	    const rejectedReasons = {};

	    for (let i = 0; i < length; i++) {
	      nameOrAdapter = adapters[i];
	      let id;

	      adapter = nameOrAdapter;

	      if (!isResolvedHandle(nameOrAdapter)) {
	        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

	        if (adapter === undefined) {
	          throw new AxiosError(`Unknown adapter '${id}'`);
	        }
	      }

	      if (adapter) {
	        break;
	      }

	      rejectedReasons[id || '#' + i] = adapter;
	    }

	    if (!adapter) {

	      const reasons = Object.entries(rejectedReasons)
	        .map(([id, state]) => `adapter ${id} ` +
	          (state === false ? 'is not supported by the environment' : 'is not available in the build')
	        );

	      let s = length ?
	        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
	        'as no adapter specified';

	      throw new AxiosError(
	        `There is no suitable adapter to dispatch the request ` + s,
	        'ERR_NOT_SUPPORT'
	      );
	    }

	    return adapter;
	  },
	  adapters: knownAdapters
	};

	/**
	 * Throws a `CanceledError` if cancellation has been requested.
	 *
	 * @param {Object} config The config that is to be used for the request
	 *
	 * @returns {void}
	 */
	function throwIfCancellationRequested(config) {
	  if (config.cancelToken) {
	    config.cancelToken.throwIfRequested();
	  }

	  if (config.signal && config.signal.aborted) {
	    throw new CanceledError(null, config);
	  }
	}

	/**
	 * Dispatch a request to the server using the configured adapter.
	 *
	 * @param {object} config The config that is to be used for the request
	 *
	 * @returns {Promise} The Promise to be fulfilled
	 */
	function dispatchRequest(config) {
	  throwIfCancellationRequested(config);

	  config.headers = AxiosHeaders$1.from(config.headers);

	  // Transform request data
	  config.data = transformData.call(
	    config,
	    config.transformRequest
	  );

	  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
	    config.headers.setContentType('application/x-www-form-urlencoded', false);
	  }

	  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

	  return adapter(config).then(function onAdapterResolution(response) {
	    throwIfCancellationRequested(config);

	    // Transform response data
	    response.data = transformData.call(
	      config,
	      config.transformResponse,
	      response
	    );

	    response.headers = AxiosHeaders$1.from(response.headers);

	    return response;
	  }, function onAdapterRejection(reason) {
	    if (!isCancel(reason)) {
	      throwIfCancellationRequested(config);

	      // Transform response data
	      if (reason && reason.response) {
	        reason.response.data = transformData.call(
	          config,
	          config.transformResponse,
	          reason.response
	        );
	        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
	      }
	    }

	    return Promise.reject(reason);
	  });
	}

	const VERSION = "1.10.0";

	const validators$1 = {};

	// eslint-disable-next-line func-names
	['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
	  validators$1[type] = function validator(thing) {
	    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
	  };
	});

	const deprecatedWarnings = {};

	/**
	 * Transitional option validator
	 *
	 * @param {function|boolean?} validator - set to false if the transitional option has been removed
	 * @param {string?} version - deprecated version / removed since version
	 * @param {string?} message - some message with additional info
	 *
	 * @returns {function}
	 */
	validators$1.transitional = function transitional(validator, version, message) {
	  function formatMessage(opt, desc) {
	    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
	  }

	  // eslint-disable-next-line func-names
	  return (value, opt, opts) => {
	    if (validator === false) {
	      throw new AxiosError(
	        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
	        AxiosError.ERR_DEPRECATED
	      );
	    }

	    if (version && !deprecatedWarnings[opt]) {
	      deprecatedWarnings[opt] = true;
	      // eslint-disable-next-line no-console
	      console.warn(
	        formatMessage(
	          opt,
	          ' has been deprecated since v' + version + ' and will be removed in the near future'
	        )
	      );
	    }

	    return validator ? validator(value, opt, opts) : true;
	  };
	};

	validators$1.spelling = function spelling(correctSpelling) {
	  return (value, opt) => {
	    // eslint-disable-next-line no-console
	    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
	    return true;
	  }
	};

	/**
	 * Assert object's properties type
	 *
	 * @param {object} options
	 * @param {object} schema
	 * @param {boolean?} allowUnknown
	 *
	 * @returns {object}
	 */

	function assertOptions(options, schema, allowUnknown) {
	  if (typeof options !== 'object') {
	    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
	  }
	  const keys = Object.keys(options);
	  let i = keys.length;
	  while (i-- > 0) {
	    const opt = keys[i];
	    const validator = schema[opt];
	    if (validator) {
	      const value = options[opt];
	      const result = value === undefined || validator(value, opt, options);
	      if (result !== true) {
	        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
	      }
	      continue;
	    }
	    if (allowUnknown !== true) {
	      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
	    }
	  }
	}

	var validator = {
	  assertOptions,
	  validators: validators$1
	};

	const validators = validator.validators;

	/**
	 * Create a new instance of Axios
	 *
	 * @param {Object} instanceConfig The default config for the instance
	 *
	 * @return {Axios} A new instance of Axios
	 */
	class Axios {
	  constructor(instanceConfig) {
	    this.defaults = instanceConfig || {};
	    this.interceptors = {
	      request: new InterceptorManager$1(),
	      response: new InterceptorManager$1()
	    };
	  }

	  /**
	   * Dispatch a request
	   *
	   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
	   * @param {?Object} config
	   *
	   * @returns {Promise} The Promise to be fulfilled
	   */
	  async request(configOrUrl, config) {
	    try {
	      return await this._request(configOrUrl, config);
	    } catch (err) {
	      if (err instanceof Error) {
	        let dummy = {};

	        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

	        // slice off the Error: ... line
	        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
	        try {
	          if (!err.stack) {
	            err.stack = stack;
	            // match without the 2 top stack lines
	          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
	            err.stack += '\n' + stack;
	          }
	        } catch (e) {
	          // ignore the case where "stack" is an un-writable property
	        }
	      }

	      throw err;
	    }
	  }

	  _request(configOrUrl, config) {
	    /*eslint no-param-reassign:0*/
	    // Allow for axios('example/url'[, config]) a la fetch API
	    if (typeof configOrUrl === 'string') {
	      config = config || {};
	      config.url = configOrUrl;
	    } else {
	      config = configOrUrl || {};
	    }

	    config = mergeConfig(this.defaults, config);

	    const {transitional, paramsSerializer, headers} = config;

	    if (transitional !== undefined) {
	      validator.assertOptions(transitional, {
	        silentJSONParsing: validators.transitional(validators.boolean),
	        forcedJSONParsing: validators.transitional(validators.boolean),
	        clarifyTimeoutError: validators.transitional(validators.boolean)
	      }, false);
	    }

	    if (paramsSerializer != null) {
	      if (utils$1.isFunction(paramsSerializer)) {
	        config.paramsSerializer = {
	          serialize: paramsSerializer
	        };
	      } else {
	        validator.assertOptions(paramsSerializer, {
	          encode: validators.function,
	          serialize: validators.function
	        }, true);
	      }
	    }

	    // Set config.allowAbsoluteUrls
	    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
	      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
	    } else {
	      config.allowAbsoluteUrls = true;
	    }

	    validator.assertOptions(config, {
	      baseUrl: validators.spelling('baseURL'),
	      withXsrfToken: validators.spelling('withXSRFToken')
	    }, true);

	    // Set config.method
	    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

	    // Flatten headers
	    let contextHeaders = headers && utils$1.merge(
	      headers.common,
	      headers[config.method]
	    );

	    headers && utils$1.forEach(
	      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
	      (method) => {
	        delete headers[method];
	      }
	    );

	    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

	    // filter out skipped interceptors
	    const requestInterceptorChain = [];
	    let synchronousRequestInterceptors = true;
	    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
	      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
	        return;
	      }

	      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

	      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
	    });

	    const responseInterceptorChain = [];
	    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
	      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
	    });

	    let promise;
	    let i = 0;
	    let len;

	    if (!synchronousRequestInterceptors) {
	      const chain = [dispatchRequest.bind(this), undefined];
	      chain.unshift.apply(chain, requestInterceptorChain);
	      chain.push.apply(chain, responseInterceptorChain);
	      len = chain.length;

	      promise = Promise.resolve(config);

	      while (i < len) {
	        promise = promise.then(chain[i++], chain[i++]);
	      }

	      return promise;
	    }

	    len = requestInterceptorChain.length;

	    let newConfig = config;

	    i = 0;

	    while (i < len) {
	      const onFulfilled = requestInterceptorChain[i++];
	      const onRejected = requestInterceptorChain[i++];
	      try {
	        newConfig = onFulfilled(newConfig);
	      } catch (error) {
	        onRejected.call(this, error);
	        break;
	      }
	    }

	    try {
	      promise = dispatchRequest.call(this, newConfig);
	    } catch (error) {
	      return Promise.reject(error);
	    }

	    i = 0;
	    len = responseInterceptorChain.length;

	    while (i < len) {
	      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
	    }

	    return promise;
	  }

	  getUri(config) {
	    config = mergeConfig(this.defaults, config);
	    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
	    return buildURL(fullPath, config.params, config.paramsSerializer);
	  }
	}

	// Provide aliases for supported request methods
	utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
	  /*eslint func-names:0*/
	  Axios.prototype[method] = function(url, config) {
	    return this.request(mergeConfig(config || {}, {
	      method,
	      url,
	      data: (config || {}).data
	    }));
	  };
	});

	utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
	  /*eslint func-names:0*/

	  function generateHTTPMethod(isForm) {
	    return function httpMethod(url, data, config) {
	      return this.request(mergeConfig(config || {}, {
	        method,
	        headers: isForm ? {
	          'Content-Type': 'multipart/form-data'
	        } : {},
	        url,
	        data
	      }));
	    };
	  }

	  Axios.prototype[method] = generateHTTPMethod();

	  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
	});

	var Axios$1 = Axios;

	/**
	 * A `CancelToken` is an object that can be used to request cancellation of an operation.
	 *
	 * @param {Function} executor The executor function.
	 *
	 * @returns {CancelToken}
	 */
	class CancelToken {
	  constructor(executor) {
	    if (typeof executor !== 'function') {
	      throw new TypeError('executor must be a function.');
	    }

	    let resolvePromise;

	    this.promise = new Promise(function promiseExecutor(resolve) {
	      resolvePromise = resolve;
	    });

	    const token = this;

	    // eslint-disable-next-line func-names
	    this.promise.then(cancel => {
	      if (!token._listeners) return;

	      let i = token._listeners.length;

	      while (i-- > 0) {
	        token._listeners[i](cancel);
	      }
	      token._listeners = null;
	    });

	    // eslint-disable-next-line func-names
	    this.promise.then = onfulfilled => {
	      let _resolve;
	      // eslint-disable-next-line func-names
	      const promise = new Promise(resolve => {
	        token.subscribe(resolve);
	        _resolve = resolve;
	      }).then(onfulfilled);

	      promise.cancel = function reject() {
	        token.unsubscribe(_resolve);
	      };

	      return promise;
	    };

	    executor(function cancel(message, config, request) {
	      if (token.reason) {
	        // Cancellation has already been requested
	        return;
	      }

	      token.reason = new CanceledError(message, config, request);
	      resolvePromise(token.reason);
	    });
	  }

	  /**
	   * Throws a `CanceledError` if cancellation has been requested.
	   */
	  throwIfRequested() {
	    if (this.reason) {
	      throw this.reason;
	    }
	  }

	  /**
	   * Subscribe to the cancel signal
	   */

	  subscribe(listener) {
	    if (this.reason) {
	      listener(this.reason);
	      return;
	    }

	    if (this._listeners) {
	      this._listeners.push(listener);
	    } else {
	      this._listeners = [listener];
	    }
	  }

	  /**
	   * Unsubscribe from the cancel signal
	   */

	  unsubscribe(listener) {
	    if (!this._listeners) {
	      return;
	    }
	    const index = this._listeners.indexOf(listener);
	    if (index !== -1) {
	      this._listeners.splice(index, 1);
	    }
	  }

	  toAbortSignal() {
	    const controller = new AbortController();

	    const abort = (err) => {
	      controller.abort(err);
	    };

	    this.subscribe(abort);

	    controller.signal.unsubscribe = () => this.unsubscribe(abort);

	    return controller.signal;
	  }

	  /**
	   * Returns an object that contains a new `CancelToken` and a function that, when called,
	   * cancels the `CancelToken`.
	   */
	  static source() {
	    let cancel;
	    const token = new CancelToken(function executor(c) {
	      cancel = c;
	    });
	    return {
	      token,
	      cancel
	    };
	  }
	}

	var CancelToken$1 = CancelToken;

	/**
	 * Syntactic sugar for invoking a function and expanding an array for arguments.
	 *
	 * Common use case would be to use `Function.prototype.apply`.
	 *
	 *  ```js
	 *  function f(x, y, z) {}
	 *  var args = [1, 2, 3];
	 *  f.apply(null, args);
	 *  ```
	 *
	 * With `spread` this example can be re-written.
	 *
	 *  ```js
	 *  spread(function(x, y, z) {})([1, 2, 3]);
	 *  ```
	 *
	 * @param {Function} callback
	 *
	 * @returns {Function}
	 */
	function spread(callback) {
	  return function wrap(arr) {
	    return callback.apply(null, arr);
	  };
	}

	/**
	 * Determines whether the payload is an error thrown by Axios
	 *
	 * @param {*} payload The value to test
	 *
	 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
	 */
	function isAxiosError(payload) {
	  return utils$1.isObject(payload) && (payload.isAxiosError === true);
	}

	const HttpStatusCode = {
	  Continue: 100,
	  SwitchingProtocols: 101,
	  Processing: 102,
	  EarlyHints: 103,
	  Ok: 200,
	  Created: 201,
	  Accepted: 202,
	  NonAuthoritativeInformation: 203,
	  NoContent: 204,
	  ResetContent: 205,
	  PartialContent: 206,
	  MultiStatus: 207,
	  AlreadyReported: 208,
	  ImUsed: 226,
	  MultipleChoices: 300,
	  MovedPermanently: 301,
	  Found: 302,
	  SeeOther: 303,
	  NotModified: 304,
	  UseProxy: 305,
	  Unused: 306,
	  TemporaryRedirect: 307,
	  PermanentRedirect: 308,
	  BadRequest: 400,
	  Unauthorized: 401,
	  PaymentRequired: 402,
	  Forbidden: 403,
	  NotFound: 404,
	  MethodNotAllowed: 405,
	  NotAcceptable: 406,
	  ProxyAuthenticationRequired: 407,
	  RequestTimeout: 408,
	  Conflict: 409,
	  Gone: 410,
	  LengthRequired: 411,
	  PreconditionFailed: 412,
	  PayloadTooLarge: 413,
	  UriTooLong: 414,
	  UnsupportedMediaType: 415,
	  RangeNotSatisfiable: 416,
	  ExpectationFailed: 417,
	  ImATeapot: 418,
	  MisdirectedRequest: 421,
	  UnprocessableEntity: 422,
	  Locked: 423,
	  FailedDependency: 424,
	  TooEarly: 425,
	  UpgradeRequired: 426,
	  PreconditionRequired: 428,
	  TooManyRequests: 429,
	  RequestHeaderFieldsTooLarge: 431,
	  UnavailableForLegalReasons: 451,
	  InternalServerError: 500,
	  NotImplemented: 501,
	  BadGateway: 502,
	  ServiceUnavailable: 503,
	  GatewayTimeout: 504,
	  HttpVersionNotSupported: 505,
	  VariantAlsoNegotiates: 506,
	  InsufficientStorage: 507,
	  LoopDetected: 508,
	  NotExtended: 510,
	  NetworkAuthenticationRequired: 511,
	};

	Object.entries(HttpStatusCode).forEach(([key, value]) => {
	  HttpStatusCode[value] = key;
	});

	var HttpStatusCode$1 = HttpStatusCode;

	/**
	 * Create an instance of Axios
	 *
	 * @param {Object} defaultConfig The default config for the instance
	 *
	 * @returns {Axios} A new instance of Axios
	 */
	function createInstance(defaultConfig) {
	  const context = new Axios$1(defaultConfig);
	  const instance = bind(Axios$1.prototype.request, context);

	  // Copy axios.prototype to instance
	  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

	  // Copy context to instance
	  utils$1.extend(instance, context, null, {allOwnKeys: true});

	  // Factory for creating new instances
	  instance.create = function create(instanceConfig) {
	    return createInstance(mergeConfig(defaultConfig, instanceConfig));
	  };

	  return instance;
	}

	// Create the default instance to be exported
	const axios = createInstance(defaults$1);

	// Expose Axios class to allow class inheritance
	axios.Axios = Axios$1;

	// Expose Cancel & CancelToken
	axios.CanceledError = CanceledError;
	axios.CancelToken = CancelToken$1;
	axios.isCancel = isCancel;
	axios.VERSION = VERSION;
	axios.toFormData = toFormData;

	// Expose AxiosError class
	axios.AxiosError = AxiosError;

	// alias for CanceledError for backward compatibility
	axios.Cancel = axios.CanceledError;

	// Expose all/spread
	axios.all = function all(promises) {
	  return Promise.all(promises);
	};

	axios.spread = spread;

	// Expose isAxiosError
	axios.isAxiosError = isAxiosError;

	// Expose mergeConfig
	axios.mergeConfig = mergeConfig;

	axios.AxiosHeaders = AxiosHeaders$1;

	axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

	axios.getAdapter = adapters.getAdapter;

	axios.HttpStatusCode = HttpStatusCode$1;

	axios.default = axios;

	axios_1 = axios;
	
	return axios_1;
}

var axiosExports = /*@__PURE__*/ requireAxios();
var axios = /*@__PURE__*/getDefaultExportFromCjs(axiosExports);

class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
            code = "0" + code;
        }
        return "%" + code;
    }));
}
function base64UrlDecode(str) {
    let output = str.replace(/-/g, "+").replace(/_/g, "/");
    switch (output.length % 4) {
        case 0:
            break;
        case 2:
            output += "==";
            break;
        case 3:
            output += "=";
            break;
        default:
            throw new Error("base64 string is not of the correct length");
    }
    try {
        return b64DecodeUnicode(output);
    }
    catch (err) {
        return atob(output);
    }
}
function jwtDecode(token, options) {
    if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
    }
    options || (options = {});
    const pos = options.header === true ? 0 : 1;
    const part = token.split(".")[pos];
    if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
    }
    let decoded;
    try {
        decoded = base64UrlDecode(part);
    }
    catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
    }
    try {
        return JSON.parse(decoded);
    }
    catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
    }
}

function n$2(t,e,l,n,r){for(e=e.split?e.split("."):e,n=0;n<e.length;n++)t=t?t[e[n]]:r;return t===r?l:t}

var e="undefined",o$1="object",b$3="any",m$1="*",j$1="__";"undefined"!=typeof process?process:{};var $$1="undefined"!=typeof document;"undefined"!=typeof Deno&&void 0!==Deno.core;$$1&&"nodejs"===window.name||"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&(navigator.userAgent.includes("Node.js")||navigator.userAgent.includes("jsdom"));function M$1(n,t){return t.charAt(0)[n]()+t.slice(1)}var U$1=M$1.bind(null,"toUpperCase"),H$1=M$1.bind(null,"toLowerCase");function J$2(n){return Y$1(n)?U$1("null"):"object"==typeof n?yn(n):Object.prototype.toString.call(n).slice(8,-1)}function R$1(n,t){ void 0===t&&(t=true);var e=J$2(n);return t?H$1(e):e}function V$1(n,t){return typeof t===n}var W$1=V$1.bind(null,"function"),q$1=V$1.bind(null,"string"),I$2=V$1.bind(null,"undefined");var Q$1=V$1.bind(null,"boolean");V$1.bind(null,"symbol");function Y$1(n){return null===n}function nn(n){return "number"===R$1(n)&&!isNaN(n)}function rn(n){return "array"===R$1(n)}function on(n){if(!un(n))return false;for(var t=n;null!==Object.getPrototypeOf(t);)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(n)===t}function un(n){return n&&("object"==typeof n||null!==n)}function yn(n){return W$1(n.constructor)?n.constructor.name:null}function hn(n){return n instanceof Error||q$1(n.message)&&n.constructor&&nn(n.constructor.stackTraceLimit)}function On(n,t){if("object"!=typeof t||Y$1(t))return false;if(t instanceof n)return true;var e=R$1(new n(""));if(hn(t))for(;t;){if(R$1(t)===e)return true;t=Object.getPrototypeOf(t);}return false}On.bind(null,TypeError);On.bind(null,SyntaxError);function $n(n,t){var e=n instanceof Element||n instanceof HTMLDocument;return e&&t?Tn(n,t):e}function Tn(n,t){return void 0===t&&(t=""),n&&n.nodeName===t.toUpperCase()}function _n(n){var t=[].slice.call(arguments,1);return function(){return n.apply(void 0,[].slice.call(arguments).concat(t))}}_n($n,"form");_n($n,"button");_n($n,"input");_n($n,"select");

function n$1(e){try{return decodeURIComponent(e.replace(/\+/g," "))}catch(e){return null}}function s$1(r){return function(e){for(var r,t=Object.create(null),o=/([^&=]+)=?([^&]*)/g;r=o.exec(e);){var a=n$1(r[1]),i=n$1(r[2]);"[]"===a.substring(a.length-2)?(t[a=a.substring(0,a.length-2)]||(t[a]=[])).push(i):t[a]=""===i||i;}for(var u in t){var c=u.split("[");c.length>1&&(m$2(t,c.map(function(e){return e.replace(/[?[\]\\ ]/g,"")}),t[u]),delete t[u]);}return t}(function(r){return $$1&&window.location.search.substring(1)}())}function m$2(e,r,t){for(var n=r.length-1,o=0;o<n;++o){var a=r[o];if("__proto__"===a||"constructor"===a)break;a in e||(e[a]={}),e=e[a];}e[r[n]]=t;}function y$1(){for(var e="",r=0,t=4294967295*Math.random()|0;r++<36;){var n="xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"[r-1],o=15&t;e+="-"==n||"4"==n?n:("x"==n?o:3&o|8).toString(16),t=r%8==0?4294967295*Math.random()|0:t>>4;}return e}

var l$1="global",o$2=j$1+"global"+j$1,n=typeof self===o$1&&self.self===self&&self||typeof global===o$1&&global.global===global&&global||void 0;function a$2(t){return n[o$2][t]}function f$1(t,e){return n[o$2][t]=e}function i$2(t){delete n[o$2][t];}function u$1(t,e,r){var l;try{if(b$2(t)){var o=window[t];l=o[e].bind(o);}}catch(t){}return l||r}n[o$2]||(n[o$2]={});var c$1={};function b$2(t){if(typeof c$1[t]!==e)return c$1[t];try{var e$1=window[t];e$1.setItem(e,e),e$1.removeItem(e);}catch(e){return c$1[t]=false}return c$1[t]=true}

function g$1(){return g$1=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r]);}return e},g$1.apply(this,arguments)}var h$1$1="function",v$1="undefined",y$2="@@redux/"+Math.random().toString(36),b$1=/* #__PURE__ */function(){return typeof Symbol===h$1$1&&Symbol.observable||"@@observable"}(),I$1=" != "+h$1$1;function w$1(e,t,n){var r;if(typeof t===h$1$1&&typeof n===v$1&&(n=t,t=void 0),typeof n!==v$1){if(typeof n!==h$1$1)throw new Error("enhancer"+I$1);return n(w$1)(e,t)}if(typeof e!==h$1$1)throw new Error("reducer"+I$1);var i=e,a=t,o=[],u=o,s=false;function l(){u===o&&(u=o.slice());}function f(){return a}function d(e){if(typeof e!==h$1$1)throw new Error("Listener"+I$1);var t=true;return l(),u.push(e),function(){if(t){t=false,l();var n=u.indexOf(e);u.splice(n,1);}}}function p(e){if(!on(e))throw new Error("Act != obj");if(typeof e.type===v$1)throw new Error("ActType "+v$1);if(s)throw new Error("Dispatch in reducer");try{s=true,a=i(a,e);}finally{s=false;}for(var t=o=u,n=0;n<t.length;n++)(0, t[n])();return e}return p({type:"@@redux/INIT"}),(r={dispatch:p,subscribe:d,getState:f,replaceReducer:function(e){if(typeof e!==h$1$1)throw new Error("next reducer"+I$1);i=e,p({type:"@@redux/INIT"});}})[b$1]=function(){var e,t=d;return (e={subscribe:function(e){if("object"!=typeof e)throw new TypeError("Observer != obj");function n(){e.next&&e.next(f());}return n(),{unsubscribe:t(n)}}})[b$1]=function(){return this},e},r}function E$1(e,t){var n=t&&t.type;return "action "+(n&&n.toString()||"?")+"reducer "+e+" returns "+v$1}function P$1(){var e=[].slice.call(arguments);return 0===e.length?function(e){return e}:1===e.length?e[0]:e.reduce(function(e,t){return function(){return e(t.apply(void 0,[].slice.call(arguments)))}})}function S$1(){var e=arguments;return function(t){return function(n,r,i){var a,o=t(n,r,i),u=o.dispatch,c={getState:o.getState,dispatch:function(e){return u(e)}};return a=[].slice.call(e).map(function(e){return e(c)}),g$1({},o,{dispatch:u=P$1.apply(void 0,a)(o.dispatch)})}}}var N$1=j$1+"anon_id",A$1=j$1+"user_id",_$1=j$1+"user_traits",j$2="userId",k$1="anonymousId",x$1=["bootstrap","params","campaign","initializeStart","initialize","initializeEnd","ready","resetStart","reset","resetEnd","pageStart","page","pageEnd","pageAborted","trackStart","track","trackEnd","trackAborted","identifyStart","identify","identifyEnd","identifyAborted","userIdChanged","registerPlugins","enablePlugin","disablePlugin","online","offline","setItemStart","setItem","setItemEnd","setItemAborted","removeItemStart","removeItem","removeItemEnd","removeItemAborted"],T$1=["name","EVENTS","config","loaded"],z$1=x$1.reduce(function(e,t){return e[t]=t,e},{registerPluginType:function(e){return "registerPlugin:"+e},pluginReadyType:function(e){return "ready:"+e}}),M$2=/^utm_/,q$2=/^an_prop_/,V$2=/^an_trait_/;function C$1(e){var t=e.storage.setItem;return function(n){return function(r){return function(i){if(i.type===z$1.bootstrap){var a=i.params,o=i.user,u=i.persistedUser,c=i.initialUser,s=u.userId===o.userId;u.anonymousId!==o.anonymousId&&t(N$1,o.anonymousId),s||t(A$1,o.userId),c.traits&&t(_$1,g$1({},s&&u.traits?u.traits:{},c.traits));var l=Object.keys(i.params);if(l.length){var f=a.an_uid,d=a.an_event,p=l.reduce(function(e,t){if(t.match(M$2)||t.match(/^(d|g)clid/)){var n=t.replace(M$2,"");e.campaign["campaign"===n?"name":n]=a[t];}return t.match(q$2)&&(e.props[t.replace(q$2,"")]=a[t]),t.match(V$2)&&(e.traits[t.replace(V$2,"")]=a[t]),e},{campaign:{},props:{},traits:{}});n.dispatch(g$1({type:z$1.params,raw:a},p,f?{userId:f}:{})),f&&setTimeout(function(){return e.identify(f,p.traits)},0),d&&setTimeout(function(){return e.track(d,p.props)},0),Object.keys(p.campaign).length&&n.dispatch({type:z$1.campaign,campaign:p.campaign});}}return r(i)}}}}function U$2(e){return function(t,n){if(void 0===t&&(t={}),void 0===n&&(n={}),n.type===z$1.setItemEnd){if(n.key===N$1)return g$1({},t,{anonymousId:n.value});if(n.key===A$1)return g$1({},t,{userId:n.value})}switch(n.type){case z$1.identify:return Object.assign({},t,{userId:n.userId,traits:g$1({},t.traits,n.traits)});case z$1.reset:return [A$1,N$1,_$1].forEach(function(t){e.removeItem(t);}),Object.assign({},t,{userId:null,anonymousId:null,traits:{}});default:return t}}}function R$2(e){return {userId:e.getItem(A$1),anonymousId:e.getItem(N$1),traits:e.getItem(_$1)}}var $$2=function(e){return j$1+"TEMP"+j$1+e};function D$1(t){var n=t.storage,r=n.setItem,a=n.removeItem,o=n.getItem;return function(t){return function(n){return function(u){var c=u.userId,s=u.traits,l=u.options;if(u.type===z$1.reset&&([A$1,_$1,N$1].forEach(function(e){a(e);}),[j$2,k$1,"traits"].forEach(function(e){i$2($$2(e));})),u.type===z$1.identify){o(N$1)||r(N$1,y$1());var f=o(A$1),d=o(_$1)||{};f&&f!==c&&t.dispatch({type:z$1.userIdChanged,old:{userId:f,traits:d},new:{userId:c,traits:s},options:l}),c&&r(A$1,c),s&&r(_$1,g$1({},d,s));}return n(u)}}}}var B$1={};function L$1(e,t){B$1[e]&&W$1(B$1[e])&&(B$1[e](t),delete B$1[e]);}function J$1(e,t,n){return new Promise(function(r,i){return t()?r(e):n<1?i(g$1({},e,{queue:true})):new Promise(function(e){return setTimeout(e,10)}).then(function(a){return J$1(e,t,n-10).then(r,i)})})}function X$1(e){return {abort:e}}var H$2=function(e){var t=e.data,n=e.action,r=e.instance,i=e.state,a=e.allPlugins,o=e.allMatches,u=e.store,s=e.EVENTS;try{var f=i.plugins,d=i.context,p=n.type,m=p.match(W$2),h=t.exact.map(function(e){return e.pluginName});m&&(h=o.during.map(function(e){return e.pluginName}));var v=function(e,t){return function(n,r,i){var a=r.config,o=r.name,u=o+"."+n.type;i&&(u=i.event);var c=n.type.match(W$2)?function(e,t,n,r,i){return function(a,o){var u=r?r.name:e,c=o&&ne$1(o)?o:n;if(r&&(!(c=o&&ne$1(o)?o:[e]).includes(e)||1!==c.length))throw new Error("Method "+t+" can only abort "+e+" plugin. "+JSON.stringify(c)+" input valid");return g$1({},i,{abort:{reason:a,plugins:c,caller:t,_:u}})}}(o,u,t,i,n):function(e,t){return function(){throw new Error(e.type+" action not cancellable. Remove abort in "+t)}}(n,u);return {payload:ae$1(n),instance:e,config:a||{},abort:c}}}(r,h),y=t.exact.reduce(function(e,t){var n=t.pluginName,r=t.methodName,i=false;return r.match(/^initialize/)||r.match(/^reset/)||(i=!f[n].loaded),d.offline&&r.match(/^(page|track|identify)/)&&(i=true),e[""+n]=i,e},{});return Promise.resolve(t.exact.reduce(function(e,i,o){try{var u=i.pluginName;return Promise.resolve(e).then(function(e){function i(){return Promise.resolve(e)}var o=function(){if(t.namespaced&&t.namespaced[u])return Promise.resolve(t.namespaced[u].reduce(function(e,t,n){try{return Promise.resolve(e).then(function(e){return t.method&&W$1(t.method)?(function(e,t){var n=ie$1(e);if(n&&n.name===t){var r=ie$1(n.method);throw new Error([t+" plugin is calling method "+e,"Plugins cant call self","Use "+n.method+" "+(r?"or "+r.method:"")+" in "+t+" plugin insteadof "+e].join("\n"))}}(t.methodName,t.pluginName),Promise.resolve(t.method({payload:e,instance:r,abort:(n=e,i=u,o=t.pluginName,function(e,t){return g$1({},n,{abort:{reason:e,plugins:t||[i],caller:p,from:o||i}})}),config:Q$2(t.pluginName,f,a),plugins:f})).then(function(t){var n=on(t)?t:{};return Promise.resolve(g$1({},e,n))})):e;var n,i,o;})}catch(e){return Promise.reject(e)}},Promise.resolve(n))).then(function(t){e[u]=t;});e[u]=n;}();return o&&o.then?o.then(i):i()})}catch(e){return Promise.reject(e)}},Promise.resolve({}))).then(function(e){return Promise.resolve(t.exact.reduce(function(n,i,o){try{var s=t.exact.length===o+1,l=i.pluginName,d=a[l];return Promise.resolve(n).then(function(t){var n=e[l]?e[l]:{};if(m&&(n=t),ee$1(n,l))return K$1({data:n,method:p,pluginName:l,store:u}),Promise.resolve(t);if(ee$1(t,l))return s&&K$1({data:t,method:p,store:u}),Promise.resolve(t);if(y.hasOwnProperty(l)&&true===y[l])return u.dispatch({type:"queue",plugin:l,payload:n,_:{called:"queue",from:"queueMechanism"}}),Promise.resolve(t);var i=v(e[l],a[l]);return Promise.resolve(d[p]({abort:i.abort,payload:n,instance:r,config:Q$2(l,f,a),plugins:f})).then(function(i){var a=on(i)?i:{},o=g$1({},t,a),s=e[l];if(ee$1(s,l))K$1({data:s,method:p,pluginName:l,store:u});else {var f=p+":"+l;(f.match(/:/g)||[]).length<2&&!p.match(F$1)&&!p.match(G$1)&&r.dispatch(g$1({},m?o:n,{type:f,_:{called:f,from:"submethod"}}));}return Promise.resolve(o)})})}catch(e){return Promise.reject(e)}},Promise.resolve(n))).then(function(e){if(!(p.match(W$2)||p.match(/^registerPlugin/)||p.match(G$1)||p.match(F$1)||p.match(/^params/)||p.match(/^userIdChanged/))){if(s.plugins.includes(p),e._&&e._.originalAction===p)return e;var n=g$1({},e,{_:{originalAction:e.type,called:e.type,from:"engineEnd"}});te$1(e,t.exact.length)&&!p.match(/End$/)&&(n=g$1({},n,{type:e.type+"Aborted"})),u.dispatch(n);}return e})})}catch(e){return Promise.reject(e)}},W$2=/Start$/,F$1=/^bootstrap/,G$1=/^ready/;function K$1(e){var t=e.pluginName,n=e.method+"Aborted"+(t?":"+t:"");e.store.dispatch(g$1({},e.data,{type:n,_:{called:n,from:"abort"}}));}function Q$2(e,t,n){var r=t[e]||n[e];return r&&r.config?r.config:{}}function Y$2(e,t){return t.reduce(function(t,n){return n[e]?t.concat({methodName:e,pluginName:n.name,method:n[e]}):t},[])}function Z$1(e,t){var n=e.replace(W$2,""),r=t?":"+t:"";return [""+e+r,""+n+r,n+"End"+r]}function ee$1(e,t){var n=e.abort;return !!n&&(true===n||re$1(n,t)||n&&re$1(n.plugins,t))}function te$1(e,t){var n=e.abort;if(!n)return false;if(true===n||q$1(n))return true;var r=n.plugins;return ne$1(n)&&n.length===t||ne$1(r)&&r.length===t}function ne$1(e){return Array.isArray(e)}function re$1(e,t){return !(!e||!ne$1(e))&&e.includes(t)}function ie$1(e){var t=e.match(/(.*):(.*)/);return !!t&&{method:t[1],name:t[2]}}function ae$1(e){return Object.keys(e).reduce(function(t,n){return "type"===n||(t[n]=on(e[n])?Object.assign({},e[n]):e[n]),t},{})}function oe$1(e,t,n){var r={};return function(i){return function(a){return function(o){try{var u,s=function(e){return u?e:a(m)},d=o.type,p=o.plugins,m=o;if(o.abort)return Promise.resolve(a(o));if(d===z$1.enablePlugin&&i.dispatch({type:z$1.initializeStart,plugins:p,disabled:[],fromEnable:true,meta:o.meta}),d===z$1.disablePlugin&&setTimeout(function(){return L$1(o.meta.rid,{payload:o})},0),d===z$1.initializeEnd){var h=t(),v=Object.keys(h),y=v.filter(function(e){return p.includes(e)}).map(function(e){return h[e]}),b=[],I=[],w=o.disabled,E=y.map(function(e){var t=e.loaded,n=e.name,a=e.config;return J$1(e,function(){return t({config:a})},1e4).then(function(t){return r[n]||(i.dispatch({type:z$1.pluginReadyType(n),name:n,events:Object.keys(e).filter(function(e){return !T$1.includes(e)})}),r[n]=true),b=b.concat(n),e}).catch(function(e){if(e instanceof Error)throw new Error(e);return I=I.concat(e.name),e})});Promise.all(E).then(function(e){var t={plugins:b,failed:I,disabled:w};setTimeout(function(){v.length===E.length+w.length&&i.dispatch(g$1({},{type:z$1.ready},t));},0);});}var P=function(){if(d!==z$1.bootstrap)return /^ready:([^:]*)$/.test(d)&&setTimeout(function(){return function(e,t,n){var r={},i=t(),a=e.getState(),o=a.plugins,u=a.queue,s=a.user;if(!a.context.offline&&u&&u.actions&&u.actions.length){var f=u.actions.reduce(function(e,t,n){return o[t.plugin].loaded?(e.process.push(t),e.processIndex.push(n)):(e.requeue.push(t),e.requeueIndex.push(n)),e},{processIndex:[],process:[],requeue:[],requeueIndex:[]});if(f.processIndex&&f.processIndex.length){f.processIndex.forEach(function(t){var a=u.actions[t],f=a.plugin,d=a.payload.type,p=i[f][d];if(p&&W$1(p)){var m,h=function(e,t){return void 0===e&&(e={}),void 0===t&&(t={}),[j$2,k$1].reduce(function(n,r){return e.hasOwnProperty(r)&&t[r]&&t[r]!==e[r]&&(n[r]=t[r]),n},e)}(a.payload,s),v=r[h.meta.rid];if(!v&&(m=p({payload:h,config:o[f].config,instance:n,abort:X$1}))&&on(m)&&m.abort)return void(r[h.meta.rid]=true);if(!v){var y=d+":"+f;e.dispatch(g$1({},h,{type:y,_:{called:y,from:"queueDrain"}}));}}});var d=u.actions.filter(function(e,t){return !~f.processIndex.indexOf(t)});u.actions=d;}}}(i,t,e)},0),Promise.resolve(function(e,t,n,r,i){try{var a=W$1(t)?t():t,o=e.type,u=o.replace(W$2,"");if(e._&&e._.called)return Promise.resolve(e);var c=n.getState(),s=(m=a,void 0===(h=c.plugins)&&(h={}),void 0===(v=e.options)&&(v={}),Object.keys(m).filter(function(e){var t=v.plugins||{};return Q$1(t[e])?t[e]:false!==t.all&&(!h[e]||false!==h[e].enabled)}).map(function(e){return m[e]}));o===z$1.initializeStart&&e.fromEnable&&(s=Object.keys(c.plugins).filter(function(t){var n=c.plugins[t];return e.plugins.includes(t)&&!n.initialized}).map(function(e){return a[e]}));var d=s.map(function(e){return e.name}),p=function(e,t,n){var r=Z$1(e).map(function(e){return Y$2(e,t)});return t.reduce(function(n,r){var i=r.name,a=Z$1(e,i).map(function(e){return Y$2(e,t)}),o=a[0],u=a[1],c=a[2];return o.length&&(n.beforeNS[i]=o),u.length&&(n.duringNS[i]=u),c.length&&(n.afterNS[i]=c),n},{before:r[0],beforeNS:{},during:r[1],duringNS:{},after:r[2],afterNS:{}})}(o,s);return Promise.resolve(H$2({action:e,data:{exact:p.before,namespaced:p.beforeNS},state:c,allPlugins:a,allMatches:p,instance:n,store:r,EVENTS:i})).then(function(e){function t(){var t=function(){if(o.match(W$2))return Promise.resolve(H$2({action:g$1({},s,{type:u+"End"}),data:{exact:p.after,namespaced:p.afterNS},state:c,allPlugins:a,allMatches:p,instance:n,store:r,EVENTS:i})).then(function(e){e.meta&&e.meta.hasCallback&&L$1(e.meta.rid,{payload:e});})}();return t&&t.then?t.then(function(){return e}):e}if(te$1(e,d.length))return e;var s,l=function(){if(o!==u)return Promise.resolve(H$2({action:g$1({},e,{type:u}),data:{exact:p.during,namespaced:p.duringNS},state:c,allPlugins:a,allMatches:p,instance:n,store:r,EVENTS:i})).then(function(e){s=e;});s=e;}();return l&&l.then?l.then(t):t()})}catch(e){return Promise.reject(e)}var m,h,v;}(o,t,e,i,n)).then(function(e){return u=1,a(e)})}();return Promise.resolve(P&&P.then?P.then(s):s(P))}catch(e){return Promise.reject(e)}}}}}function ue$1(e){return function(t){return function(t){return function(n){var r=n.type,i=n.key,a=n.value,o=n.options;if(r===z$1.setItem||r===z$1.removeItem){if(n.abort)return t(n);r===z$1.setItem?e.setItem(i,a,o):e.removeItem(i,o);}return t(n)}}}}var ce$1=function(){var e=this;this.before=[],this.after=[],this.addMiddleware=function(t,n){e[n]=e[n].concat(t);},this.removeMiddleware=function(t,n){var r=e[n].findIndex(function(e){return e===t});-1!==r&&(e[n]=[].concat(e[n].slice(0,r),e[n].slice(r+1)));},this.dynamicMiddlewares=function(t){return function(n){return function(r){return function(i){var a={getState:n.getState,dispatch:function(e){return n.dispatch(e)}},o=e[t].map(function(e){return e(a)});return P$1.apply(void 0,o)(r)(i)}}}};};function se$1(e){return function(t,n){ void 0===t&&(t={});var r={};if("initialize:aborted"===n.type)return t;if(/^registerPlugin:([^:]*)$/.test(n.type)){var i=le$1(n.type,"registerPlugin"),a=e()[i];if(!a||!i)return t;var o=n.enabled,u=a.config;return r[i]={enabled:o,initialized:!!o&&Boolean(!a.initialize),loaded:!!o&&Boolean(a.loaded({config:u})),config:u},g$1({},t,r)}if(/^initialize:([^:]*)$/.test(n.type)){var c=le$1(n.type,z$1.initialize),s=e()[c];return s&&c?(r[c]=g$1({},t[c],{initialized:true,loaded:Boolean(s.loaded({config:s.config}))}),g$1({},t,r)):t}if(/^ready:([^:]*)$/.test(n.type))return r[n.name]=g$1({},t[n.name],{loaded:true}),g$1({},t,r);switch(n.type){case z$1.disablePlugin:return g$1({},t,fe$1(n.plugins,false,t));case z$1.enablePlugin:return g$1({},t,fe$1(n.plugins,true,t));default:return t}}}function le$1(e,t){return e.substring(t.length+1,e.length)}function fe$1(e,t,n){return e.reduce(function(e,r){return e[r]=g$1({},n[r],{enabled:t}),e},n)}function de$1(e){try{return JSON.parse(JSON.stringify(e))}catch(e){}return e}var pe$1={last:{},history:[]};function me$1(e,t){ void 0===e&&(e=pe$1);var n=t.options,r=t.meta;if(t.type===z$1.track){var i=de$1(g$1({event:t.event,properties:t.properties},Object.keys(n).length&&{options:n},{meta:r}));return g$1({},e,{last:i,history:e.history.concat(i)})}return e}var ge$1={actions:[]};function he$1(e,t){ void 0===e&&(e=ge$1);var n=t.payload;switch(t.type){case "queue":var r;return r=n&&n.type&&n.type===z$1.identify?[t].concat(e.actions):e.actions.concat(t),g$1({},e,{actions:r});case "dequeue":return [];default:return e}}var ve$1=/#.*$/;function ye$1(e){var t=/(http[s]?:\/\/)?([^\/\s]+\/)(.*)/g.exec(e);return "/"+(t&&t[3]?t[3].split("?")[0].replace(ve$1,""):"")}var be$1,Ie$1=function(e){if(void 0===e&&(e={}),!$$1)return e;var t=document,n=t.title,r=t.referrer,i=window,a=i.location,o=i.innerWidth,u=i.innerHeight,c=a.hash,s=a.search,l=function(e){var t=function(){if($$1)for(var e,t=document.getElementsByTagName("link"),n=0;e=t[n];n++)if("canonical"===e.getAttribute("rel"))return e.getAttribute("href")}();return t?t.match(/\?/)?t:t+e:window.location.href.replace(ve$1,"")}(s),f={title:n,url:l,path:ye$1(l),hash:c,search:s,width:o,height:u};return r&&""!==r&&(f.referrer=r),g$1({},f,e)},we$1={last:{},history:[]};function Ee$1(e,t){ void 0===e&&(e=we$1);var n=t.options;if(t.type===z$1.page){var r=de$1(g$1({properties:t.properties,meta:t.meta},Object.keys(n).length&&{options:n}));return g$1({},e,{last:r,history:e.history.concat(r)})}return e}be$1={};var Pe$1={initialized:false,sessionId:y$1(),app:null,version:null,debug:false,offline:!!$$1&&!navigator.onLine,os:{name:"na"},userAgent:$$1?navigator.userAgent:"node",library:{name:"analytics",version:"0.12.14"},timezone:void 0,locale:void 0,campaign:{},referrer:be$1};function Se$1(e,t){ void 0===e&&(e=Pe$1);var n=e.initialized,r=t.campaign;switch(t.type){case z$1.campaign:return g$1({},e,{campaign:r});case z$1.offline:return g$1({},e,{offline:true});case z$1.online:return g$1({},e,{offline:false});default:return n?e:g$1({},Pe$1,e,{initialized:true})}}var Ne$1=["plugins","reducers","storage"];function Ae$1(){return f$1("analytics",[]),function(e){return function(t,n$1,r){var i=e(t,n$1,r),a=i.dispatch;return Object.assign(i,{dispatch:function(e){return n[o$2].analytics.push(e.action||e),a(e)}})}}}function _e$1(e){return function(){return P$1(P$1.apply(null,arguments),Ae$1())}}function Oe$1(e){return e?rn(e)?e:[e]:[]}function je$1(t,n,r){ void 0===t&&(t={});var i,a,o=y$1();return n&&(B$1[o]=(i=n,a=function(e){for(var t,n=e||Array.prototype.slice.call(arguments),r=0;r<n.length;r++)if(W$1(n[r])){t=n[r];break}return t}(r),function(e){a&&a(e),i(e);})),g$1({},t,{rid:o,ts:(new Date).getTime()},n?{hasCallback:true}:{})}function ke$1(o){ void 0===o&&(o={});var u=o.reducers||{},s$1$1=o.initialUser||{},f$1$1=(o.plugins||[]).reduce(function(e,t){if(W$1(t))return e.middlewares=e.middlewares.concat(t),e;if(t.NAMESPACE&&(t.name=t.NAMESPACE),!t.name)throw new Error("https://lytics.dev/errors/1");t.config||(t.config={});var n=t.EVENTS?Object.keys(t.EVENTS).map(function(e){return t.EVENTS[e]}):[];e.pluginEnabled[t.name]=!(false===t.enabled||false===t.config.enabled),delete t.enabled,t.methods&&(e.methods[t.name]=Object.keys(t.methods).reduce(function(e,n){var r;return e[n]=(r=t.methods[n],function(){for(var e=Array.prototype.slice.call(arguments),t=new Array(r.length),n=0;n<e.length;n++)t[n]=e[n];return t[t.length]=K,r.apply({instance:K},t)}),e},{}),delete t.methods);var r=Object.keys(t).concat(n),i=new Set(e.events.concat(r));if(e.events=Array.from(i),e.pluginsArray=e.pluginsArray.concat(t),e.plugins[t.name])throw new Error(t.name+"AlreadyLoaded");return e.plugins[t.name]=t,e.plugins[t.name].loaded||(e.plugins[t.name].loaded=function(){return true}),e},{plugins:{},pluginEnabled:{},methods:{},pluginsArray:[],middlewares:[],events:[]}),m=o.storage?o.storage:{getItem:a$2,setItem:f$1,removeItem:i$2},b=function(e){return function(t,n,i){return n.getState("user")[t]||(i&&on(i)&&i[t]?i[t]:R$2(e)[t]||a$2($$2(t))||null)}}(m),I=f$1$1.plugins,A=f$1$1.events.filter(function(e){return !T$1.includes(e)}).sort(),_=new Set(A.concat(x$1).filter(function(e){return !T$1.includes(e)})),O=Array.from(_).sort(),M=function(){return I},q=new ce$1,V=q.addMiddleware,B=q.removeMiddleware,L=q.dynamicMiddlewares,J=function(){throw new Error("Abort disabled inListener")},X=s$1(),H=R$2(m),W=g$1({},H,s$1$1,X.an_uid?{userId:X.an_uid}:{},X.an_aid?{anonymousId:X.an_aid}:{});W.anonymousId||(W.anonymousId=y$1());var F=g$1({enable:function(e,t){return new Promise(function(n){le.dispatch({type:z$1.enablePlugin,plugins:Oe$1(e),_:{originalAction:z$1.enablePlugin}},n,[t]);})},disable:function(e,t){return new Promise(function(n){le.dispatch({type:z$1.disablePlugin,plugins:Oe$1(e),_:{originalAction:z$1.disablePlugin}},n,[t]);})}},f$1$1.methods),G=false,K={identify:function(e,t,n,r){try{var i=q$1(e)?e:null,o=on(e)?e:t,u=n||{},s=K.user();f$1($$2(j$2),i);var l=i||o.userId||b(j$2,K,o);return Promise.resolve(new Promise(function(e){le.dispatch(g$1({type:z$1.identifyStart,userId:l,traits:o||{},options:u,anonymousId:s.anonymousId},s.id&&s.id!==i&&{previousId:s.id}),e,[t,n,r]);}))}catch(e){return Promise.reject(e)}},track:function(e,t,n,r){try{var i=on(e)?e.event:e;if(!i||!q$1(i))throw new Error("EventMissing");var a=on(e)?e:t||{},o=on(n)?n:{};return Promise.resolve(new Promise(function(e){le.dispatch({type:z$1.trackStart,event:i,properties:a,options:o,userId:b(j$2,K,t),anonymousId:b(k$1,K,t)},e,[t,n,r]);}))}catch(e){return Promise.reject(e)}},page:function(e,t,n){try{var r=on(e)?e:{},i=on(t)?t:{};return Promise.resolve(new Promise(function(a){le.dispatch({type:z$1.pageStart,properties:Ie$1(r),options:i,userId:b(j$2,K,r),anonymousId:b(k$1,K,r)},a,[e,t,n]);}))}catch(e){return Promise.reject(e)}},user:function(e){if(e===j$2||"id"===e)return b(j$2,K);if(e===k$1||"anonId"===e)return b(k$1,K);var t=K.getState("user");return e?n$2(t,e):t},reset:function(e){return new Promise(function(t){le.dispatch({type:z$1.resetStart},t,e);})},ready:function(e){return G&&e({plugins:F,instance:K}),K.on(z$1.ready,function(t){e(t),G=true;})},on:function(e,t){if(!e||!W$1(t))return false;if(e===z$1.bootstrap)throw new Error(".on disabled for "+e);var n=/Start$|Start:/;if("*"===e){var r=function(e){return function(e){return function(r){return r.type.match(n)&&t({payload:r,instance:K,plugins:I}),e(r)}}},i=function(e){return function(e){return function(r){return r.type.match(n)||t({payload:r,instance:K,plugins:I}),e(r)}}};return V(r,xe$1),V(i,Te$1),function(){B(r,xe$1),B(i,Te$1);}}var a=e.match(n)?xe$1:Te$1,o=function(n){return function(n){return function(r){return r.type===e&&t({payload:r,instance:K,plugins:I,abort:J}),n(r)}}};return V(o,a),function(){return B(o,a)}},once:function(e,t){if(!e||!W$1(t))return false;if(e===z$1.bootstrap)throw new Error(".once disabled for "+e);var n=K.on(e,function(e){t({payload:e.payload,instance:K,plugins:I,abort:J}),n();});return n},getState:function(e){var t=le.getState();return e?n$2(t,e):Object.assign({},t)},dispatch:function(e){var t=q$1(e)?{type:e}:e;if(x$1.includes(t.type))throw new Error("reserved action "+t.type);var n=g$1({},t,{_:g$1({originalAction:t.type},e._||{})});le.dispatch(n);},enablePlugin:F.enable,disablePlugin:F.disable,plugins:F,storage:{getItem:m.getItem,setItem:function(e,t,n){le.dispatch({type:z$1.setItemStart,key:e,value:t,options:n});},removeItem:function(e,t){le.dispatch({type:z$1.removeItemStart,key:e,options:t});}},setAnonymousId:function(e,t){K.storage.setItem(N$1,e,t);},events:{core:x$1,plugins:A}},Q=f$1$1.middlewares.concat([function(e){return function(e){return function(t){return t.meta||(t.meta=je$1()),e(t)}}},L(xe$1),oe$1(K,M,{all:O,plugins:A}),ue$1(m),C$1(K),D$1(K),L(Te$1)]),Y={context:Se$1,user:U$2(m),page:Ee$1,track:me$1,plugins:se$1(M),queue:he$1},Z=P$1,ee=P$1;if($$1&&o.debug){var te=window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__;te&&(Z=te({trace:true,traceLimit:25})),ee=function(){return 0===arguments.length?Ae$1():on(typeof arguments[0])?_e$1():_e$1().apply(null,arguments)};}var ne,re=function(e){return Object.keys(e).reduce(function(t,n){return Ne$1.includes(n)||(t[n]=e[n]),t},{})}(o),ie=f$1$1.pluginsArray.reduce(function(e,t){var n=t.name,r=t.config,i=t.loaded,a=f$1$1.pluginEnabled[n];return e[n]={enabled:a,initialized:!!a&&Boolean(!t.initialize),loaded:Boolean(i({config:r})),config:r},e},{}),ae={context:re,user:W,plugins:ie},le=w$1(function(e){for(var t=Object.keys(e),n={},r=0;r<t.length;r++){var i=t[r];typeof e[i]===h$1$1&&(n[i]=e[i]);}var a,o=Object.keys(n);try{!function(e){Object.keys(e).forEach(function(t){var n=e[t];if(typeof n(void 0,{type:"@@redux/INIT"})===v$1||typeof n(void 0,{type:y$2})===v$1)throw new Error("reducer "+t+" "+v$1)});}(n);}catch(e){a=e;}return function(e,t){if(void 0===e&&(e={}),a)throw a;for(var r=false,i={},u=0;u<o.length;u++){var c=o[u],s=e[c],l=(0, n[c])(s,t);if(typeof l===v$1){var f=E$1(c,t);throw new Error(f)}i[c]=l,r=r||l!==s;}return r?i:e}}(g$1({},Y,u)),ae,ee(Z(S$1.apply(void 0,Q))));le.dispatch=(ne=le.dispatch,function(e,t,n){var r=g$1({},e,{meta:je$1(e.meta,t,Oe$1(n))});return ne.apply(null,[r])});var fe=Object.keys(I);le.dispatch({type:z$1.bootstrap,plugins:fe,config:re,params:X,user:W,initialUser:s$1$1,persistedUser:H});var de=fe.filter(function(e){return f$1$1.pluginEnabled[e]}),pe=fe.filter(function(e){return !f$1$1.pluginEnabled[e]});return le.dispatch({type:z$1.registerPlugins,plugins:fe,enabled:f$1$1.pluginEnabled}),f$1$1.pluginsArray.map(function(e,t){var n=e.bootstrap,r=e.config,i=e.name;n&&W$1(n)&&n({instance:K,config:r,payload:e}),le.dispatch({type:z$1.registerPluginType(i),name:i,enabled:f$1$1.pluginEnabled[i],plugin:e}),f$1$1.pluginsArray.length===t+1&&le.dispatch({type:z$1.initializeStart,plugins:de,disabled:pe});}),K}var xe$1="before",Te$1="after";

var t="cookie",i$1=a$1(),r$1=d$1,c$2=d$1;function u$2(o){return i$1?d$1(o,"",-1):i$2(o)}function a$1(){if(void 0!==i$1)return i$1;var e="cookiecookie";try{d$1(e,e),i$1=-1!==document.cookie.indexOf(e),u$2(e);}catch(e){i$1=false;}return i$1}function d$1(e,t,r,c,u,a){if("undefined"!=typeof window){var d=arguments.length>1;return false===i$1&&(d?f$1(e,t):a$2(e)),d?document.cookie=e+"="+encodeURIComponent(t)+(r?"; expires="+new Date(+new Date+1e3*r).toUTCString()+(c?"; path="+c:"")+(u?"; domain="+u:"")+(a?"; secure":""):""):decodeURIComponent((("; "+document.cookie).split("; "+e+"=")[1]||"").split(";")[0])}}

var r="localStorage",g$2=b$2.bind(null,"localStorage");u$1("localStorage","getItem",a$2);u$1("localStorage","setItem",f$1);u$1("localStorage","removeItem",i$2);

var a="sessionStorage",i=b$2.bind(null,"sessionStorage");u$1("sessionStorage","getItem",a$2);u$1("sessionStorage","setItem",f$1);u$1("sessionStorage","removeItem",i$2);

function I$3(t){var o=t;try{if("true"===(o=JSON.parse(t)))return true;if("false"===o)return false;if(on(o))return o;parseFloat(o)===o&&(o=parseFloat(o));}catch(t){}if(null!==o&&""!==o)return o}var k$2=g$2(),O$1=i(),x$2=a$1();function C$2(o,e){if(o){var r=A$2(e),a=!N$2(r),i=d$2(r)?I$3(localStorage.getItem(o)):void 0;if(a&&!I$2(i))return i;var n=h$2(r)?I$3(r$1(o)):void 0;if(a&&n)return n;var l=E$2(r)?I$3(sessionStorage.getItem(o)):void 0;if(a&&l)return l;var u=a$2(o);return a?u:{localStorage:i,sessionStorage:l,cookie:n,global:u}}}function L$2(r$2,a$1,l$1$1){if(r$2&&!I$2(a$1)){var u={},g=A$2(l$1$1),m=JSON.stringify(a$1),S=!N$2(g);return d$2(g)&&(u[r]=F$2(r,a$1,I$3(localStorage.getItem(r$2))),localStorage.setItem(r$2,m),S)?u[r]:h$2(g)&&(u[t]=F$2(t,a$1,I$3(r$1(r$2))),c$2(r$2,m),S)?u[t]:E$2(g)&&(u[a]=F$2(a,a$1,I$3(sessionStorage.getItem(r$2))),sessionStorage.setItem(r$2,m),S)?u[a]:(u[l$1]=F$2(l$1,a$1,a$2(r$2)),f$1(r$2,a$1),S?u[l$1]:u)}}function b$4(t$1,e){if(t$1){var a$1=A$2(e),s=C$2(t$1,m$1),n={};return !I$2(s.localStorage)&&d$2(a$1)&&(localStorage.removeItem(t$1),n[r]=s.localStorage),!I$2(s.cookie)&&h$2(a$1)&&(u$2(t$1),n[t]=s.cookie),!I$2(s.sessionStorage)&&E$2(a$1)&&(sessionStorage.removeItem(t$1),n[a]=s.sessionStorage),!I$2(s.global)&&G$2(a$1,l$1)&&(i$2(t$1),n[l$1]=s.global),n}}function A$2(t){return t?q$1(t)?t:t.storage:b$3}function d$2(t){return k$2&&G$2(t,r)}function h$2(t$1){return x$2&&G$2(t$1,t)}function E$2(t){return O$1&&G$2(t,a)}function N$2(t){return t===m$1||"all"===t}function G$2(t,o){return t===b$3||t===o||N$2(t)}function F$2(t,o,e){return {location:t,current:o,previous:e}}var J$3={setItem:L$2,getItem:C$2,removeItem:b$4};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function analyticsLib() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultSettings = {
    storage: J$3
  };
  return ke$1(_objectSpread2(_objectSpread2({}, defaultSettings), opts));
}

function findScript(src) {
    const scripts = Array.prototype.slice.call(window.document.querySelectorAll("script"));
    return scripts.find(s => s.src === src);
}
function buildScriptSrc(src, options) {
    let result = src;
    if (!result.startsWith("http")) {
        result = `https://${(options === null || options === void 0 ? void 0 : options.www) ? "www." : ""}${result}`;
    }
    if (options === null || options === void 0 ? void 0 : options.min) {
        result = result + ".min.js";
    }
    else if (options === null || options === void 0 ? void 0 : options.js) {
        result = result + ".js";
    }
    if (options === null || options === void 0 ? void 0 : options.query) {
        result += "?" + options.query;
    }
    return result;
}
function loadScript(src, options) {
    const found = findScript(src);
    if (found !== undefined) {
        const status = found === null || found === void 0 ? void 0 : found.getAttribute("status");
        if (status === "loaded") {
            return Promise.resolve(found);
        }
        if (status === "loading") {
            return new Promise((resolve, reject) => {
                found.addEventListener("load", () => resolve(found));
                found.addEventListener("error", err => reject(err));
            });
        }
    }
    return new Promise((resolve, reject) => {
        var _a, _b;
        const script = window.document.createElement("script");
        script.type = "text/javascript";
        script.src = buildScriptSrc(src, options);
        script.async = true;
        script.setAttribute("status", "loading");
        for (const [k, v] of Object.entries((_a = options === null || options === void 0 ? void 0 : options.attributes) !== null && _a !== void 0 ? _a : {})) {
            script.setAttribute(k, v);
        }
        script.onload = () => {
            script.onerror = script.onload = null;
            script.setAttribute("status", "loaded");
            resolve(script);
        };
        script.onerror = () => {
            script.onerror = script.onload = null;
            script.setAttribute("status", "error");
            reject(new Error(`Failed to load ${src}`));
        };
        const tag = window.document.getElementsByTagName("script")[0];
        (_b = tag.parentElement) === null || _b === void 0 ? void 0 : _b.insertBefore(script, tag);
    });
}

var __awaiter$5 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const tagPlugin = {
    id: "tag",
    handle(config, payload) {
        return __awaiter$5(this, void 0, void 0, function* () {
            if (!applyFilters(payload, config)) {
                return;
            }
            insertTags(config.code, payload);
        });
    },
};
function insertTags(code, event, opts = {}) {
    let tag;
    try {
        tag = JSON.parse(code);
    }
    catch (e) {
        tag = { code, lang: "javascript" };
    }
    const debug = opts.debug || false;
    if (isInBrowser()) {
        if (tag.lang === "javascript") {
            execJs(tag.code, event);
        }
        else {
            const codeHolder = document.createElement("span");
            codeHolder.innerHTML = replaceMacro(tag.code, event);
            document.body.insertAdjacentElement("beforeend", codeHolder);
            const scripts = codeHolder.querySelectorAll("script");
            scripts.forEach(script => {
                const scriptClone = document.createElement("script");
                scriptClone.type = scriptClone.type || "text/javascript";
                if (script.hasAttribute("src")) {
                    scriptClone.src = script.src;
                }
                scriptClone.text = script.text;
                if (debug) {
                    console.log(`[JITSU] Executing script${script.hasAttribute("src") ? ` ${script.src}` : ""}`, scriptClone.text);
                }
                document.head.appendChild(scriptClone);
                document.head.removeChild(scriptClone);
            });
        }
    }
    else {
        if (debug) {
            console.log(`[JITSU] insertTags(): cannot insert tags in non-browser environment`);
        }
    }
}
//This weird code is used to mask eval() usage.
//Although the code can be executed in the browser, some server side bundlers (like Vercel) fails
//the build if a direct reference to eval() is found.
let al = "al";
let ev = "ve".split("").reverse().join("");
const execF = globalThis[ev + al];
function execJs(code, event) {
    const varName = `jitsu_event_${randomId()}`;
    window[varName] = event;
    const iif = `(function(){
      const event = ${varName};
      ${code}
  })()`;
    try {
        execF(iif);
    }
    catch (e) {
        console.error(`[JITSU] Error executing JS code: ${e.message}. Code: `, iif);
    }
    finally {
        delete window[varName];
    }
    return iif;
}
function replaceMacro(code, event) {
    return code.replace(/{{\s*event\s*}}/g, JSON.stringify(event));
}

var __awaiter$4 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const cdn = "cdn.lr-ingest.io/";
const logrocketPlugin = {
    id: "logrocket",
    handle(config, payload) {
        return __awaiter$4(this, void 0, void 0, function* () {
            if (!applyFilters(payload, config)) {
                return;
            }
            initLogrocketIfNeeded(config.appId);
            const action = logRocket => {
                if (payload.type === "identify" && payload.userId) {
                    logRocket.identify(payload.userId, payload.traits || {});
                }
            };
            getLogRocketQueue().push(action);
            if (getLogRocketState() === "loaded") {
                flushLogRocketQueue(window["LogRocket"]);
            }
        });
    },
};
function getLogRocketState() {
    return window["__jitsuLrState"] || "fresh";
}
function setLogRocketState(s) {
    window["__jitsuLrState"] = s;
}
function getLogRocketQueue() {
    return window["__jitsuLrQueue"] || (window["__jitsuLrQueue"] = []);
}
function flushLogRocketQueue(lr) {
    const queue = getLogRocketQueue();
    while (queue.length > 0) {
        const method = queue.shift();
        try {
            const res = method(lr);
            if (res) {
                res.catch(e => console.warn(`Async LogRocket method failed: ${e.message}`, e));
            }
        }
        catch (e) {
            console.warn(`LogRocket method failed: ${e.message}`, e);
        }
    }
}
function initLogrocketIfNeeded(appId) {
    return __awaiter$4(this, void 0, void 0, function* () {
        if (getLogRocketState() !== "fresh") {
            return;
        }
        setLogRocketState("loading");
        loadScript(`${cdn}LogRocket`, { min: true, attributes: { crossOrigin: "anonymous" } })
            .then(() => {
            if (window["LogRocket"]) {
                try {
                    window["LogRocket"].init(appId);
                }
                catch (e) {
                    console.warn(`LogRocket (id=${appId}) init failed: ${e.message}`, e);
                    setLogRocketState("failed");
                }
                setLogRocketState("loaded");
                flushLogRocketQueue(window["LogRocket"]);
            }
        })
            .catch(e => {
            console.warn(`LogRocket (id=${appId}) init failed: ${e.message}`, e);
            setLogRocketState("failed");
        });
    });
}

var __awaiter$3 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function omit(obj, ...keys) {
    return Object.fromEntries(Object.entries(obj).filter(([k]) => !keys.includes(k)));
}
const gtmPlugin = {
    id: "gtm",
    handle(config, payload) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            const debug = !!config.debug;
            if (!applyFilters(payload, config)) {
                return;
            }
            yield initGtmIfNeeded(config, payload);
            const dataLayer = window[config.dataLayerName || "dataLayer"];
            //traits could be in both nodes, context.traits takes precedence
            const traits = Object.assign(Object.assign({}, ((payload === null || payload === void 0 ? void 0 : payload.traits) || {})), (((_a = payload === null || payload === void 0 ? void 0 : payload.context) === null || _a === void 0 ? void 0 : _a.traits) || {}));
            //remove properties that defined separately
            const idsFromTraits = omit(traits, "id", "userId", "user_id", "anonymousId", "userId");
            if (debug) {
                console.debug("GTM plugin will be applied to following payload", payload);
            }
            // See  https://developers.google.com/tag-platform/tag-manager/server-side/common-event-data
            const userData = {
                email_address: traits.email,
            };
            const ids = Object.assign(Object.assign(Object.assign(Object.assign({}, (payload.userId ? { user_id: payload.userId, userId: payload.userId } : {})), (payload.anonymousId ? { anonymousId: payload.anonymousId } : {})), idsFromTraits), { user_data: Object.keys(userData).length > 0 ? userData : undefined });
            if (debug) {
                console.debug("GTM plugin will set following user-related data layer vars", ids);
            }
            const pageProperties = payload.properties || {};
            const pageVariables = {
                page_location: pageProperties.url || ((_c = (_b = payload.context) === null || _b === void 0 ? void 0 : _b.page) === null || _c === void 0 ? void 0 : _c.url),
                page_title: pageProperties.title || ((_e = (_d = payload.context) === null || _d === void 0 ? void 0 : _d.page) === null || _e === void 0 ? void 0 : _e.title),
                page_path: pageProperties.path || ((_g = (_f = payload.context) === null || _f === void 0 ? void 0 : _f.page) === null || _g === void 0 ? void 0 : _g.path),
                page_hash: pageProperties.hash || ((_j = (_h = payload.context) === null || _h === void 0 ? void 0 : _h.page) === null || _j === void 0 ? void 0 : _j.hash),
                page_search: pageProperties.search || ((_l = (_k = payload.context) === null || _k === void 0 ? void 0 : _k.page) === null || _l === void 0 ? void 0 : _l.search),
                page_referrer: (_p = (_o = (_m = payload === null || payload === void 0 ? void 0 : payload.context) === null || _m === void 0 ? void 0 : _m.page) === null || _o === void 0 ? void 0 : _o.referrer) !== null && _p !== void 0 ? _p : "",
            };
            if (debug) {
                console.debug("GTM plugin will set following context (page) related data layer vars", ids);
            }
            const pushToDataLayer = (data) => {
                dataLayer.push(data);
                if (debug) {
                    console.debug("GTM plugin will push following data to dataLayer", data);
                }
            };
            switch (payload.type) {
                case "page":
                    const pageEvent = Object.assign(Object.assign({ event: "page_view" }, pageVariables), ids);
                    pushToDataLayer(pageEvent);
                    break;
                case "track":
                    const { properties: trackProperties } = payload;
                    const trackEvent = Object.assign(Object.assign(Object.assign({ event: payload.event }, pageVariables), trackProperties), ids);
                    pushToDataLayer(trackEvent);
                    break;
                case "identify":
                    const { traits } = payload;
                    const identifyEvent = Object.assign(Object.assign(Object.assign({ event: "identify" }, pageVariables), traits), ids);
                    pushToDataLayer(identifyEvent);
                    break;
            }
            dataLayer.push(function () {
                this.reset();
            });
        });
    },
};
function getGtmState() {
    return window["__jitsuGtmState"] || "fresh";
}
function setGtmState(s) {
    window["__jitsuGtmState"] = s;
}
function initGtmIfNeeded(config, payload) {
    return __awaiter$3(this, void 0, void 0, function* () {
        if (getGtmState() !== "fresh") {
            return;
        }
        setGtmState("loading");
        const dlName = config.dataLayerName || "dataLayer";
        const tagId = config.containerId;
        (function (w, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                user_id: payload.userId,
            });
            w[l].push({
                "gtm.start": new Date().getTime(),
                event: "gtm.js",
            });
            const dl = l != "dataLayer" ? "&l=" + l : "";
            const scriptSrc = "googletagmanager.com/gtm";
            loadScript(scriptSrc, { www: true, js: true, query: "id=" + i + dl })
                .then(() => {
                setGtmState("loaded");
            })
                .catch(e => {
                console.warn(`GTM (containerId=${tagId}) init failed: ${e.message}`, e);
                setGtmState("failed");
            });
        })(window, dlName, tagId);
    });
}

var __awaiter$2 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const urlData = [
    new Uint8Array([109, 111, 99, 46, 114, 101, 103, 97, 110, 97, 109, 103, 97, 116, 101, 108, 103, 111, 111, 103]),
    new Uint8Array([103, 97, 116, 103]),
    new Uint8Array([115, 106]),
];
function byteArrayToString(byteArray) {
    const decoder = new TextDecoder();
    return decoder.decode(byteArray);
}
function buildTagUrl() {
    return urlData
        .map(d => d.reverse())
        .map(byteArrayToString)
        .join("/");
}
const ga4Plugin = {
    id: "ga4-tag",
    handle(config, payload) {
        return __awaiter$2(this, void 0, void 0, function* () {
            var _a, _b;
            if (!applyFilters(payload, config)) {
                return;
            }
            yield initGa4IfNeeded(config, payload);
            const dataLayer = window[config.dataLayerName || "dataLayer"];
            const gtag = function () {
                dataLayer.push(arguments);
            };
            const ids = Object.assign(Object.assign({}, (payload.userId ? { user_id: payload.userId, userId: payload.userId } : {})), (payload.anonymousId ? { anonymousId: payload.anonymousId } : {}));
            if (payload.userId) {
                // @ts-ignore
                gtag("set", { user_id: payload.userId });
            }
            switch (payload.type) {
                case "page":
                    if (config.autoPageView) {
                        console.log("autoPageView");
                        break;
                    }
                    const { properties: pageProperties, context } = payload;
                    const pageEvent = Object.assign({ page_location: pageProperties.url, page_title: pageProperties.title, page_path: pageProperties.path, page_hash: pageProperties.hash, page_search: pageProperties.search, page_referrer: (_b = (_a = context === null || context === void 0 ? void 0 : context.page) === null || _a === void 0 ? void 0 : _a.referrer) !== null && _b !== void 0 ? _b : "" }, ids);
                    // @ts-ignore
                    gtag("event", "page_view", pageEvent);
                    break;
                case "track":
                    const { properties: trackProperties } = payload;
                    const trackEvent = Object.assign(Object.assign({}, trackProperties), ids);
                    // @ts-ignore
                    gtag("event", payload.event, trackEvent);
                    break;
                case "identify":
                    const { traits } = payload;
                    const identifyEvent = Object.assign(Object.assign({}, traits), ids);
                    // @ts-ignore
                    gtag("event", "identify", identifyEvent);
                    break;
            }
        });
    },
};
function getGa4State() {
    return window["__jitsuGa4State"] || "fresh";
}
function setGa4State(s) {
    window["__jitsuGa4State"] = s;
}
function initGa4IfNeeded(config, payload) {
    return __awaiter$2(this, void 0, void 0, function* () {
        if (getGa4State() !== "fresh") {
            return;
        }
        setGa4State("loading");
        const dlName = config.dataLayerName || "dataLayer";
        const dlParam = dlName !== "dataLayer" ? "&l=" + dlName : "";
        // to work with both GA4 and GTM
        const tagId = config.measurementIds;
        window[dlName] = window[dlName] || [];
        const gtag = function () {
            window[dlName].push(arguments);
        };
        // @ts-ignore
        gtag("js", new Date());
        gtag(
        // @ts-ignore
        "config", tagId, Object.assign(Object.assign({}, (payload.userId ? { user_id: payload.userId } : {})), (!config.autoPageView ? { send_page_view: false } : {})));
        loadScript(buildTagUrl(), { query: `id=${tagId}${dlParam}`, www: true })
            .then(() => {
            setGa4State("loaded");
        })
            .catch(e => {
            console.warn(`GA4 (containerId=${config.measurementIds}) init failed: ${e.message}`, e);
            setGa4State("failed");
        });
    });
}

function satisfyFilter(filter, subject) {
    return filter === "*" || filter.toLowerCase().trim() === (subject || "").trim().toLowerCase();
}
function satisfyDomainFilter(filter, subject) {
    if (filter === "*") {
        return true;
    }
    subject = subject || "";
    if (filter.startsWith("*.")) {
        return subject.endsWith(filter.substring(1));
    }
    else {
        return filter === subject;
    }
}
function applyFilters(event, creds) {
    const { hosts = "*", events = "*" } = creds;
    try {
        const eventsArray = Array.isArray(events) ? events : events.split("\n");
        const hostsArray = Array.isArray(hosts) ? hosts : hosts.split("\n");
        return (!!hostsArray.find(hostFilter => { var _a, _b; return satisfyDomainFilter(hostFilter, (_b = (_a = event.context) === null || _a === void 0 ? void 0 : _a.page) === null || _b === void 0 ? void 0 : _b.host); }) &&
            (!!eventsArray.find(eventFilter => satisfyFilter(eventFilter, event.type)) ||
                !!eventsArray.find(eventFilter => satisfyFilter(eventFilter, event.event))));
    }
    catch (e) {
        console.warn(`Failed to apply filters: ${e.message}. Typeof events: ${typeof events}, typeof hosts: ${typeof hosts}. Values`, events, hosts);
        throw new Error(`Failed to apply filters: ${e.message}. Typeof events: ${typeof events}, typeof hosts: ${typeof hosts}`);
    }
}
const internalDestinationPlugins = {
    [tagPlugin.id]: tagPlugin,
    [gtmPlugin.id]: gtmPlugin,
    [ga4Plugin.id]: ga4Plugin,
    [logrocketPlugin.id]: logrocketPlugin,
};

const jitsuVersion = "2.0.0";
const jitsuLibraryName = "@jitsu/js";

const publicSuffixes = "myshopify.com,ac,com.ac,edu.ac,gov.ac,net.ac,mil.ac,org.ac,ad,nom.ad,ae,co.ae,net.ae,org.ae,sch.ae,ac.ae,gov.ae,mil.ae,aero,af,gov.af,com.af,org.af,net.af,edu.af,ag,com.ag,org.ag,net.ag,co.ag,nom.ag,ai,off.ai,com.ai,net.ai,org.ai,al,com.al,edu.al,gov.al,mil.al,net.al,org.al,am,co.am,com.am,commune.am,net.am,org.am,ao,ed.ao,gv.ao,og.ao,co.ao,pb.ao,it.ao,aq,ar,bet.ar,com.ar,coop.ar,edu.ar,gob.ar,gov.ar,int.ar,mil.ar,musica.ar,mutual.ar,net.ar,org.ar,senasa.ar,tur.ar,arpa,e164.arpa,in-addr.arpa,ip6.arpa,iris.arpa,uri.arpa,urn.arpa,as,gov.as,asia,at,ac.at,co.at,gv.at,or.at,sth.ac.at,au,com.au,net.au,org.au,edu.au,gov.au,asn.au,id.au,act.au,nsw.au,nt.au,qld.au,sa.au,tas.au,vic.au,wa.au,aw,com.aw,ax,az,com.az,net.az,int.az,gov.az,org.az,edu.az,info.az,pp.az,mil.az,name.az,pro.az,biz.az,ba,com.ba,edu.ba,gov.ba,mil.ba,net.ba,org.ba,bb,biz.bb,co.bb,com.bb,edu.bb,gov.bb,info.bb,net.bb,org.bb,store.bb,tv.bb,bd,be,ac.be,bf,gov.bf,bg,a.bg,b.bg,c.bg,d.bg,e.bg,f.bg,g.bg,h.bg,i.bg,j.bg,k.bg,l.bg,m.bg,n.bg,o.bg,p.bg,q.bg,r.bg,s.bg,t.bg,u.bg,v.bg,w.bg,x.bg,y.bg,z.bg,0.bg,1.bg,2.bg,3.bg,4.bg,5.bg,6.bg,7.bg,8.bg,9.bg,bh,com.bh,edu.bh,net.bh,org.bh,gov.bh,bi,co.bi,com.bi,edu.bi,or.bi,org.bi,biz,bj,africa.bj,agro.bj,architectes.bj,assur.bj,avocats.bj,co.bj,com.bj,eco.bj,econo.bj,edu.bj,info.bj,loisirs.bj,money.bj,net.bj,org.bj,ote.bj,resto.bj,restaurant.bj,tourism.bj,univ.bj,bm,com.bm,edu.bm,gov.bm,net.bm,org.bm,bn,com.bn,edu.bn,gov.bn,net.bn,org.bn,bo,com.bo,edu.bo,gob.bo,int.bo,org.bo,net.bo,mil.bo,tv.bo,web.bo,br,9guacu.br,abc.br,adm.br,adv.br,agr.br,aju.br,am.br,anani.br,aparecida.br,app.br,arq.br,art.br,ato.br,b.br,barueri.br,belem.br,bhz.br,bib.br,bio.br,blog.br,bmd.br,boavista.br,bsb.br,campinagrande.br,campinas.br,caxias.br,cim.br,cng.br,cnt.br,com.br,contagem.br,coop.br,coz.br,cri.br,cuiaba.br,curitiba.br,def.br,des.br,det.br,dev.br,ecn.br,eco.br,edu.br,emp.br,enf.br,eng.br,esp.br,etc.br,eti.br,far.br,feira.br,flog.br,floripa.br,fm.br,fnd.br,fortal.br,fot.br,foz.br,fst.br,g12.br,geo.br,ggf.br,goiania.br,gov.br,gru.br,imb.br,ind.br,inf.br,jab.br,jampa.br,jdf.br,joinville.br,jor.br,jus.br,leg.br,lel.br,log.br,londrina.br,macapa.br,maceio.br,manaus.br,maringa.br,mat.br,med.br,mil.br,morena.br,mp.br,mus.br,natal.br,net.br,niteroi.br,nom.br,not.br,ntr.br,odo.br,ong.br,org.br,osasco.br,palmas.br,poa.br,ppg.br,pro.br,psc.br,psi.br,pvh.br,qsl.br,radio.br,rec.br,recife.br,rep.br,ribeirao.br,rio.br,riobranco.br,riopreto.br,salvador.br,sampa.br,santamaria.br,santoandre.br,saobernardo.br,saogonca.br,seg.br,sjc.br,slg.br,slz.br,sorocaba.br,srv.br,taxi.br,tc.br,tec.br,teo.br,the.br,tmp.br,trd.br,tur.br,tv.br,udi.br,vet.br,vix.br,vlog.br,wiki.br,zlg.br,bs,com.bs,net.bs,org.bs,edu.bs,gov.bs,bt,com.bt,edu.bt,gov.bt,net.bt,org.bt,bv,bw,co.bw,org.bw,by,gov.by,mil.by,com.by,of.by,bz,com.bz,net.bz,org.bz,edu.bz,gov.bz,ca,ab.ca,bc.ca,mb.ca,nb.ca,nf.ca,nl.ca,ns.ca,nt.ca,nu.ca,on.ca,pe.ca,qc.ca,sk.ca,yk.ca,gc.ca,cat,cc,cd,gov.cd,cf,cg,ch,ci,org.ci,or.ci,com.ci,co.ci,edu.ci,ed.ci,ac.ci,net.ci,go.ci,asso.ci,aÃ©roport.ci,int.ci,presse.ci,md.ci,gouv.ci,ck,cl,co.cl,gob.cl,gov.cl,mil.cl,cm,co.cm,com.cm,gov.cm,net.cm,cn,ac.cn,com.cn,edu.cn,gov.cn,net.cn,org.cn,mil.cn,co,arts.co,com.co,edu.co,firm.co,gov.co,info.co,int.co,mil.co,net.co,nom.co,org.co,rec.co,web.co,com,coop,cr,ac.cr,co.cr,ed.cr,fi.cr,go.cr,or.cr,sa.cr,cu,com.cu,edu.cu,org.cu,net.cu,gov.cu,inf.cu,cv,com.cv,edu.cv,int.cv,nome.cv,org.cv,cw,com.cw,edu.cw,net.cw,org.cw,cx,gov.cx,cy,ac.cy,biz.cy,com.cy,ekloges.cy,gov.cy,ltd.cy,mil.cy,net.cy,org.cy,press.cy,pro.cy,tm.cy,cz,de,dj,dk,dm,com.dm,net.dm,org.dm,edu.dm,gov.dm,do,art.do,com.do,edu.do,gob.do,gov.do,mil.do,net.do,org.do,sld.do,web.do,dz,art.dz,asso.dz,com.dz,edu.dz,gov.dz,org.dz,net.dz,pol.dz,soc.dz,tm.dz,ec,com.ec,info.ec,net.ec,fin.ec,k12.ec,med.ec,pro.ec,org.ec,edu.ec,gov.ec,gob.ec,mil.ec,edu,ee,edu.ee,gov.ee,riik.ee,lib.ee,med.ee,com.ee,pri.ee,aip.ee,org.ee,fie.ee,eg,com.eg,edu.eg,eun.eg,gov.eg,mil.eg,name.eg,net.eg,org.eg,sci.eg,er,es,com.es,nom.es,org.es,gob.es,edu.es,et,com.et,gov.et,org.et,edu.et,biz.et,name.et,info.et,net.et,eu,fi,aland.fi,fj,ac.fj,biz.fj,com.fj,gov.fj,info.fj,mil.fj,name.fj,net.fj,org.fj,pro.fj,fk,com.fm,edu.fm,net.fm,org.fm,fm,fo,fr,asso.fr,com.fr,gouv.fr,nom.fr,prd.fr,tm.fr,aeroport.fr,avocat.fr,avoues.fr,cci.fr,chambagri.fr,chirurgiens-dentistes.fr,experts-comptables.fr,geometre-expert.fr,greta.fr,huissier-justice.fr,medecin.fr,notaires.fr,pharmacien.fr,port.fr,veterinaire.fr,ga,gb,edu.gd,gov.gd,gd,ge,com.ge,edu.ge,gov.ge,org.ge,mil.ge,net.ge,pvt.ge,gf,gg,co.gg,net.gg,org.gg,gh,com.gh,edu.gh,gov.gh,org.gh,mil.gh,gi,com.gi,ltd.gi,gov.gi,mod.gi,edu.gi,org.gi,gl,co.gl,com.gl,edu.gl,net.gl,org.gl,gm,gn,ac.gn,com.gn,edu.gn,gov.gn,org.gn,net.gn,gov,gp,com.gp,net.gp,mobi.gp,edu.gp,org.gp,asso.gp,gq,gr,com.gr,edu.gr,net.gr,org.gr,gov.gr,gs,gt,com.gt,edu.gt,gob.gt,ind.gt,mil.gt,net.gt,org.gt,gu,com.gu,edu.gu,gov.gu,guam.gu,info.gu,net.gu,org.gu,web.gu,gw,gy,co.gy,com.gy,edu.gy,gov.gy,net.gy,org.gy,hk,com.hk,edu.hk,gov.hk,idv.hk,net.hk,org.hk,hm,hn,com.hn,edu.hn,org.hn,net.hn,mil.hn,gob.hn,hr,iz.hr,from.hr,name.hr,com.hr,ht,com.ht,shop.ht,firm.ht,info.ht,adult.ht,net.ht,pro.ht,org.ht,med.ht,art.ht,coop.ht,pol.ht,asso.ht,edu.ht,rel.ht,gouv.ht,perso.ht,hu,co.hu,info.hu,org.hu,priv.hu,sport.hu,tm.hu,2000.hu,agrar.hu,bolt.hu,casino.hu,city.hu,erotica.hu,erotika.hu,film.hu,forum.hu,games.hu,hotel.hu,ingatlan.hu,jogasz.hu,konyvelo.hu,lakas.hu,media.hu,news.hu,reklam.hu,sex.hu,shop.hu,suli.hu,szex.hu,tozsde.hu,utazas.hu,video.hu,id,ac.id,biz.id,co.id,desa.id,go.id,mil.id,my.id,net.id,or.id,ponpes.id,sch.id,web.id,ie,gov.ie,il,ac.il,co.il,gov.il,idf.il,k12.il,muni.il,net.il,org.il,im,ac.im,co.im,com.im,ltd.co.im,net.im,org.im,plc.co.im,tt.im,tv.im,in,5g.in,6g.in,ac.in,ai.in,am.in,bihar.in,biz.in,business.in,ca.in,cn.in,co.in,com.in,coop.in,cs.in,delhi.in,dr.in,edu.in,er.in,firm.in,gen.in,gov.in,gujarat.in,ind.in,info.in,int.in,internet.in,io.in,me.in,mil.in,net.in,nic.in,org.in,pg.in,post.in,pro.in,res.in,travel.in,tv.in,uk.in,up.in,us.in,info,int,eu.int,io,com.io,iq,gov.iq,edu.iq,mil.iq,com.iq,org.iq,net.iq,ir,ac.ir,co.ir,gov.ir,id.ir,net.ir,org.ir,sch.ir,is,net.is,com.is,edu.is,gov.is,org.is,int.is,it,gov.it,edu.it,je,co.je,net.je,org.je,jm,jo,com.jo,org.jo,net.jo,edu.jo,sch.jo,gov.jo,mil.jo,name.jo,jobs,jp,ac.jp,ad.jp,co.jp,ed.jp,go.jp,gr.jp,lg.jp,ne.jp,or.jp,ke,ac.ke,co.ke,go.ke,info.ke,me.ke,mobi.ke,ne.ke,or.ke,sc.ke,kg,org.kg,net.kg,com.kg,edu.kg,gov.kg,mil.kg,kh,ki,edu.ki,biz.ki,net.ki,org.ki,gov.ki,info.ki,com.ki,km,org.km,nom.km,gov.km,prd.km,tm.km,edu.km,mil.km,ass.km,com.km,kn,net.kn,org.kn,edu.kn,gov.kn,kp,com.kp,edu.kp,gov.kp,org.kp,rep.kp,tra.kp,kr,ac.kr,co.kr,es.kr,go.kr,hs.kr,kg.kr,mil.kr,ms.kr,ne.kr,or.kr,pe.kr,re.kr,sc.kr,kw,com.kw,edu.kw,emb.kw,gov.kw,ind.kw,net.kw,org.kw,ky,com.ky,edu.ky,net.ky,org.ky,kz,org.kz,edu.kz,net.kz,gov.kz,mil.kz,com.kz,la,int.la,net.la,info.la,edu.la,gov.la,per.la,com.la,org.la,lb,com.lb,edu.lb,gov.lb,net.lb,org.lb,lc,com.lc,net.lc,co.lc,org.lc,edu.lc,gov.lc,li,lk,gov.lk,sch.lk,net.lk,int.lk,com.lk,org.lk,edu.lk,ngo.lk,soc.lk,web.lk,ltd.lk,assn.lk,grp.lk,hotel.lk,ac.lk,lr,com.lr,edu.lr,gov.lr,org.lr,net.lr,ls,ac.ls,biz.ls,co.ls,edu.ls,gov.ls,info.ls,net.ls,org.ls,sc.ls,lt,gov.lt,lu,lv,com.lv,edu.lv,gov.lv,org.lv,mil.lv,id.lv,net.lv,asn.lv,conf.lv,ly,com.ly,net.ly,gov.ly,plc.ly,edu.ly,sch.ly,med.ly,org.ly,id.ly,ma,co.ma,net.ma,gov.ma,org.ma,ac.ma,press.ma,mc,tm.mc,asso.mc,md,me,co.me,net.me,org.me,edu.me,ac.me,gov.me,its.me,priv.me,mg,org.mg,nom.mg,gov.mg,prd.mg,tm.mg,edu.mg,mil.mg,com.mg,co.mg,mh,mil,mk,com.mk,org.mk,net.mk,edu.mk,gov.mk,inf.mk,name.mk,ml,com.ml,edu.ml,gouv.ml,gov.ml,net.ml,org.ml,presse.ml,mm,mn,gov.mn,edu.mn,org.mn,mo,com.mo,net.mo,org.mo,edu.mo,gov.mo,mobi,mp,mq,mr,gov.mr,ms,com.ms,edu.ms,gov.ms,net.ms,org.ms,mt,com.mt,edu.mt,net.mt,org.mt,mu,com.mu,net.mu,org.mu,gov.mu,ac.mu,co.mu,or.mu,museum,mv,aero.mv,biz.mv,com.mv,coop.mv,edu.mv,gov.mv,info.mv,int.mv,mil.mv,museum.mv,name.mv,net.mv,org.mv,pro.mv,mw,ac.mw,biz.mw,co.mw,com.mw,coop.mw,edu.mw,gov.mw,int.mw,museum.mw,net.mw,org.mw,mx,com.mx,org.mx,gob.mx,edu.mx,net.mx,my,biz.my,com.my,edu.my,gov.my,mil.my,name.my,net.my,org.my,mz,ac.mz,adv.mz,co.mz,edu.mz,gov.mz,mil.mz,net.mz,org.mz,na,info.na,pro.na,name.na,school.na,or.na,dr.na,us.na,mx.na,ca.na,in.na,cc.na,tv.na,ws.na,mobi.na,co.na,com.na,org.na,name,nc,asso.nc,nom.nc,ne,net,nf,com.nf,net.nf,per.nf,rec.nf,web.nf,arts.nf,firm.nf,info.nf,other.nf,store.nf,ng,com.ng,edu.ng,gov.ng,i.ng,mil.ng,mobi.ng,name.ng,net.ng,org.ng,sch.ng,ni,ac.ni,biz.ni,co.ni,com.ni,edu.ni,gob.ni,in.ni,info.ni,int.ni,mil.ni,net.ni,nom.ni,org.ni,web.ni,nl,no,fhs.no,vgs.no,fylkesbibl.no,folkebibl.no,museum.no,idrett.no,priv.no,mil.no,stat.no,dep.no,kommune.no,herad.no,np,nr,biz.nr,info.nr,gov.nr,edu.nr,org.nr,net.nr,com.nr,nu,nz,ac.nz,co.nz,cri.nz,geek.nz,gen.nz,govt.nz,health.nz,iwi.nz,kiwi.nz,maori.nz,mil.nz,mÄori.nz,net.nz,org.nz,parliament.nz,school.nz,om,co.om,com.om,edu.om,gov.om,med.om,museum.om,net.om,org.om,pro.om,onion,org,pa,ac.pa,gob.pa,com.pa,org.pa,sld.pa,edu.pa,net.pa,ing.pa,abo.pa,med.pa,nom.pa,pe,edu.pe,gob.pe,nom.pe,mil.pe,org.pe,com.pe,net.pe,pf,com.pf,org.pf,edu.pf,pg,ph,com.ph,net.ph,org.ph,gov.ph,edu.ph,ngo.ph,mil.ph,i.ph,pk,com.pk,net.pk,edu.pk,org.pk,fam.pk,biz.pk,web.pk,gov.pk,gob.pk,gok.pk,gon.pk,gop.pk,gos.pk,info.pk,pl,com.pl,net.pl,org.pl,aid.pl,agro.pl,atm.pl,auto.pl,biz.pl,edu.pl,gmina.pl,gsm.pl,info.pl,mail.pl,miasta.pl,media.pl,mil.pl,nieruchomosci.pl,nom.pl,pc.pl,powiat.pl,priv.pl,realestate.pl,rel.pl,sex.pl,shop.pl,sklep.pl,sos.pl,szkola.pl,targi.pl,tm.pl,tourism.pl,travel.pl,turystyka.pl,pm,pn,gov.pn,co.pn,org.pn,edu.pn,net.pn,post,pr,com.pr,net.pr,org.pr,gov.pr,edu.pr,isla.pr,pro.pr,biz.pr,info.pr,name.pr,est.pr,prof.pr,ac.pr,pro,aaa.pro,aca.pro,acct.pro,avocat.pro,bar.pro,cpa.pro,eng.pro,jur.pro,law.pro,med.pro,recht.pro,ps,edu.ps,gov.ps,sec.ps,plo.ps,com.ps,org.ps,net.ps,pt,net.pt,gov.pt,org.pt,edu.pt,int.pt,publ.pt,com.pt,nome.pt,pw,co.pw,ne.pw,or.pw,ed.pw,go.pw,belau.pw,py,com.py,coop.py,edu.py,gov.py,mil.py,net.py,org.py,qa,com.qa,edu.qa,gov.qa,mil.qa,name.qa,net.qa,org.qa,sch.qa,re,asso.re,com.re,nom.re,ro,arts.ro,com.ro,firm.ro,info.ro,nom.ro,nt.ro,org.ro,rec.ro,store.ro,tm.ro,www.ro,rs,ac.rs,co.rs,edu.rs,gov.rs,in.rs,org.rs,ru,rw,ac.rw,co.rw,coop.rw,gov.rw,mil.rw,net.rw,org.rw,sa,com.sa,net.sa,org.sa,gov.sa,med.sa,pub.sa,edu.sa,sch.sa,sb,com.sb,edu.sb,gov.sb,net.sb,org.sb,sc,com.sc,gov.sc,net.sc,org.sc,edu.sc,sd,com.sd,net.sd,org.sd,edu.sd,med.sd,tv.sd,gov.sd,info.sd,se,a.se,ac.se,b.se,bd.se,brand.se,c.se,d.se,e.se,f.se,fh.se,fhsk.se,fhv.se,g.se,h.se,i.se,k.se,komforb.se,kommunalforbund.se,komvux.se,l.se,lanbib.se,m.se,n.se,naturbruksgymn.se,o.se,org.se,p.se,parti.se,pp.se,press.se,r.se,s.se,t.se,tm.se,u.se,w.se,x.se,y.se,z.se,sg,com.sg,net.sg,org.sg,gov.sg,edu.sg,per.sg,sh,com.sh,net.sh,gov.sh,org.sh,mil.sh,si,sj,sk,sl,com.sl,net.sl,edu.sl,gov.sl,org.sl,sm,sn,art.sn,com.sn,edu.sn,gouv.sn,org.sn,perso.sn,univ.sn,so,com.so,edu.so,gov.so,me.so,net.so,org.so,sr,ss,biz.ss,com.ss,edu.ss,gov.ss,me.ss,net.ss,org.ss,sch.ss,st,co.st,com.st,consulado.st,edu.st,embaixada.st,mil.st,net.st,org.st,principe.st,saotome.st,store.st,su,sv,com.sv,edu.sv,gob.sv,org.sv,red.sv,sx,gov.sx,sy,edu.sy,gov.sy,net.sy,mil.sy,com.sy,org.sy,sz,co.sz,ac.sz,org.sz,tc,td,tel,tf,tg,th,ac.th,co.th,go.th,in.th,mi.th,net.th,or.th,tj,ac.tj,biz.tj,co.tj,com.tj,edu.tj,go.tj,gov.tj,int.tj,mil.tj,name.tj,net.tj,nic.tj,org.tj,test.tj,web.tj,tk,tl,gov.tl,tm,com.tm,co.tm,org.tm,net.tm,nom.tm,gov.tm,mil.tm,edu.tm,tn,com.tn,ens.tn,fin.tn,gov.tn,ind.tn,info.tn,intl.tn,mincom.tn,nat.tn,net.tn,org.tn,perso.tn,tourism.tn,to,com.to,gov.to,net.to,org.to,edu.to,mil.to,tr,av.tr,bbs.tr,bel.tr,biz.tr,com.tr,dr.tr,edu.tr,gen.tr,gov.tr,info.tr,mil.tr,k12.tr,kep.tr,name.tr,net.tr,org.tr,pol.tr,tel.tr,tsk.tr,tv.tr,web.tr,nc.tr,tt,co.tt,com.tt,org.tt,net.tt,biz.tt,info.tt,pro.tt,int.tt,coop.tt,jobs.tt,mobi.tt,travel.tt,museum.tt,aero.tt,name.tt,gov.tt,edu.tt,tv,tw,edu.tw,gov.tw,mil.tw,com.tw,net.tw,org.tw,idv.tw,game.tw,ebiz.tw,club.tw,tz,ac.tz,co.tz,go.tz,hotel.tz,info.tz,me.tz,mil.tz,mobi.tz,ne.tz,or.tz,sc.tz,tv.tz,ua,com.ua,edu.ua,gov.ua,in.ua,net.ua,org.ua,ug,co.ug,or.ug,ac.ug,sc.ug,go.ug,ne.ug,com.ug,org.ug,uk,ac.uk,co.uk,gov.uk,ltd.uk,me.uk,net.uk,nhs.uk,org.uk,plc.uk,police.uk,us,dni.us,fed.us,isa.us,kids.us,nsn.us,ak.us,al.us,ar.us,as.us,az.us,ca.us,co.us,ct.us,dc.us,de.us,fl.us,ga.us,gu.us,hi.us,ia.us,id.us,il.us,in.us,ks.us,ky.us,la.us,ma.us,md.us,me.us,mi.us,mn.us,mo.us,ms.us,mt.us,nc.us,nd.us,ne.us,nh.us,nj.us,nm.us,nv.us,ny.us,oh.us,ok.us,or.us,pa.us,pr.us,ri.us,sc.us,sd.us,tn.us,tx.us,ut.us,vi.us,vt.us,va.us,wa.us,wi.us,wv.us,wy.us,uy,com.uy,edu.uy,gub.uy,mil.uy,net.uy,org.uy,uz,co.uz,com.uz,net.uz,org.uz,va,vc,com.vc,net.vc,org.vc,gov.vc,mil.vc,edu.vc,ve,arts.ve,bib.ve,co.ve,com.ve,e12.ve,edu.ve,firm.ve,gob.ve,gov.ve,info.ve,int.ve,mil.ve,net.ve,nom.ve,org.ve,rar.ve,rec.ve,store.ve,tec.ve,web.ve,vg,vi,co.vi,com.vi,k12.vi,net.vi,org.vi,vn,ac.vn,ai.vn,biz.vn,com.vn,edu.vn,gov.vn,health.vn,id.vn,info.vn,int.vn,io.vn,name.vn,net.vn,org.vn,pro.vn,vu,com.vu,edu.vu,net.vu,org.vu,wf,ws,com.ws,net.ws,org.ws,gov.ws,edu.ws,yt,ye,com.ye,edu.ye,gov.ye,net.ye,mil.ye,org.ye,ac.za,agric.za,alt.za,co.za,edu.za,gov.za,grondar.za,law.za,mil.za,net.za,ngo.za,nic.za,nis.za,nom.za,org.za,school.za,tm.za,web.za,zm,ac.zm,biz.zm,co.zm,com.zm,edu.zm,gov.zm,info.zm,mil.zm,net.zm,org.zm,sch.zm,zw,ac.zw,co.zw,gov.zw,mil.zw,org.zw".split(",");
//convert to Map
const _publicSuffixesMap = {};
publicSuffixes.forEach(tld => {
    _publicSuffixesMap[tld] = true;
});
const publicSuffixesMap = _publicSuffixesMap;
function getTopLevelDomain(hostname) {
    const [domain] = hostname.split(":");
    const parts = domain.split(".");
    if (parts[parts.length - 1] === "localhost" || parts.length < 2) {
        return parts[parts.length - 1];
    }
    else {
        const d = parts[parts.length - 2] + "." + parts[parts.length - 1];
        if (parts.length > 2 && publicSuffixesMap[d]) {
            return parts[parts.length - 3] + "." + d;
        }
        else {
            return d;
        }
    }
}

class Processor {
    constructor(options) {
        this.selfOptions = options || {};
        this.pipes = {};
    }
    options(options) {
        if (options) {
            this.selfOptions = options;
        }
        return this.selfOptions;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    pipe(name, pipeArg) {
        let pipe = pipeArg;
        if (typeof name === "string") {
            if (typeof pipe === "undefined") {
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                return this.pipes[name];
            }
            else {
                this.pipes[name] = pipe;
            }
        }
        if (name && name.name) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            pipe = name;
            if (pipe.processor === this) {
                return pipe;
            }
            this.pipes[pipe.name] = pipe;
        }
        pipe.processor = this;
        return pipe;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    process(input, pipe) {
        let context = input;
        context.options = this.options();
        let nextPipe = pipe || input.pipe || "default";
        let lastPipe;
        while (nextPipe) {
            if (typeof context.nextAfterChildren !== "undefined") {
                // children processed and coming back to parent
                context.next = context.nextAfterChildren;
                context.nextAfterChildren = null;
            }
            if (typeof nextPipe === "string") {
                nextPipe = this.pipe(nextPipe);
            }
            nextPipe.process(context);
            lastPipe = nextPipe;
            nextPipe = null;
            if (context) {
                if (context.next) {
                    context = context.next;
                    nextPipe = context.pipe || lastPipe;
                }
            }
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return
        return context.hasResult ? context.result : undefined;
    }
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
class Pipe {
    constructor(name) {
        this.name = name;
        this.filters = [];
    }
    process(input) {
        if (!this.processor) {
            throw new Error("add this pipe to a processor before using it");
        }
        const debug = this.debug;
        const length = this.filters.length;
        const context = input;
        for (let index = 0; index < length; index++) {
            const filter = this.filters[index];
            if (debug) {
                this.log(`filter: ${filter.filterName}`);
            }
            filter(context);
            if (typeof context === "object" && context.exiting) {
                context.exiting = false;
                break;
            }
        }
        if (!context.next && this.resultCheck) {
            this.resultCheck(context);
        }
    }
    log(msg) {
        console.log(`[jsondiffpatch] ${this.name} pipe, ${msg}`);
    }
    append(...args) {
        this.filters.push(...args);
        return this;
    }
    prepend(...args) {
        this.filters.unshift(...args);
        return this;
    }
    indexOf(filterName) {
        if (!filterName) {
            throw new Error("a filter name is required");
        }
        for (let index = 0; index < this.filters.length; index++) {
            const filter = this.filters[index];
            if (filter.filterName === filterName) {
                return index;
            }
        }
        throw new Error(`filter not found: ${filterName}`);
    }
    list() {
        return this.filters.map(f => f.filterName);
    }
    after(filterName, ...params) {
        const index = this.indexOf(filterName);
        this.filters.splice(index + 1, 0, ...params);
        return this;
    }
    before(filterName, ...params) {
        const index = this.indexOf(filterName);
        this.filters.splice(index, 0, ...params);
        return this;
    }
    replace(filterName, ...params) {
        const index = this.indexOf(filterName);
        this.filters.splice(index, 1, ...params);
        return this;
    }
    remove(filterName) {
        const index = this.indexOf(filterName);
        this.filters.splice(index, 1);
        return this;
    }
    clear() {
        this.filters.length = 0;
        return this;
    }
    shouldHaveResult(should) {
        if (should === false) {
            this.resultCheck = null;
            return;
        }
        if (this.resultCheck) {
            return;
        }
        this.resultCheck = context => {
            if (!context.hasResult) {
                console.log(context);
                const error = new Error(`${this.name} failed`);
                error.noResult = true;
                throw error;
            }
        };
        return this;
    }
}

class Context {
    setResult(result) {
        this.result = result;
        this.hasResult = true;
        return this;
    }
    exit() {
        this.exiting = true;
        return this;
    }
    push(child, name) {
        child.parent = this;
        if (typeof name !== "undefined") {
            child.childName = name;
        }
        child.root = this.root || this;
        child.options = child.options || this.options;
        if (!this.children) {
            this.children = [child];
            this.nextAfterChildren = this.next || null;
            this.next = child;
        }
        else {
            this.children[this.children.length - 1].next = child;
            this.children.push(child);
        }
        child.next = this;
        return this;
    }
}

class DiffContext extends Context {
    constructor(left, right) {
        super();
        this.left = left;
        this.right = right;
        this.pipe = "diff";
    }
    setResult(result) {
        return super.setResult(result);
    }
}

class PatchContext extends Context {
    constructor(left, delta) {
        super();
        this.left = left;
        this.delta = delta;
        this.pipe = "patch";
    }
}

function arrayEquals(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
const diffFilter$1 = function trivialMatchesDiffFilter(context) {
    if (context.left === context.right) {
        context.setResult(undefined).exit();
        return;
    }
    if (typeof context.left === "undefined") {
        if (typeof context.right === "function") {
            throw new Error("functions are not supported");
        }
        context.setResult([context.right]).exit();
        return;
    }
    if (typeof context.right === "undefined") {
        context.setResult([context.left, 0, 0]).exit();
        return;
    }
    if (typeof context.left === "function" || typeof context.right === "function") {
        throw new Error("functions are not supported");
    }
    context.leftType = context.left === null ? "null" : typeof context.left;
    context.rightType = context.right === null ? "null" : typeof context.right;
    if (context.leftType !== context.rightType) {
        context.setResult([context.left, context.right]).exit();
        return;
    }
    if (context.leftType === "boolean" || context.leftType === "number" || context.leftType === "string") {
        context.setResult([context.left, context.right]).exit();
        return;
    }
    if (context.leftType === "object") {
        context.leftIsArray = Array.isArray(context.left);
    }
    if (context.rightType === "object") {
        context.rightIsArray = Array.isArray(context.right);
    }
    if (context.leftIsArray !== context.rightIsArray) {
        context.setResult([context.left, context.right]).exit();
        return;
    }
    if (context.leftIsArray && context.rightIsArray) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (arrayEquals(context.left, context.right)) {
            context.setResult(undefined).exit();
            return;
        }
        else {
            context.setResult([context.left, context.right]).exit();
            return;
        }
    }
    if (context.left instanceof RegExp) {
        if (context.right instanceof RegExp) {
            context.setResult([context.left.toString(), context.right.toString()]).exit();
        }
        else {
            context.setResult([context.left, context.right]).exit();
        }
    }
};
diffFilter$1.filterName = "trivial";
const patchFilter$1 = function trivialMatchesPatchFilter(context) {
    if (typeof context.delta === "undefined") {
        context.setResult(context.left).exit();
        return;
    }
    context.nested = !Array.isArray(context.delta);
    if (context.nested) {
        return;
    }
    const nonNestedDelta = context.delta;
    if (nonNestedDelta.length === 1) {
        context.setResult(nonNestedDelta[0]).exit();
        return;
    }
    if (nonNestedDelta.length === 2) {
        if (context.left instanceof RegExp) {
            const regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(nonNestedDelta[1]);
            if (regexArgs) {
                context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
                return;
            }
        }
        context.setResult(nonNestedDelta[1]).exit();
        return;
    }
    if (nonNestedDelta.length === 3 && nonNestedDelta[2] === 0) {
        context.setResult(undefined).exit();
    }
};
patchFilter$1.filterName = "trivial";

const collectChildrenDiffFilter = context => {
    if (!context || !context.children) {
        return;
    }
    const length = context.children.length;
    let child;
    let result = context.result;
    for (let index = 0; index < length; index++) {
        child = context.children[index];
        if (typeof child.result === "undefined") {
            continue;
        }
        result = result || {};
        result[child.childName] = child.result;
    }
    if (result && context.leftIsArray) {
        result._t = "a";
    }
    context.setResult(result).exit();
};
collectChildrenDiffFilter.filterName = "collectChildren";
const objectsDiffFilter = context => {
    if (context.leftIsArray || context.leftType !== "object") {
        return;
    }
    const left = context.left;
    const right = context.right;
    let name;
    let child;
    const propertyFilter = context.options.propertyFilter;
    for (name in left) {
        if (!Object.prototype.hasOwnProperty.call(left, name)) {
            continue;
        }
        if (propertyFilter && !propertyFilter(name, context)) {
            continue;
        }
        child = new DiffContext(left[name], right[name]);
        context.push(child, name);
    }
    for (name in right) {
        if (!Object.prototype.hasOwnProperty.call(right, name)) {
            continue;
        }
        if (propertyFilter && !propertyFilter(name, context)) {
            continue;
        }
        if (typeof left[name] === "undefined") {
            child = new DiffContext(undefined, right[name]);
            context.push(child, name);
        }
    }
    if (!context.children || context.children.length === 0) {
        context.setResult(undefined).exit();
        return;
    }
    context.exit();
};
objectsDiffFilter.filterName = "objects";
const patchFilter = function nestedPatchFilter(context) {
    if (!context.nested) {
        return;
    }
    const nestedDelta = context.delta;
    if (nestedDelta._t) {
        return;
    }
    const objectDelta = nestedDelta;
    let name;
    let child;
    for (name in objectDelta) {
        child = new PatchContext(context.left[name], objectDelta[name]);
        context.push(child, name);
    }
    context.exit();
};
patchFilter.filterName = "objects";
const collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
    if (!context || !context.children) {
        return;
    }
    const deltaWithChildren = context.delta;
    if (deltaWithChildren._t) {
        return;
    }
    const object = context.left;
    const length = context.children.length;
    let child;
    for (let index = 0; index < length; index++) {
        child = context.children[index];
        const property = child.childName;
        if (Object.prototype.hasOwnProperty.call(context.left, property) && child.result === undefined) {
            delete object[property];
        }
        else if (object[property] !== child.result) {
            object[property] = child.result;
        }
    }
    context.setResult(object).exit();
};
collectChildrenPatchFilter.filterName = "collectChildren";

const diffFilter = function datesDiffFilter(context) {
    if (context.left instanceof Date) {
        if (context.right instanceof Date) {
            if (context.left.getTime() !== context.right.getTime()) {
                context.setResult([context.left, context.right]);
            }
            else {
                context.setResult(undefined);
            }
        }
        else {
            context.setResult([context.left, context.right]);
        }
        context.exit();
    }
    else if (context.right instanceof Date) {
        context.setResult([context.left, context.right]).exit();
    }
};
diffFilter.filterName = "dates";

class DiffPatcher {
    constructor(options) {
        this.processor = new Processor(options);
        this.processor.pipe(new Pipe("diff")
            .append(collectChildrenDiffFilter, diffFilter$1, diffFilter, objectsDiffFilter)
            .shouldHaveResult());
        this.processor.pipe(new Pipe("patch")
            .append(collectChildrenPatchFilter, patchFilter$1, patchFilter)
            .shouldHaveResult());
    }
    options(options) {
        return this.processor.options(options);
    }
    diff(left, right) {
        return this.processor.process(new DiffContext(left, right));
    }
    patch(left, delta) {
        return this.processor.process(new PatchContext(left, delta));
    }
}

function create(options) {
    return new DiffPatcher(options);
}

/* global analytics */
var __awaiter$1 = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const diff = create();
const defaultConfig = {
    /* Your segment writeKey */
    writeKey: null,
    /* Disable anonymous MTU */
    host: null,
    debug: false,
    fetch: null,
    echoEvents: false,
    cookieDomain: undefined,
    cookieNames: {},
    cookieCapture: {},
    runtime: undefined,
    fetchTimeoutMs: undefined,
    s2s: undefined,
    idEndpoint: undefined,
    errorPolicy: "log",
    defaultPayloadContext: {},
    privacy: {
        dontSend: false,
        disableUserIds: false,
        ipPolicy: "keep",
        consentCategories: undefined,
    },
};
// mergeConfig merges newConfig into currentConfig also making sure that all undefined values are replaced with defaultConfig values
const mergeConfig = (current, newConfig) => {
    for (const key of Object.keys(defaultConfig)) {
        const value = newConfig[key];
        if (key === "privacy") {
            if (typeof value === "object") {
                current.privacy = Object.assign(Object.assign(Object.assign({}, defaultConfig.privacy), current.privacy), value);
            }
            else if (newConfig.hasOwnProperty("privacy") && typeof value === "undefined") {
                // explicitly set to undefined - reset to default
                current.privacy = Object.assign({}, defaultConfig.privacy);
            }
        }
        else if (typeof value === "undefined") {
            if (newConfig.hasOwnProperty(key) || !current.hasOwnProperty(key)) {
                // explicitly set to undefined - reset to default
                // or was not set at all - set to default
                current[key] = defaultConfig[key];
            }
        }
        else {
            current[key] = value;
        }
    }
};
const parseQuery = (qs) => {
    if (!qs) {
        return {};
    }
    let queryString = qs.length > 0 && qs.charAt(0) === "?" ? qs.substring(1) : qs;
    let query = {};
    let pairs = (queryString[0] === "?" ? queryString.substr(1) : queryString).split("&");
    for (let i = 0; i < pairs.length; i++) {
        let pair = pairs[i].split("=");
        query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || "");
    }
    return query;
};
function utmToKey(key) {
    const name = key.substring("utm_".length);
    return name === "campaign" ? "name" : name;
}
function parseUtms(query) {
    return Object.entries(query)
        .filter(([key]) => key.indexOf("utm_") === 0)
        .reduce((acc, [key, value]) => (Object.assign(Object.assign({}, acc), { [utmToKey(key)]: value })), {});
}
function safeCall$1(f, defaultVal) {
    try {
        return f();
    }
    catch (e) {
        return defaultVal;
    }
}
function restoreTraits(storage) {
    let val = storage.getItem("__user_traits");
    if (typeof val === "string") {
        val = safeCall$1(() => JSON.parse(val), {});
    }
    if (typeof val !== "object" || val === null || Array.isArray(val)) {
        val = {};
    }
    let groupVal = storage.getItem("__group_traits");
    if (typeof groupVal === "string") {
        groupVal = safeCall$1(() => JSON.parse(groupVal), {});
    }
    if (typeof groupVal !== "object" || groupVal === null || Array.isArray(groupVal)) {
        groupVal = {};
    }
    return Object.assign(Object.assign({}, (groupVal || {})), (val || {}));
}
function getCookie(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    return parts.length === 2 ? parts.pop().split(";").shift() : undefined;
}
function getClientIds(runtime, customCookieCapture) {
    const cookieCapture = Object.assign({ fbc: "_fbc", fbp: "_fbp" }, customCookieCapture);
    const clientIds = Object.entries(cookieCapture).reduce((acc, [key, cookieName]) => {
        acc[key] = runtime.getCookie(cookieName);
        return acc;
    }, {});
    return Object.assign(Object.assign({}, clientIds), getGa4Ids(runtime));
}
function getGa4Ids(runtime) {
    var _a;
    const allCookies = runtime.getCookies();
    const clientId = (_a = allCookies["_ga"]) === null || _a === void 0 ? void 0 : _a.split(".").slice(-2).join(".");
    const gaSessionCookies = Object.entries(allCookies).filter(([key]) => key.startsWith("_ga_"));
    const sessionIds = gaSessionCookies.length > 0
        ? Object.fromEntries(gaSessionCookies
            .map(([key, value]) => {
            if (typeof value !== "string") {
                return null;
            }
            const parts = value.split(".");
            if (parts.length < 3) {
                return null;
            }
            return [key.substring("_ga_".length), parts[2]];
        })
            .filter(v => v !== null))
        : undefined;
    if (clientId || sessionIds) {
        return { ga4: { clientId, sessionIds } };
    }
    else {
        return undefined;
    }
}
function removeCookie(name, { domain, secure }) {
    document.cookie =
        name +
            "=;domain=" +
            domain +
            ";path=/" +
            ";expires=Thu, 01 Jan 1970 00:00:01 GMT;SameSite=" +
            (secure ? "None" : "Lax") +
            (secure ? ";secure" : "");
}
function setCookie(name, val, { domain, secure }) {
    document.cookie =
        name +
            "=" +
            val +
            ";domain=" +
            domain +
            ";path=/" +
            ";expires=" +
            new Date(new Date().getTime() + 1000 * 60 * 60 * 24 * 365 * 5).toUTCString() +
            ";SameSite=" +
            (secure ? "None" : "Lax") +
            (secure ? ";secure" : "");
}
const defaultCookie2Key = {
    __anon_id: "__eventn_id",
    __user_id: "__eventn_uid",
    __user_traits: "__eventn_id_usr",
    __group_id: "__group_id",
    __group_traits: "__group_traits",
};
const cookieStorage = (cookieDomain, key2cookie) => {
    return {
        setItem(key, val) {
            const cookieName = key2cookie(key) || key;
            if (typeof val === "undefined") {
                removeCookie(cookieName, {
                    domain: cookieDomain,
                    secure: window.location.protocol === "https:",
                });
                return;
            }
            const strVal = typeof val === "object" && val !== null ? encodeURIComponent(JSON.stringify(val)) : val;
            setCookie(cookieName, strVal, {
                domain: cookieDomain,
                secure: window.location.protocol === "https:",
            });
        },
        getItem(key) {
            const cookieName = key2cookie(key) || key;
            const result = getCookie(cookieName);
            if (key === "__anon_id") {
                //anonymous id must always be a string, so we don't parse it to preserve its exact value
                return result;
            }
            if (typeof result === "undefined" && key === "__user_id") {
                //backward compatibility with old jitsu cookie. get user id if from traits
                const traits = parse(getCookie(key2cookie("__user_traits") || "__eventn_id_usr")) || {};
                return traits.internal_id || traits.user_id || traits.id || traits.userId;
            }
            return parse(result);
        },
        removeItem(key) {
            removeCookie(key2cookie(key) || key, {
                domain: cookieDomain,
                secure: window.location.protocol === "https:",
            });
        },
        reset() {
            for (const key of Object.keys(defaultCookie2Key)) {
                removeCookie(key2cookie(key) || key, {
                    domain: cookieDomain,
                    secure: window.location.protocol === "https:",
                });
            }
        },
    };
};
function windowRuntime(opts) {
    const key2Cookie = (key) => {
        var _a, _b, _c, _d, _e;
        switch (key) {
            case "__anon_id":
                return ((_a = opts.cookieNames) === null || _a === void 0 ? void 0 : _a.anonymousId) || defaultCookie2Key.__anon_id;
            case "__user_id":
                return ((_b = opts.cookieNames) === null || _b === void 0 ? void 0 : _b.userId) || defaultCookie2Key.__user_id;
            case "__user_traits":
                return ((_c = opts.cookieNames) === null || _c === void 0 ? void 0 : _c.userTraits) || defaultCookie2Key.__user_traits;
            case "__group_id":
                return ((_d = opts.cookieNames) === null || _d === void 0 ? void 0 : _d.groupId) || defaultCookie2Key.__group_id;
            case "__group_traits":
                return ((_e = opts.cookieNames) === null || _e === void 0 ? void 0 : _e.groupTraits) || defaultCookie2Key.__group_traits;
            default:
                return key;
        }
    };
    return {
        getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            return parts.length === 2 ? parts.pop().split(";").shift() : undefined;
        },
        getCookies() {
            const value = `; ${document.cookie}`;
            const cookies = {};
            const matches = value.matchAll(/(\w+)=([^;]+)/g);
            for (const match of matches) {
                cookies[match[1]] = match[2];
            }
            return cookies;
        },
        documentEncoding() {
            return window.document.characterSet;
        },
        timezoneOffset() {
            return new Date().getTimezoneOffset();
        },
        store() {
            return cookieStorage(opts.cookieDomain || getTopLevelDomain(window.location.hostname), key2Cookie);
        },
        language() {
            return window.navigator.language;
        },
        pageTitle() {
            return window.document.title;
        },
        pageUrl() {
            return window.location.href;
        },
        referrer() {
            return window.document.referrer;
        },
        screen() {
            return {
                width: window.screen.width,
                height: window.screen.height,
                innerWidth: window.innerWidth,
                innerHeight: window.innerHeight,
                density: Math.floor(window.devicePixelRatio),
            };
        },
        userAgent() {
            return window.navigator.userAgent;
        },
    };
}
function createInMemoryStorage(debug) {
    const storage = {};
    return {
        reset() {
            Object.keys(storage).forEach(key => delete storage[key]);
        },
        setItem(key, val) {
            if (debug) {
                console.log(`[JITSU EMPTY RUNTIME] Set storage item ${key}=${JSON.stringify(val)}`);
            }
            if (typeof val === "undefined") {
                delete storage[key];
            }
            else {
                storage[key] = val;
            }
        },
        getItem(key) {
            const val = storage[key];
            if (debug) {
                console.log(`[JITSU EMPTY RUNTIME] Get storage item ${key}=${JSON.stringify(val)}`);
            }
            return val;
        },
        removeItem(key) {
            if (debug) {
                console.log(`[JITSU EMPTY RUNTIME] Get storage item ${key}=${storage[key]}`);
            }
            delete storage[key];
        },
    };
}
const emptyRuntime = (config) => ({
    documentEncoding() {
        return undefined;
    },
    timezoneOffset() {
        return undefined;
    },
    getCookie(name) {
        return undefined;
    },
    getCookies() {
        return {};
    },
    store() {
        return createInMemoryStorage(config.debug);
    },
    language() {
        return undefined;
    },
    pageTitle() {
        return undefined;
    },
    pageUrl() {
        return undefined;
    },
    referrer() {
        return undefined;
    },
    screen() {
        return undefined;
    },
    userAgent() {
        return undefined;
    },
});
function deepMerge(target, source) {
    if (typeof source !== "object" || source === null) {
        return source;
    }
    if (typeof target !== "object" || target === null) {
        return source;
    }
    return Object.entries(source).reduce((acc, [key, value]) => {
        acc[key] = deepMerge(target[key], value);
        return acc;
    }, target);
}
function isInBrowser() {
    return typeof document !== "undefined" && typeof window !== "undefined";
}
/**
 * Fixes a weird bug in analytics URL where path
 * of https://test.com becomes //test.com
 */
function fixPath(path) {
    if (path.indexOf("//") === 0 && path.lastIndexOf("/") === 1) {
        return "/";
    }
    return path;
}
const hashRegex = /#.*$/;
/**
 * for compatibility with path produced by analytics.js
 * @param url
 */
function urlPath(url) {
    const regex = /(http[s]?:\/\/)?([^\/\s]+\/)(.*)/g;
    const matches = regex.exec(url);
    const pathMatch = matches && matches[3] ? matches[3].split("?")[0].replace(hashRegex, "") : "";
    return "/" + pathMatch;
}
function adjustPayload(payload, config, storage, s2s) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
    const runtime = config.runtime || (isInBrowser() ? windowRuntime(config) : emptyRuntime(config));
    const url = runtime.pageUrl();
    const parsedUrl = safeCall$1(() => new URL(url), undefined);
    const query = parsedUrl ? parseQuery(parsedUrl.search) : {};
    const properties = payload.properties || {};
    if (payload.type === "page" && (properties.url || url)) {
        const targetUrl = properties.url || url;
        properties.url = targetUrl.replace(hashRegex, "");
        properties.path = fixPath(urlPath(targetUrl));
    }
    const customContext = deepMerge(config.defaultPayloadContext, ((_a = payload.properties) === null || _a === void 0 ? void 0 : _a.context) || ((_b = payload.options) === null || _b === void 0 ? void 0 : _b.context) || {});
    (_c = payload.properties) === null || _c === void 0 ? true : delete _c.context;
    const referrer = runtime.referrer();
    const context = {
        library: {
            name: jitsuLibraryName,
            version: jitsuVersion,
            env: isInBrowser() ? "browser" : "node",
        },
        consent: ((_d = config.privacy) === null || _d === void 0 ? void 0 : _d.consentCategories)
            ? {
                categoryPreferences: config.privacy.consentCategories,
            }
            : undefined,
        userAgent: (_e = runtime.userAgent) === null || _e === void 0 ? void 0 : _e.call(runtime),
        locale: (_f = runtime.language) === null || _f === void 0 ? void 0 : _f.call(runtime),
        screen: (_g = runtime.screen) === null || _g === void 0 ? void 0 : _g.call(runtime),
        ip: (_h = runtime === null || runtime === void 0 ? void 0 : runtime.ip) === null || _h === void 0 ? void 0 : _h.call(runtime),
        traits: payload.type != "identify" && payload.type != "group"
            ? Object.assign(Object.assign({}, (restoreTraits(storage) || {})), (((_j = payload === null || payload === void 0 ? void 0 : payload.options) === null || _j === void 0 ? void 0 : _j.traits) || {})) : undefined,
        page: {
            path: properties.path || (parsedUrl && parsedUrl.pathname),
            referrer: referrer,
            referring_domain: safeCall$1(() => referrer && new URL(referrer).hostname),
            host: parsedUrl && parsedUrl.host,
            search: properties.search || (parsedUrl && parsedUrl.search),
            title: properties.title || runtime.pageTitle(),
            url: properties.url || url,
            encoding: properties.encoding || runtime.documentEncoding(),
        },
        clientIds: !((_k = config.privacy) === null || _k === void 0 ? void 0 : _k.disableUserIds) ? getClientIds(runtime, config.cookieCapture) : undefined,
        campaign: parseUtms(query),
    };
    const withContext = Object.assign(Object.assign({}, payload), { userId: ((_l = payload === null || payload === void 0 ? void 0 : payload.options) === null || _l === void 0 ? void 0 : _l.userId) || (payload === null || payload === void 0 ? void 0 : payload.userId), anonymousId: ((_m = payload === null || payload === void 0 ? void 0 : payload.options) === null || _m === void 0 ? void 0 : _m.anonymousId) || (payload === null || payload === void 0 ? void 0 : payload.anonymousId), groupId: ((_o = payload === null || payload === void 0 ? void 0 : payload.options) === null || _o === void 0 ? void 0 : _o.groupId) || storage.getItem("__group_id"), timestamp: new Date().toISOString(), sentAt: new Date().toISOString(), messageId: randomId(properties.path || (parsedUrl && parsedUrl.pathname)), writeKey: maskWriteKey(config.writeKey), context: deepMerge(context, customContext) });
    delete withContext.meta;
    delete withContext.options;
    if ((_p = config.privacy) === null || _p === void 0 ? void 0 : _p.disableUserIds) {
        delete withContext.userId;
        delete withContext.anonymousId;
        delete withContext.context.traits;
        delete withContext.groupId;
    }
    return withContext;
}
function isDiff(obj) {
    const keys = Object.keys(obj);
    return keys.length === 1 && keys[0] === "__diff";
}
function processDestinations(destinations, method, originalEvent, debug, analyticsInstance) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const promises = [];
        for (const destination of destinations) {
            let newEvents = [originalEvent];
            if (destination.newEvents) {
                try {
                    newEvents = destination.newEvents.map(e => e === "same" ? originalEvent : isDiff(e) ? diff.patch(originalEvent, e.__diff) : e);
                }
                catch (e) {
                    console.error(`[JITSU] Error applying '${destination.id}' changes to event: ${e === null || e === void 0 ? void 0 : e.message}`, e);
                }
            }
            const credentials = Object.assign(Object.assign({}, destination.credentials), destination.options);
            if (destination.deviceOptions.type === "internal-plugin") {
                const plugin = internalDestinationPlugins[destination.deviceOptions.name];
                if (plugin) {
                    for (const event of newEvents) {
                        try {
                            promises.push(plugin.handle(Object.assign(Object.assign({}, credentials), { debug }), event));
                        }
                        catch (e) {
                            console.warn(`[JITSU] Error processing event with internal plugin '${destination.deviceOptions.name}': ${e === null || e === void 0 ? void 0 : e.message}`, e);
                        }
                    }
                }
                else {
                    console.warn(`[JITSU] Unknown internal plugin '${destination.deviceOptions.name}' for destination '${destination.id}'`);
                }
            }
            else if (destination.deviceOptions.type === "analytics-plugin") {
                yield loadScript(destination.deviceOptions.packageCdn);
                const plugin = window[destination.deviceOptions.moduleVarName];
                if (!plugin) {
                    console.warn(`[JITSU] Broken plugin '${destination.deviceOptions.packageCdn}' for destination '${destination.id}' - it doesn't export '${destination.deviceOptions.moduleVarName}' variable`);
                }
                else {
                    let pluginInstance;
                    try {
                        pluginInstance = (typeof plugin === "function" ? plugin : plugin.init)(credentials);
                    }
                    catch (e) {
                        console.warn(`[JITSU] Error creating plugin '${destination.deviceOptions.moduleVarName}@${destination.deviceOptions.packageCdn}' for destination '${destination.id}': ${e === null || e === void 0 ? void 0 : e.message}`, e);
                    }
                    try {
                        if (debug) {
                            console.log(`[JITSU] Plugin '${destination.deviceOptions.moduleVarName}@${destination.deviceOptions.packageCdn}' for destination '${destination.id}' initialized with config:`, pluginInstance.config);
                        }
                        pluginInstance.initialize({ config: pluginInstance.config, instance: analyticsInstance });
                    }
                    catch (e) {
                        console.warn(`[JITSU] Error initializing plugin '${destination.deviceOptions.moduleVarName}@${destination.deviceOptions.packageCdn}' for destination '${destination.id}': ${e === null || e === void 0 ? void 0 : e.message}. Config: ${JSON.stringify(pluginInstance.config)}`, e);
                        continue;
                    }
                    if (pluginInstance[method]) {
                        for (const event of newEvents) {
                            try {
                                pluginInstance[method]({
                                    payload: event,
                                    config: pluginInstance.config,
                                    instance: analyticsInstance,
                                });
                            }
                            catch (e) {
                                console.warn(`[JITSU] Error processing ${method}() with plugin '${destination.deviceOptions.moduleVarName}@${destination.deviceOptions.packageCdn}' for destination '${destination.id}': ${e === null || e === void 0 ? void 0 : e.message}`, e);
                            }
                        }
                    }
                }
            }
        }
    });
}
function looksLikeCuid(id) {
    return id.length === 25 && id.charAt(0) === "c";
}
function validateWriteKey(writeKey) {
    if (writeKey) {
        const [, secret] = writeKey.split(":", 2);
        if (!secret && !looksLikeCuid(writeKey)) {
            throw new Error(`Legacy write key detected - ${writeKey}! This format doesn't work anymore, it should be 'key:secret'. Please download a new key from Jitsu UI`);
        }
    }
    return writeKey;
}
function maskWriteKey(writeKey) {
    if (writeKey) {
        const [id, secret] = writeKey.split(":", 2);
        if (secret) {
            return `${id}:***`;
        }
        else {
            return "***";
        }
    }
    return writeKey;
}
function getErrorHandler(opts) {
    const configuredHandler = opts.errorPolicy || "log";
    if (typeof configuredHandler === "function") {
        return configuredHandler;
    }
    else if (configuredHandler === "rethrow") {
        return (msg, ...args) => {
            //ignore args, not clear what to do with them
            throw new Error(msg);
        };
    }
    else {
        return (msg, ...args) => {
            console.error(msg, ...args);
        };
    }
}
function send(method, payload, jitsuConfig, instance, store) {
    return __awaiter$1(this, void 0, void 0, function* () {
        var _a, _b;
        const s2s = !!jitsuConfig.s2s;
        const debugHeader = jitsuConfig.debug ? { "X-Enable-Debug": "true" } : {};
        const adjustedPayload = adjustPayload(payload, jitsuConfig, store);
        if (jitsuConfig.echoEvents) {
            console.log(`[JITSU DEBUG] sending '${method}' event:`, adjustedPayload);
            return;
        }
        const url = s2s ? `${jitsuConfig.host}/api/s/s2s/${method}` : `${jitsuConfig.host}/api/s/${method}`;
        const fetch = jitsuConfig.fetch || globalThis.fetch;
        if (!fetch) {
            //don't run it through error handler since error is critical and should be addressed
            throw new Error("Please specify fetch function in jitsu plugin initialization, fetch isn't available in global scope");
        }
        const abortController = jitsuConfig.fetchTimeoutMs ? new AbortController() : undefined;
        const abortTimeout = jitsuConfig.fetchTimeoutMs
            ? setTimeout(() => {
                abortController.abort();
            }, jitsuConfig.fetchTimeoutMs)
            : undefined;
        const authHeader = jitsuConfig.writeKey ? { "X-Write-Key": jitsuConfig.writeKey } : {};
        const ipHeader = typeof ((_a = jitsuConfig.privacy) === null || _a === void 0 ? void 0 : _a.ipPolicy) === "undefined" || ((_b = jitsuConfig.privacy) === null || _b === void 0 ? void 0 : _b.ipPolicy) === "keep"
            ? {}
            : { "X-IP-Policy": jitsuConfig.privacy.ipPolicy };
        let fetchResult;
        try {
            fetchResult = yield fetch(url, {
                method: "POST",
                headers: Object.assign(Object.assign(Object.assign({ "Content-Type": "application/json" }, authHeader), debugHeader), ipHeader),
                body: JSON.stringify(adjustedPayload),
                signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
            });
            if (abortTimeout) {
                clearTimeout(abortTimeout);
            }
        }
        catch (e) {
            getErrorHandler(jitsuConfig)(`Call to ${url} failed with error ${e.message}`);
            return Promise.resolve();
        }
        let responseText;
        try {
            responseText = yield fetchResult.text();
        }
        catch (e) {
            console.warn(`Can't read response text from ${url} (status - ${fetchResult.status}  ${fetchResult.statusText}): ${e === null || e === void 0 ? void 0 : e.message}`);
        }
        if (jitsuConfig.debug) {
            console.log(`[JITSU DEBUG] ${url} replied ${fetchResult.status}: ${responseText}. Original payload:\n${JSON.stringify(adjustedPayload, null, 2)}`);
        }
        if (!fetchResult.ok) {
            getErrorHandler(jitsuConfig)(`Call to ${url} failed with error: ${fetchResult.status} - ${fetchResult.statusText}: ${responseText}`);
            return Promise.resolve();
        }
        let responseJson;
        try {
            responseJson = JSON.parse(responseText);
        }
        catch (e) {
            getErrorHandler(jitsuConfig)(`Can't parse JSON: ${responseText}: ${e === null || e === void 0 ? void 0 : e.message}`);
            return Promise.resolve();
        }
        if (responseJson.destinations && responseJson.destinations.length > 0) {
            if (jitsuConfig.s2s) {
                console.warn(`[JITSU] ${payload.type} responded with list of ${responseJson.destinations.length} destinations. However, this code is running in server-to-server mode, so destinations will be ignored`, jitsuConfig.debug ? JSON.stringify(responseJson.destinations, null, 2) : undefined);
            }
            else {
                //double protection, ingest should not return destinations in s2s mode
                if (isInBrowser()) {
                    if (jitsuConfig.debug) {
                        console.log(`[JITSU] Processing device destinations: `, JSON.stringify(responseJson.destinations, null, 2));
                    }
                    return processDestinations(responseJson.destinations, method, adjustedPayload, !!jitsuConfig.debug, instance);
                }
            }
        }
        return adjustedPayload;
    });
}
const controllingTraits = ["$doNotSend"];
/**
 * Remove all members of traits that controls identify/group behavior (see analytics.d.ts), and should not be recorded. Returns
 * copy of the object with these members removed.
 *
 * Do not modify traits object, but creates one
 * @param traits
 */
function stripControllingTraits(traits) {
    const res = Object.assign({}, traits);
    // see Traits definition in analytics.d.ts. We cannot define const here, so here's a little code duplication
    for (const key of controllingTraits) {
        delete res[key];
    }
    return res;
}
const jitsuAnalyticsPlugin = (jitsuOptions = {}, storage) => {
    // just to make sure that all undefined values are replaced with defaultConfig values
    mergeConfig(jitsuOptions, jitsuOptions);
    return {
        name: "jitsu",
        config: jitsuOptions,
        initialize: (args) => __awaiter$1(void 0, void 0, void 0, function* () {
            const { config } = args;
            if (config.debug) {
                console.debug("[JITSU DEBUG] Initializing Jitsu plugin with config: ", JSON.stringify(config, null, 2));
            }
            if (!config.host && !config.echoEvents) {
                throw new Error("Please specify host variable in jitsu plugin initialization, or set echoEvents to true");
            }
            validateWriteKey(config.writeKey);
            if (config.idEndpoint) {
                if (!isInBrowser()) {
                    console.error(`[JITSU] 'idEndpoint' option can be used only in browser environment`);
                    return;
                }
                try {
                    const fetch = config.fetch || globalThis.fetch;
                    const controller = new AbortController();
                    setTimeout(() => controller.abort(), 1000);
                    const domain = config.cookieDomain || getTopLevelDomain(window.location.hostname);
                    const res = yield fetch(config.idEndpoint + "?domain=" + encodeURIComponent(domain), {
                        credentials: "include",
                        signal: controller.signal,
                    });
                    if (!res.ok) {
                        console.error(`[JITSU] Can't fetch idEndpoint: ${res.status} - ${res.statusText}`);
                    }
                    else if (config.debug) {
                        console.log(`[JITSU DEBUG] Fetch idEndpoint: ${res.status}`);
                    }
                }
                catch (e) {
                    console.error(`[JITSU] Can't fetch idEndpoint: ${e.message}`);
                }
            }
        }),
        page: args => {
            var _a;
            const { payload, config, instance } = args;
            if ((_a = config.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) {
                return;
            }
            return send("page", payload, config, instance, storage);
        },
        track: args => {
            var _a;
            const { payload, config, instance } = args;
            if ((_a = config.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) {
                return;
            }
            return send("track", payload, config, instance, storage);
        },
        identify: args => {
            var _a, _b, _c;
            const { payload, config, instance } = args;
            if (((_a = config.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) || ((_b = config.privacy) === null || _b === void 0 ? void 0 : _b.disableUserIds)) {
                return;
            }
            // Store traits in cache to be able to use them in page and track events that run asynchronously with current identify.
            storage.setItem("__user_id", payload.userId);
            const doNotSend = (_c = payload.traits) === null || _c === void 0 ? void 0 : _c.$doNotSend;
            if (payload.traits && typeof payload.traits === "object") {
                payload.traits = stripControllingTraits(payload.traits);
                storage.setItem("__user_traits", payload.traits);
            }
            if (doNotSend) {
                return Promise.resolve();
            }
            return send("identify", payload, config, instance, storage);
        },
        reset: args => {
            const { config} = args;
            storage.reset();
            if (config.debug) {
                console.log("[JITSU DEBUG] Resetting Jitsu plugin storage");
            }
        },
        methods: {
            //analytics doesn't support group as a base method, so we need to add it manually
            configure(newOptions) {
                var _a, _b, _c, _d;
                const idsWasDisabled = ((_a = jitsuOptions.privacy) === null || _a === void 0 ? void 0 : _a.disableUserIds) || ((_b = jitsuOptions.privacy) === null || _b === void 0 ? void 0 : _b.dontSend);
                mergeConfig(jitsuOptions, newOptions);
                const idsDisabledNow = ((_c = jitsuOptions.privacy) === null || _c === void 0 ? void 0 : _c.disableUserIds) || ((_d = jitsuOptions.privacy) === null || _d === void 0 ? void 0 : _d.dontSend);
                if (!idsDisabledNow && idsWasDisabled) {
                    if (jitsuOptions.debug) {
                        console.log("[JITSU] Enabling Anonymous ID. Generating new Id.");
                    }
                    const instance = this.instance;
                    const newAnonymousId = uuid();
                    const userState = instance.user();
                    if (userState) {
                        userState.anonymousId = newAnonymousId;
                    }
                    storage.setItem("__anon_id", newAnonymousId);
                    instance.setAnonymousId(newAnonymousId);
                }
            },
            group(groupId, traits, options, callback) {
                var _a, _b;
                if (((_a = jitsuOptions.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) || ((_b = jitsuOptions.privacy) === null || _b === void 0 ? void 0 : _b.disableUserIds)) {
                    return;
                }
                if (typeof groupId === "number") {
                    //fix potential issues with group id being used incorrectly
                    groupId = groupId + "";
                }
                const instance = this.instance;
                const user = instance.user();
                const userId = (options === null || options === void 0 ? void 0 : options.userId) || (user === null || user === void 0 ? void 0 : user.userId);
                const anonymousId = (options === null || options === void 0 ? void 0 : options.anonymousId) || (user === null || user === void 0 ? void 0 : user.anonymousId) || storage.getItem("__anon_id");
                storage.setItem("__group_id", groupId);
                const doNotSend = traits === null || traits === void 0 ? void 0 : traits.$doNotSend;
                if (traits && typeof traits === "object") {
                    traits = stripControllingTraits(traits);
                    storage.setItem("__group_traits", traits);
                }
                if (doNotSend) {
                    return Promise.resolve();
                }
                return send("group", Object.assign(Object.assign({ type: "group", groupId, traits }, (anonymousId ? { anonymousId } : {})), (userId ? { userId } : {})), jitsuOptions, instance, storage);
            },
        },
    };
};
let seedCounter = 0;
function getSeed() {
    var _a;
    seedCounter = (seedCounter + 1) % Number.MAX_SAFE_INTEGER;
    const defaultSeed = Date.now() % 2147483647;
    const seed = isInBrowser() ? ((_a = window === null || window === void 0 ? void 0 : window.performance) === null || _a === void 0 ? void 0 : _a.now()) || defaultSeed : defaultSeed;
    return seed + seedCounter;
}
function randomId(hashString = "") {
    const d = Date.now();
    return (((Math.random() * d * hash(hashString !== null && hashString !== void 0 ? hashString : "", getSeed())) % Number.MAX_SAFE_INTEGER).toString(36) +
        ((Math.random() * d * hash(hashString !== null && hashString !== void 0 ? hashString : "", getSeed())) % Number.MAX_SAFE_INTEGER).toString(36));
}
function uuid() {
    var u = "", m = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx", i = 0, rb = (Math.random() * 0xffffffff) | 0;
    while (i++ < 36) {
        var c = m[i - 1], r = rb & 0xf, v = c == "x" ? r : (r & 0x3) | 0x8;
        u += c == "-" || c == "4" ? c : v.toString(16);
        rb = i % 8 == 0 ? (Math.random() * 0xffffffff) | 0 : rb >> 4;
    }
    return u;
}
function hash(str, seed = 0) {
    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
}

var __awaiter = function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function parse(input) {
    let value = input;
    if ((input === null || input === void 0 ? void 0 : input.indexOf("%7B%22")) === 0) {
        value = decodeURIComponent(input);
    }
    try {
        value = JSON.parse(value);
        if (value === "true")
            return true;
        if (value === "false")
            return false;
        if (typeof value === "object")
            return value;
        if (parseFloat(value) === value) {
            value = parseFloat(value);
        }
    }
    catch (e) { }
    if (value === null || value === "") {
        return;
    }
    return value;
}
function createUnderlyingAnalyticsInstance(opts, rt, plugins = []) {
    var _a, _b, _c;
    const storageCache = {};
    // AnalyticsInstance's storage is async somewhere inside. So if we make 'page' call right after 'identify' call
    // 'page' call will load traits from storage before 'identify' call had a change to save them.
    // to avoid that we use in-memory cache for storage
    const cachingStorageWrapper = (persistentStorage) => ({
        setItem(key, val) {
            var _a, _b;
            if (((_a = opts.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) || ((_b = opts.privacy) === null || _b === void 0 ? void 0 : _b.disableUserIds)) {
                return;
            }
            if (opts.debug) {
                console.log(`[JITSU DEBUG] Caching storage setItem: ${key}=${val}`);
            }
            storageCache[key] = val;
            persistentStorage.setItem(key, val);
        },
        getItem(key) {
            var _a, _b;
            if (((_a = opts.privacy) === null || _a === void 0 ? void 0 : _a.dontSend) || ((_b = opts.privacy) === null || _b === void 0 ? void 0 : _b.disableUserIds)) {
                return;
            }
            const value = storageCache[key] || persistentStorage.getItem(key);
            if (opts.debug) {
                console.log(`[JITSU DEBUG] Caching storage getItem: ${key}=${value}. Evicted from cache: ${!storageCache[key]}`);
            }
            return value;
        },
        reset() {
            for (const key of [...Object.keys(storageCache)]) {
                delete storageCache[key];
            }
            persistentStorage.reset();
        },
        removeItem(key) {
            if (opts.debug) {
                console.log(`[JITSU DEBUG] Caching storage removeItem: ${key}`);
            }
            delete storageCache[key];
            persistentStorage.removeItem(key);
        },
    });
    const storage = cachingStorageWrapper(((_a = rt.store) === null || _a === void 0 ? void 0 : _a.call(rt)) || createInMemoryStorage(opts.debug));
    const analytics = analyticsLib({
        debug: !!opts.debug,
        storage,
        plugins: [jitsuAnalyticsPlugin(opts, storage), ...plugins],
    });
    const a = Object.assign(Object.assign({}, analytics), { page: (...args) => {
            if (args.length === 2 && typeof args[0] === "string" && typeof args[1] === "object") {
                return analytics.page(Object.assign({ name: args[0] }, args[1]));
            }
            else {
                return analytics.page(...args);
            }
        }, identify: (...args) => {
            if (args[0] && typeof args[0] !== "object" && typeof args[0] !== "string") {
                //fix the quirk of analytics.js: if you pass number as first argument, it will be converted to string
                args[0] = args[0] + "";
            }
            //analytics.js sets userId and traits asynchronously, so if
            //we want them to be available immediately after identify call in subsequent page() calls,
            //we need to put them into storage manually
            const storage = analytics.storage;
            const storageWrapper = cachingStorageWrapper(storage);
            if (typeof args[0] === "string") {
                //first argument is user id
                storageWrapper.setItem("__user_id", args[0]);
            }
            else if (typeof args[0] === "object") {
                //first argument is traits
                storageWrapper.setItem("__user_traits", args[0]);
            }
            if (args.length === 2 && typeof args[1] === "object") {
                //first argument is user id, second is traits
                storageWrapper.setItem("__user_traits", args[1]);
            }
            return analytics.identify(...args);
        }, setContextProperty(name, value) {
            if (opts.debug) {
                console.log(`[JITSU DEBUG] Setting context property '${name}':${JSON.stringify(value)}`);
            }
            if (!opts.defaultPayloadContext) {
                opts.defaultPayloadContext = {
                    [name]: value,
                };
            }
            else {
                opts.defaultPayloadContext[name] = value;
            }
        },
        getContextProperty(name) {
            var _a;
            if (opts.debug) {
                console.log(`[JITSU DEBUG] Getting context property '${name}'`);
            }
            return (_a = opts.defaultPayloadContext) === null || _a === void 0 ? void 0 : _a[name];
        }, setAnonymousId: (id) => {
            if (opts.debug) {
                console.log("[JITSU DEBUG] Setting anonymous id to " + id);
            }
            //Workaround for analytics.js bug. Underlying setAnonymousId doesn't  set the id immediately,
            //so we got to it manually here. See https://github.com/jitsucom/jitsu/issues/1060
            storage.setItem("__anon_id", id);
            const userState = analytics.user();
            if (userState) {
                userState.anonymousId = id;
            }
            analytics.setAnonymousId(id);
        }, reset() {
            return __awaiter(this, void 0, void 0, function* () {
                if (opts.debug) {
                    console.log("[JITSU DEBUG] Called reset(). Storage state", JSON.stringify(analytics.user()));
                }
                storage.reset();
                yield analytics.reset();
                this.setAnonymousId(uuid());
                if (opts.debug) {
                    console.log("[JITSU DEBUG] User state after reset", JSON.stringify(analytics.user()));
                }
            });
        },
        configure(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b;
                if (opts.debug) {
                    console.log("[JITSU DEBUG] Update Jitsu config with", JSON.stringify(options));
                }
                if (((_a = options.privacy) === null || _a === void 0 ? void 0 : _a.disableUserIds) || ((_b = options.privacy) === null || _b === void 0 ? void 0 : _b.dontSend)) {
                    storage.reset();
                }
                for (const plugin of Object.values(analytics.plugins)) {
                    if (typeof plugin["configure"] === "function") {
                        plugin["configure"](options);
                    }
                }
            });
        },
        group(groupId, traits, options, callback) {
            return __awaiter(this, void 0, void 0, function* () {
                const results = [];
                for (const plugin of Object.values(analytics.plugins)) {
                    if (plugin["group"]) {
                        results.push(yield plugin["group"](groupId, traits, options, callback));
                    }
                }
                //It's incorrect at many levels. First, it's not a dispatched event. Second, we take a first result
                //However, since returned values are used for debugging purposes only, it's ok
                return results[0];
            });
        } });
    if (((_b = opts.privacy) === null || _b === void 0 ? void 0 : _b.disableUserIds) || ((_c = opts.privacy) === null || _c === void 0 ? void 0 : _c.dontSend)) {
        storage.reset();
    }
    return a;
}
/**
 * Fix common mistakes in jitsu configuration
 * @param opts
 */
function fixOptions(opts) {
    var _a, _b;
    return Object.assign(Object.assign({}, opts), { host: ((_a = opts.host) !== null && _a !== void 0 ? _a : "").indexOf("https://") !== 0 && ((_b = opts.host) !== null && _b !== void 0 ? _b : "").indexOf("http://") !== 0
            ? `https://${opts.host}`
            : opts.host });
}
function jitsuAnalytics(_opts) {
    const opts = fixOptions(_opts);
    const inBrowser = isInBrowser();
    const rt = opts.runtime || (inBrowser ? windowRuntime(opts) : emptyRuntime(opts));
    return createUnderlyingAnalyticsInstance(opts, rt);
    // if (inBrowser) {
    //   const fetch = opts.fetch || globalThis.fetch;
    //   if (!fetch) {
    //     throw new Error(
    //       "Please specify fetch function in jitsu plugin initialization, fetch isn't available in global scope"
    //     );
    //   }
    //   const url = `${opts.host}/api/s/cfg`;
    //   const authHeader = {};
    //   const debugHeader = opts.debug ? { "X-Enable-Debug": "true" } : {};
    //   fetch(url)
    //     .then(res => res.json())
    //     .then(res => {
    //       result.loaded(createUnderlyingAnalyticsInstance(opts, rt, []));
    //     })
    //     .catch(e => {
    //       console.warn(`[JITSU] error getting device-destinations from ${url}`, e);
    //       result.loaded(createUnderlyingAnalyticsInstance(opts, rt));
    //     });
    // } else {
    //   result.loaded(createUnderlyingAnalyticsInstance(opts, rt));
    // }
}

var o=function(e,t,a){return alert(e)},s=function(e,t){return o(e,l.error,t)},l={error:"error",success:"success",info:"info"},c={fire:function(e,t,a){return o(e,t,a)},setNotifier:function(e){o=e,salla.event.emit("twilight::notifier.changed");},error:s,success:function(e,t){return o(e,l.success,t)},info:function(e,t){return o(e,l.info,t)},sallaInitiated:function(){var e=window.location.href.match(/([\?\&]danger=)[^&]+/g);e&&(window.history.replaceState(null,document.title,window.location.pathname),salla.event.once("twilight::notifier.changed",(function(){e.forEach((function(e){e=decodeURI(e.replace("?danger=","").replace("&danger=",""));var t=document.createElement("div");t.innerText=e,s(t.innerHTML),salla.event.emit("twilight::error",e);}));})));},types:l},u=function(e,t){return this.api=e,this.event=t,new Proxy(this,{get:function(a,n){return "event"===n?t:"api"===n?e:e&&e[n]||a[n]}})};function d(e,t){(null==t||t>e.length)&&(t=e.length);for(var a=0,n=Array(t);a<t;a++)n[a]=e[a];return n}function p(e,t,a){if(v())return Reflect.construct.apply(null,arguments);var n=[null];return n.push.apply(n,t),new(e.bind.apply(e,n))}function h$1(e,t){var a="undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(a)return (a=a.call(e)).next.bind(a);if(Array.isArray(e)||(a=function(e,t){if(e){if("string"==typeof e)return d(e,t);var a={}.toString.call(e).slice(8,-1);return "Object"===a&&e.constructor&&(a=e.constructor.name),"Map"===a||"Set"===a?Array.from(e):"Arguments"===a||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)?d(e,t):void 0}}(e))||t){a&&(e=a);var n=0;return function(){return n>=e.length?{done:true}:{done:false,value:e[n++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function f(){return f=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var a=arguments[t];for(var n in a)({}).hasOwnProperty.call(a,n)&&(e[n]=a[n]);}return e},f.apply(null,arguments)}function g(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,m(e,t);}function v(){try{var e=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})));}catch(e){}return (v=function(){return !!e})()}function m(e,t){return m=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(e,t){return e.__proto__=t,e},m(e,t)}Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector),Element.prototype.closest||(Element.prototype.closest=function(e){for(var t=this;t;){if(t.matches(e))return t;t=t.parentElement;}}),Element.prototype.getElementSallaData=function(e){if(this.getAttribute){if(this.hasAttribute("data-json"))try{return JSON.parse(this.getAttribute("data-json"))}catch(e){}var t=this.getAttribute("data-function");if(t&&window[t]){if("function"==typeof window[t]){for(var a,n=arguments.length,r=new Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];return this.getFilteredData((a=window[t]).call.apply(a,[this].concat(r)))}return this.getFilteredData(window[t])}var o=this.hasAttribute("data-form-selector")?document.querySelector(this.dataset.formSelector):void 0;if((o="FORM"===this.tagName?this:o||this.closest("form")||this.closest("[salla-form-data]")||this)&&"FORM"===o.tagName)return this.getFilteredData(new FormData(o),null,o);var s=o.querySelectorAll("[name]");if(!s.length)return this.getFilteredData();var l=Object.assign({},this.dataset);return s.forEach((function(e){if(!["checkbox","radio"].includes(e.type)||e.checked)try{var t=Salla.helpers.inputData(e.name,e.value,l);l[t.name]=t.value;}catch(t){Salla.log(e.name+" can't be send");}})),this.getFilteredData(l)}},Element.prototype.canEventFireHook=function(e){return !!this.hasAttribute&&this.hasAttribute(Salla.api.hooksPrefix+e.type)},Element.prototype.hasAttributeStartsWith=function(e,t){e=e.toLowerCase();for(var a=0;a<this.attributes.length;a++){var n=this.attributes[a].name.toLowerCase();if(0===n.indexOf(e))return !t||n}return  false},HTMLFormElement.prototype.getAjaxFormData=function(e){var t=this.querySelectorAll('input[type="file"]');t.forEach((function(e){e.files.length||e.setAttribute("disabled","");}));var a=new FormData(this);return t.forEach((function(e){e.files.length||e.removeAttribute("disabled");})),{formData:this.getFilteredData(a,e),url:this.getAttribute("action"),method:this.getAttribute("method")||"post",events:{success:this.dataset.onSuccess,fail:this.dataset.onFail}}},Element.prototype.getFilteredData=function(e,t,a){var n,r=this;return void 0===e&&(e=null),void 0===t&&(t=null),void 0===a&&(a=null),e=e||(null==(n=a)?void 0:n.dataset)||this.dataset,a&&this.name&&void 0!==this.value&&(e=function(e,t,a){e instanceof FormData?e.append(t,a):e[t]=a;return e}(e,this.name,this.value)),["filterBeforeSubmit","filterBeforeSend"].forEach((function(n){var i,o=(null==(i=a)?void 0:i.dataset[n])||r.dataset[n];if(o){var s=window[o];if("function"==typeof s){if(!s(e,a||r,t)&&e)throw "Data failed to be pass verify function window."+o+"(formData, element, event)!";return s(e,a||r,t)}Salla.log("window."+o+"() not found!");}})),e},HTMLAnchorElement.prototype.getAjaxFormData=function(e){return {formData:this.getFilteredData(null,e),url:this.getAttribute("href"),method:this.dataset.type||"get",events:{success:this.dataset.onSuccess,fail:this.dataset.onFail}}};var y=function(){function e(){this.events={},this.namespace="";var e=/function (.{1,})\(/.exec(this.constructor.toString());this.className=(e&&e.length>1?e[1]:"").toLowerCase();}var t=e.prototype;return t.after_init=function(){this.createDynamicFunctions();},t.createDynamicFunctions=function(){var e=this;Object.keys(this.events).forEach((function(t){e.createDynamicEventFuns(t),e.createDynamicListenerFuns(t);}));},t.createDynamicEventFuns=function(e){if(!this[e]){var t=this;this[e]=function(){for(var a=arguments.length,n=new Array(a),r=0;r<a;r++)n[r]=arguments[r];return t.dispatch.apply(t,[e].concat(n))};}},t.createDynamicListenerFuns=function(e){var t="on"+e.charAt(0).toUpperCase()+e.slice(1);if(!this[t]){var a=this;this[t]=function(t){return a.on(e,(async function(){return t.apply(void 0,arguments)}))};}},t.getEventName=function(e){return e=this.events[e]||e||"unknown-event",!this.namespace||e.includes("::")?e:this.namespace+Salla.event.delimiter+e},t.dispatch=function(e){for(var t,a=arguments.length,n=new Array(a>1?a-1:0),r=1;r<a;r++)n[r-1]=arguments[r];return (t=Salla.event).emitAsync.apply(t,[this.getEventName(e)].concat(n))},t.on=function(e,t,a){return void 0===a&&(a={}),Salla.event.addListener(this.getEventName(e),t,a)},t.once=function(e,t){return Salla.event.once(this.getEventName(e),t)},e}(),w=function(e){function t(){var t;return (t=e.call(this)||this).namespace="auth",t.events={login:"login",logout:"logout",codeSent:"code.sent",codeNotSent:"code.not-sent",verified:"verified",verificationFailed:"verification.failed",loggedIn:"logged.in",registered:"registered",registrationFailed:"registration.failed",loggedOut:"logged.out",failedLogout:"failed.logout",refreshFailed:"refresh.failed",tokenFetched:"token.fetched",tokenInvalid:"token.invalid"},t.after_init(),t}g(t,e);var a=t.prototype;return a.login=function(e){return e?(e.type&&this.setTypeActionOnVerified(e.type),this.next_event=e.next_event||null,this.dispatch.apply(this,["login"].concat(Array.prototype.slice.call(arguments)))):(this.next_event=null,this.dispatch.apply(this,["login"].concat(Array.prototype.slice.call(arguments))))},a.loggedIn=async function(e){var t=this;return Salla.profile.info().finally((function(){return t.dispatch("loggedIn",e)}))},a.setTypeActionOnVerified=function(e){this.type_action_on_verified=e;},a.getTypeActionOnVerified=function(){return this.type_action_on_verified||"redirect"},t}(y),S=function(e){function t(){var t;return (t=e.call(this)||this).namespace="cart",t.events={latestFetched:"latest.fetched",latestFailed:"latest.failed",updated:"updated",itemUpdated:"item.updated",itemUpdatedFailed:"item.updated.failed",itemAdded:"item.added",beforeAddItem:"before.add.item",itemAddedFailed:"item.added.failed",itemDeleted:"item.deleted",itemDeletedFailed:"item.deleted.failed",submitted:"submitted",submitFailed:"submit.failed",imageDeleted:"image.deleted",imageNotDeleted:"image.not.deleted",detailsFetched:"details.fetched",detailsNotFetched:"details.not.fetched",successReset:"success.reset",priceQuoteSucceeded:"price-quote.succeeded",priceQuoteFailed:"price-quote.failed",offersFetched:"offers.fetched",offersFailed:"offers.failed",couponAdded:"coupon.added",couponDeleted:"coupon.deleted",couponAdditionFailed:"coupon.addition.failed",couponDeletionFailed:"coupon.deletion.failed",quickOrderSettingFetched:"quick-order.fetched",quickOrderSettingFailed:"quick-order.failed",quickOrderSucceeded:"quick-order.succeeded",quickOrderFailed:"quick-order.failed",beforeStartFastCheckout:"before.start.fast-checkout",submitting:"submitting"},t.after_init(),t}g(t,e);var a=t.prototype;return a.updated=function(e){var t;return Salla.cookie.set("fresh_summary",1),e&&"object"==typeof e?(e.offer&&salla.product.event.offerExisted(e.offer),e.redirect&&(salla.log("The current cart is purchased!"),salla.cart.api.reset()),e.cart?(salla.storage.set("cart.summary",{total:e.cart.total,sub_total:e.cart.sub_total,discount:e.cart.discount,tax_amount:e.cart.tax_amount,total_discount:e.cart.total_discount,real_shipping_cost:e.cart.real_shipping_cost,count:e.cart.count,shipping_cost:null!=(t=e.cart.free_shipping_bar)&&t.has_free_shipping?0:e.cart.real_shipping_cost}),this.dispatch("updated",e.cart)):void salla.log("Failed to get the cart summary!")):(Salla.logger.info("Cart summary not an object!",e),this.dispatch("updated"))},a.latestFetched=function(e){return this.updated(e.data),this.dispatch("latestFetched",e)},a.itemAdded=function(e,t){return this.updated(e.data),this.dispatch("itemAdded",e,t)},a.itemDeleted=function(e,t){return this.updated(e.data),this.dispatch("itemDeleted",e,t)},a.itemUpdated=function(e,t){return this.updated(e.data),this.dispatch("itemUpdated",e,t)},a.couponAdded=function(e,t){return this.updated(e.data),this.dispatch("couponAdded",e,t)},a.couponDeleted=function(e,t){return this.updated(e.data),this.dispatch("couponDeleted",e,t)},t}(y),b=function(e){function t(){var t;return (t=e.call(this)||this).namespace="order",t.events={canceled:"canceled",notCanceled:"not.canceled",orderCreated:"order.created",orderCreationFailed:"order.creation.failed",invoiceSent:"invoice.sent",invoiceNotSent:"invoice.not.sent",ordersFetched:"order.fetched",ordersNotFetched:"order.not.fetched"},t.after_init(),t}return g(t,e),t}(y),_=function(e){function t(){var t;return (t=e.call(this)||this).namespace="scope",t.events={fetched:"fetched",notFetched:"not.fetched",productAvailabilityFetched:"product-availability.fetched",productAvailabilityNotFetched:"product-availability.not.fetched",changeSucceeded:"changed",changeFailed:"not.changed"},t.after_init(),t}return g(t,e),t}(y),F=function(e){function t(){var t;return (t=e.call(this)||this).namespace="rating",t.events={orderNotFetched:"order.not.fetched",orderFetched:"order.fetched",storeRated:"store.rated",storeFailed:"store.failed",productsRated:"products.rated",productsFailed:"products.failed",shippingRated:"shipping.rated",shippingFailed:"shipping.failed"},t.after_init(),t}return g(t,e),t}(y),k=function(e){function t(){var t;return (t=e.call(this)||this).namespace="comment",t.events={added:"added",additionFailed:"addition.failed",fetched:"fetched",fetchFailed:"fetch.failed"},t.after_init(),t}return g(t,e),t}(y),C=function(e){function t(){var t;return (t=e.call(this)||this).namespace="loyalty",t.events={exchangeSucceeded:"exchange.succeeded",exchangeFailed:"exchange.failed",programFetched:"program.fetched",programNotFetched:"program.not.fetched",resetSucceeded:"exchange-reset.succeeded",resetFailed:"exchange-reset.failed"},t.after_init(),t}g(t,e);var a=t.prototype;return a.exchangeSucceeded=function(e,t){return salla.cart.event.updated(e.data),this.dispatch("exchangeSucceeded",e,t)},a.resetSucceeded=function(e){return salla.cart.event.updated(e.data),this.dispatch("resetSucceeded",e)},t}(y),P=function(e){function t(){var t;return (t=e.call(this)||this).namespace="profile",t.events={updated:"updated",updateFailed:"update.failed",verificationCodeSent:"verification.code.sent",updateContactsFailed:"update.contacts.failed",verified:"verified",unverified:"unverified",infoFetched:"info.fetched",infoNotFetched:"info.not.fetched",settingsUpdated:"settings.updated",updateSettingsFailed:"update.settings.failed",deleted:"deleted",notDeleted:"not.deleted"},t.after_init(),t}return g(t,e),t}(y),A=function(e){function t(){var t;return (t=e.call(this)||this).namespace="product",t.events={priceUpdated:"price.updated",priceUpdateFailed:"price.updated.failed",availabilitySubscribed:"availability.subscribed",availabilitySubscribeFailed:"availability.subscribe.failed",categoriesFetched:"categories.fetched",categoriesFailed:"categories.failed",searchFailed:"search.failed",searchResults:"search.results",offerExisted:"offer.existed",fetchOffersFailed:"fetch.offers.failed",offersFetched:"offers.fetched",sizeGuideFetched:"size-guide.fetched",sizeGuideFetchFailed:"size-guide.failed",giftFetched:"gift.fetched",giftFetchFailed:"gift.failed",detailFetched:"detail.fetched",detailFetchFailed:"detail.failed",addGiftToCartSucceeded:"gift.add-to-cart.succeeded",addGiftToCartFailed:"gift.add-to-cart.failed",giftImageUploadSucceeded:"gift.image-upload.succeeded",giftImageUploadFailed:"gift.image-upload.failed",productListFetchSucceeded:"fetch.succeeded",productListFetchFailed:"fetch.failed",productOptionsFetched:"options.fetched",productOptionsNotFetched:"options.not.fetched"},t.after_init(),t}return g(t,e),t}(y),q=function(e){function t(){var t;return (t=e.call(this)||this).namespace="document",t.events={click:"click",change:"change",submit:"submit",keyup:"keyup",leaving:"leaving",request:"request",requestFailed:"request.failed"},t.after_init(),t}g(t,e);var a=t.prototype;return a.onClick=function(e,t){this.fireCallableFuns("click",e,t);},a.onChange=function(e,t){this.fireCallableFuns("change",e,t);},a.onSubmit=function(e,t){this.fireCallableFuns("submit",e,t);},a.onKeyup=function(e,t){this.fireCallableFuns("keyup",e,t);},a.fireCallableFuns=function(e,t,a){this.on(e,(function(e){"function"!=typeof t?"function"==typeof a&&e.target.matches(t)&&a(e):t(e);}));},a.fireEvent=function(e,t){for(var a=arguments.length,n=new Array(a>2?a-2:0),r=2;r<a;r++)n[r-2]=arguments[r];return this.fireEventForElements.apply(this,[e,t,false].concat(n))},a.fireEventForAll=function(e,t){for(var a=arguments.length,n=new Array(a>2?a-2:0),r=2;r<a;r++)n[r-2]=arguments[r];return this.fireEventForElements.apply(this,[e,t,true].concat(n))},a.fireEventForElements=function(e,t,a){for(var n=this,r=arguments.length,i=new Array(r>3?r-3:0),o=3;o<r;o++)i[o-3]=arguments[o];if("string"==typeof e){if(a)return document.querySelectorAll(e).forEach((function(e){return n.fireEventForElements.apply(n,[e,t,false].concat(i))}));e=document.querySelector(e);}if(e){var s=p(CustomEvent,[t].concat(i));return e.dispatchEvent(s)}salla.log("Failed To get element to fire event: "+t);},t}(y),E=function(e){function t(){var t;return (t=e.call(this)||this).namespace="wishlist",t.events={added:"added",removed:"removed",additionFailed:"addition.failed",removingFailed:"removing.failed"},t.after_init(),t}return g(t,e),t}(y),I=function(e){function t(){var t;return (t=e.call(this)||this).namespace="currency",t.events={changed:"changed",failed:"failed",fetched:"fetched",failedToFetch:"failed.to.fetch"},t.after_init(),t}return g(t,e),t}(y),T=function(e){function t(){var t;return (t=e.call(this)||this).namespace="infiniteScroll",t.events={scrollThreshold:"scroll.threshold",request:"request",load:"load",append:"append",error:"error",last:"last",history:"history"},t.after_init(),t}return g(t,e),t}(y),x=function(e){function t(){var t;return (t=e.call(this)||this).namespace="booking",t.events={added:"added",additionFailed:"addition.failed"},t.after_init(),t}return g(t,e),t}(y),L=function(e){function t(){var t;return (t=e.call(this)||this).namespace="landing",t.events={detailsFetched:"order.fetched",getDetailsFailed:"get.details.failed",orderCreated:"order.created",orderCreationFailed:"order.creation.failed",breadcrumbFetched:"breadcrumb.fetched",breadcrumbFetchFailed:"breadcrumb.fetch.failed"},t.after_init(),t}return g(t,e),t}(y),R=function(e){function t(){var t;return (t=e.call(this)||this).namespace="notifications",t.events={fetched:"fetched",fetchFailed:"fetch.failed"},t.after_init(),t}return g(t,e),t}(y),O=function(e){function t(){var t;return (t=e.call(this)||this).namespace="component",t.events={menuFetched:"menus.fetched",menuFetchFailed:"menus.fetch.failed",reviewsFetched:"reviews.fetched",reviewsFetchFailed:"reviews.fetch.failed"},t.after_init(),t}return g(t,e),t}(y),j=function(e){function t(){var t;return (t=e.call(this)||this).namespace="advertisement",t.events={fetched:"advertisement.fetched",fetchFailed:"advertisement.not.fetched"},t.after_init(),t}return g(t,e),t}(y),D=function(e){function t(){var t;return (t=e.call(this)||this).namespace="navigation",t.events={breadcrumbFetched:"breadcrumb.fetched",breadcrumbFetchFailed:"breadcrumb.fetch.failed"},t.after_init(),t}return g(t,e),t}(y),U=function(e){function t(){var t;return (t=e.call(this)||this).namespace="metadata",t.events={valueFetched:"value.fetched",valueNotFetch:"value.not.fetched"},t.after_init(),t}return g(t,e),t}(y);function N(e){e&&e.sallaInitiated&&!e.initiated&&(e.sallaInitiated(),e.initiated=true);}Salla.event.auth=new w,Salla.event.cart=new S,Salla.event.order=new b,Salla.event.scope=new _,Salla.event.rating=new F,Salla.event.booking=new x,Salla.event.comment=new k,Salla.event.landing=new L,Salla.event.loyalty=new C,Salla.event.product=new A,Salla.event.profile=new P,Salla.event.currency=new I,Salla.event.document=new q,Salla.event.wishlist=new E,Salla.event.infiniteScroll=new T,Salla.event.notifications=new R,Salla.event.component=new O,Salla.event.advertisement=new j,Salla.event.navigation=new D,Salla.event.metadata=new U,Salla.event.on("twilight::initiated",(function(){Object.keys(Salla).forEach((function(e){"object"==typeof(e=Salla[e])&&(N(e),Object.keys(e).forEach((function(t){N(e[t]);})));}));})),Salla.config.default_properties={debug:"undefined"!=typeof process&&"development"==="production",token:null,fastRequests:true,canLeave:true,store:{api:["group","test"].includes(window.location.hostname.split(".").pop())?window.location.origin+"/api/v1/":"https://api.salla.dev/store/v1/"},currencies:{SAR:{code:"SAR",name:"Ø±ÙŠØ§Ù„ Ø³Ø¹ÙˆØ¯ÙŠ",symbol:"Ø±.Ø³",amount:1,country_code:"sa"}}},Salla.config.merge(Salla.config.default_properties),Salla.config.triedToGetCurrencies_=false,Salla.config.triedToGetLanguages_=false,Salla.config.isUser=function(){return "user"===Salla.config.get("user.type")},Salla.config.isGuest=function(){return !Salla.config.isUser()},Salla.config.languages=async function(){var e;if(Salla.config.triedToGetLanguages_)return Salla.config.get("languages");Salla.config.triedToGetLanguages_=true;var t=true,a=[];return null==(e=await salla.document.api.request("languages",null,"get"))||null==(e=e.data)||e.map((function(e){t&&(a=[],t=false),e.code=e.code||e.iso_code,e.url=salla.url.get(e.code),e.is_rtl=e.is_rtl||e.rtl,a.push(e);})),Salla.config.set("languages",a),a},Salla.config.currencies=async function(){var e;if(Salla.config.triedToGetCurrencies_)return Salla.config.get("currencies");Salla.config.triedToGetCurrencies_=true;var t=true,a={};return null==(e=await salla.currency.api.list())||null==(e=e.data)||e.map((function(e){t&&(a={},t=false),e.country_code=e.code.substr(0,2).toLowerCase(),a[e.code]=e;})),Salla.config.set("currencies",a),a},Salla.config.isMobileApp=function(){var e;return ["ios","android"].includes(null==(e=Salla.analytics)||null==(e=e.jitsuAnalytics)||null==(e=e.getContextProperty("app"))||null==(e=e.platform)?void 0:e.toLowerCase())};var M=function(e){function a(t,a){var n;return (n=e.call(this,t,a)||this).options={path:".infinite-scroll-btn",history:"push",status:".infinite-scroll-status",append:".list-block"},n.fetchOptions={headers:{"S-INFINITE-SCROLL":true,"S-Source":"twilight","cache-control":"no-cache",pragma:"no-cache"}},n.instances=[],n}g(a,e);var n=a.prototype;return n.initiate=function(e,a,n,r){ void 0===r&&(r=false),r?((n=n||{}).fetchOptions=f({},this.fetchOptions,n.fetchOptions||{}),n.responseBody="json"):n=this.getCustomOptions(a,n);var i="string"!=typeof e?e:document.querySelector(e),o=n.path;if(i&&o&&("string"!=typeof o||document.querySelector(o))){var s=new t$1(i,n);return s.on("scrollThreshold",Salla.infiniteScroll.event.scrollThreshold),s.on("request",Salla.infiniteScroll.event.request),s.on("load",Salla.infiniteScroll.event.load),s.on("append",Salla.infiniteScroll.event.append),s.on("error",Salla.infiniteScroll.event.error),s.on("last",Salla.infiniteScroll.event.last),s.on("history",Salla.infiniteScroll.event.history),this.instances.push(s),s}Salla.logger.warn(i?"Path Option (a link that has next page link) Not Existed!":"Container For InfiniteScroll not Existed!");},n.getCustomOptions=function(e,t){return (t="object"==typeof e&&e||t||this.options).fetchOptions=this.fetchOptions,t.path=t.path||this.options.path,t.button=t.button||t.path,t.status=t.status||this.options.status,t.hasOwnProperty("history")||(t.history=this.options.history),t.nextPage=t.nextPage||t.next_page,t.append="string"==typeof e&&e||t.append||this.options.append,t},n.loadNextPage=function(e){("string"!=typeof e?e:document.querySelector(e)).loadNextPage();},n.destroy=function(e){("string"!=typeof e?e:document.querySelector(e)).destroy();},a}(u),H=function(){function e(){}var t=e.prototype;return t.submit=async function(e,t){var a,n;void 0===t&&(t=null);var r=t;if("SubmitEvent"===(null==(a=t)||null==(a=a.constructor)?void 0:a.name)||"submit"===(null==(n=t)?void 0:n.type)){var i,o;if(t.preventDefault(),"FORM"!==(null==(i=t.target)?void 0:i.tagName))return Salla.logger.warn("Failed find the target element for submit action. make sure you submit a form element"),new Promise((function(){throw "Failed find the target element for submit action. make sure you submit a form element"}));"SALLA-BUTTON"===(null==(o=t)||null==(o=o.submitter)||null==(o=o.parentElement)?void 0:o.tagName)&&t.submitter.parentElement.load(),r=t.target.getElementSallaData(),salla.log("Data from element",r);}if(/^https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)$/gm.test(e))return salla.api.request(e,r,"post").finally((function(){var e;loaderSupported&&(null==(e=t)||null==(e=e.submitter)||e.parentElement.stop());}));var s=e.split("."),l=s.splice(-1);return await salla.call(s.join("."))[l](r).finally((function(){var e;return null==(e=t)||null==(e=e.submitter)||null==(e=e.parentElement)?void 0:e.stop()})).catch((function(e){throw salla.logger.warn(e),e}))},t.onSubmit=function(e,t){return salla.form.submit(e,t),false},t.onChange=function(e,t){var a;return null!=t&&t.currentTarget?"FORM"!==(null==t||null==(a=t.currentTarget)?void 0:a.tagName)||t.currentTarget.checkValidity()?(salla.form.submit(e,t.currentTarget.getElementSallaData()),true):(salla.logger.warn("Trying to trigger '"+e+"' without filling required fields!"),false):(salla.logger.warn("Trying to trigger '"+e+"' without event!"),false)},t.getPossibleValue=function(e,t,a){if(void 0===a&&(a=false),e){if("object"!=typeof e)return e;for(var n,r=0;r<t.length&&!(n=e[t[r]])&&!("undefined"!=typeof FormData&&e instanceof FormData&&(n=e.get(t[r])));r++);return "object"!=typeof(n=n||e)||a?n:void 0}},e}(),V=function(e){function t(t){var a;return (t=t||{}).messages=t.messages||window.translations,t.locale=t.locale||(window.locale||navigator.language||navigator.userLanguage||"ar").split("-")[0],t.fallback=t.fallback||t.locale,(a=e.call(this,t)||this).translationsLoaded=false,a}g(t,e);var a=t.prototype;return a.onLoaded=function(e){var t=this;return new Promise((function(a){if(t.translationsLoaded)return a(e?e():null);Salla.event.once("languages::translations.loaded",(function(){return a(e?e():null)}));}))},a.loadStoreTranslations=function(){if(this.hash=salla.config.get("theme.translations_hash",salla.config.get("store.id","twilight")),this.message||(salla.log("try to load translations from localstorage"),this.messages=salla.storage.get("s_translations."+this.hash),this.messages&&(this.translationsLoaded=true)&&e.prototype.setMessages.call(this,this.messages)),this.messages)return salla.event.dispatch("languages::translations.loaded"),void salla.logger.info("The messages of transactions is already loaded");salla.url.get("")?this.loadScript(salla.url.get("languages/assets/"+this.hash+".js")):this.loadScript("https://cdn.salla.network/js/translations.js",false);},a.setMessages=function(t){e.prototype.setMessages.call(this,t),salla.event.dispatch("languages::translations.loaded"),this.translationsLoaded=true;},a.loadScript=function(e,t){var a=this;void 0===t&&(t=true);var n=document.createElement("script");n.src=e,n.onload=function(){var e;if(window.translations)return salla.storage.remove("s_translations"),salla.storage.set("s_translations",((e={})[a.hash]=window.translations,e)),a.setMessages(window.translations);n.onerror();},n.onerror=function(){if(t)return salla.logger.warn("Failed to load Translations for store, lets try load it from CDN"),a.loadScript("https://cdn.salla.network/js/translations.js",false);salla.logger.error("Failed to load Translations, check your network logs for more details\nor: salla.lang.setMessages({....}), see https://docs.salla.dev for more information's.");},document.head.appendChild(n);},a.getWithDefault=function(e,t,a,n){var r=this.get(e,a,n);return r!==e?r:t},a.get=function(t,a,n){var r=t;(window.translations||this.translationsLoaded)&&(r="trans."+t);var i=e.prototype.get.call(this,r,a,n);return i!==r?i:e.prototype.get.call(this,r,a,"en").replace(r,t)},a.set=function(e,t){return salla.helpers.setNested(this.messages[this.getLocale()+".trans"],e,t),this},a.add=function(e,t){var a=this;return Object.entries(t).forEach((function(t){return salla.helpers.setNested(a.messages[t[0]+".trans"],e,t[1])})),this},a.addBulk=function(e){var t=this;return Object.entries(e).forEach((function(e){var a=e[0],n=e[1];t.add(a,n);})),this},t}(a$3),G=function(){function e(){this.endpoints={},this.webEndpoints=[],this.namespace="BaseApi",this.endpointsMethods={},this.endpointsHeaders={};var e=/function (.{1,})\(/.exec(this.constructor.toString());this.className=(e&&e.length>1?e[1]:"").toLowerCase(),this.debounce={request:void 0,time:300,enabled:true,exclude:[]};}var t=e.prototype;return t.after_init=function(){},t.normalRequest=function(e,t,a){ void 0===t&&(t=void 0),void 0===a&&(a=null);var n=Array.isArray(e),r=n?this.getUrl.apply(this,e):this.getUrl(e);e=n?e[0]:e,a=a||this.endpointsMethods[e]||"post";var i=this.endpointsHeaders[e];if("get"===a&&t instanceof FormData){var o={};Array.from(t.entries()).forEach((function(e){o[e[0]]=e[1];})),t={params:o};}return i&&"get"===a&&(t=t?Object.assign(t,i):i),this.webEndpoints.includes(e)?r=salla.url.get(r):"http"!==r.substring(0,4)&&(r=salla.url.api(r)),Salla.api.request(r,t,a,{headers:i})},t.request=function(e,t,a){return void 0===t&&(t=void 0),void 0===a&&(a=null),!salla.api.isFastRequestsAllowed()&&this.debounce.enabled?(this.debounce.request||(this.debounce.request=salla.helpers.debounce(this.normalRequest.bind(this),this.debounce.time)),this.debounce.request(e,t,a)):this.normalRequest(e,t,a)},t.getUrl=function(e){for(var t=this.endpoints[e]||e,a=/{[^{}]+}/i,n=1;n<arguments.length;n++)t=t.replace(a,arguments[n]);return t},t.event=function(){return salla.event[this.className]},e}(),z=function(e){function t(){var t;return (t=e.call(this)||this).addToCartTries=0,t.guestCartAssigned=false,t.namespace="cart",t._pendingCartIdRequest=null,t._pendingAssignRequest=null,t.endpoints={latest:"cart/latest",latestApi:"cart/latest",details:"cart/{cart}",quickAdd:"cart/{cart}/item/{product}/quick-add",addItem:"cart/{cart}/item/{product}/add",deleteItem:"cart/{cart}/item/{item}",updateItem:"cart/{cart}/item/{item}",deleteImage:"cart/{cart}/image/{image}",uploadImage:"cart/{cart}/image",status:"cart/{cart}/status",addCoupon:"cart/{id}/coupon",deleteCoupon:"cart/{id}/coupon",getQuickOrderSettings:"checkout/quick-order",createQuickOrder:"checkout/quick-order",priceQuote:"cart/{cartId}/price-quote",offers:"offers/cart/{cartId}",giftCartDetails:"cart/{cartId}/buy-as-gift",cartGiftToCart:"cart/{cart_id}/buy-as-gift",assign:"cart/{cartId}/assign?merge=1"},t.endpointsMethods={latest:"get",details:"get",status:"get",updateItem:"post",deleteItem:"delete",deleteImage:"delete",deleteCoupon:"put",getQuickOrderSettings:"get",offers:"get",giftCartDetails:"get"},t.webEndpoints=["latest"],t.latestCart=null,t.after_init(),salla.event.on("api::initiated",(function(){return salla.api.cart.getCurrentCartId(false,"api::initiated")})),salla.event.on("auth::token.fetched",t._checkCurrentCart),salla.event.on("auth::token.invalid",t._checkCurrentCart),salla.event.on("auth::verified",(async function(){try{await Salla.api.cart.assign();}catch(e){Salla.log("Error on assign after verified",e);}return Salla.api.cart.getCurrentCartId(true,"auth::verified")}),{async:true}),salla.event.on("twilight::initiated",(function(){return salla.api.cart.syncGuestCart()})),salla.event.on("profile::info.fetched",(function(){return t._checkCurrentCart(true)})),salla.event.on("twilight::error",(function(e){return (e.includes("Cart not available")||e.includes("Ø§Ù„Ø³Ù„Ø© ØºÙŠØ± Ù…ØªØ§Ø­Ø©"))&&salla.cart.api.reset()})),t}g(t,e);var a=t.prototype;return a._checkCurrentCart=function(e){var t,a;void 0===e&&(e=false);var n=salla.storage.get("cart"),r=null==(t=salla.config.get("user"))?void 0:t.id,i=null==(a=salla.config.get("store"))?void 0:a.id;n&&n.id&&!e&&(n.user_id===r&&n.store_id===i||(salla.log("cart",{user_id:n.user_id,store_id:n.store_id}),salla.log("current",{user_id:r,store_id:i}),salla.log("Api:: case2 => The cart is not belong to current "+(n.user_id!==r?"user":"store")+"!"),salla.cart.api.reset()),salla.url.is_page("cart")&&n.id!==salla.config.get("page.id")&&(salla.log("cart",{user_id:n.user_id,store_id:n.store_id}),salla.log("current",{user_id:r,store_id:i}),salla.log("Api:: case2 => The cart is different between storage:"+n.id+" & session:"+salla.config.get("page.id")+" !"),salla.cart.api.reset()));},a.getCurrentCartId=async function(e,t){if(void 0===e&&(e=false),void 0===t&&(t="getCurrentCartId"),Salla.cart.api._pendingCartIdRequest)return Salla.cart.api._pendingCartIdRequest;Salla.cart.api._pendingCartIdRequest=async function(){try{if(!e){if(Salla.cart.api.latestCart)return Salla.cart.api.latestCart.cart.id;var a=Salla.storage.get("cart.id");if(a)return a}var n=await Salla.cart.api.latest(t);return Salla.cart.api.latestCart=n.data,Salla.cart.api.latestCart.cart.id}finally{Salla.cart.api._pendingCartIdRequest=null;}}();var a=Salla.cart.api._pendingCartIdRequest;return Salla.cart.api._pendingCartIdRequest=null,a},a.getUploadImageEndpoint=function(e){return salla.url.api(this.getUrl("uploadImage",e||salla.storage.get("cart.id")))},a.latest=function(e){return void 0===e&&(e="direct"),this.request(salla.auth.api.isSessionless()?"latestApi":"latest",{params:{source:"",callerName:e}}).then((function(e){return salla.api.cart.set(e.data.cart),salla.event.cart.latestFetched(e),e})).catch((function(e){throw salla.api.cart.reset(),salla.event.cart.latestFailed(e),e}))},a.details=async function(e,t){return void 0===t&&(t=[]),e=e||await salla.api.cart.getCurrentCartId(false,"salla.api.cart.details"),this.request(["details",e],{params:{with:t}}).then((function(e){return salla.cart.event.detailsFetched(e),e})).catch((function(e){throw salla.cart.event.detailsNotFetched(e),e}))},a.quickAdd=async function(e,t,a){return this.addItem({id:e,quantity:t,offerType:a,endpoint:"quickAdd"})},a.addItem=async function(e){var t=this.getCartPayload(e);if(!t.id){var a='There is no product "id"!';return salla.cart.event.itemAddedFailed(a),salla.api.errorPromise(a)}var n=salla.form.getPossibleValue(t.payload,["endpoint"]);n&&["addItem","quickAdd"].includes(n)||(n=salla.form.getPossibleValue(t.payload,["quantity","donating_amount"])?"addItem":"quickAdd");var r=await Salla.api.cart.getCurrentCartId(false,"salla.api.cart.addItem");try{t.payload=Salla.helpers.createFormDataWrapper(t.payload||{}),await Salla.cart.event.beforeAddItem(t);}catch(e){}return this.request([n,r,t.id],t.payload.getRawData()).then((function(e){Salla.cart.api.addToCartTries=0;try{Salla.cart.event.itemAdded(e,t.id);}catch(e){Salla.log(e);}return e})).catch((function(a){if(!Salla.cart.api.addToCartTries)return Salla.cart.api.addToCartTries++,Salla.cart.reset(),Salla.cart.api.addItem(e);throw Salla.cart.event.itemAddedFailed(a,t.id),a}))},a.deleteItem=async function(e){var t=this.getCartPayload(e);if(!t.id){var a='There is no "id"!';return salla.cart.event.itemDeletedFailed(a),salla.api.errorPromise(a)}var n=await salla.api.cart.getCurrentCartId(false,"salla.api.cart.deleteItem");return this.request(["deleteItem",n,t.id]).then((function(e){return salla.cart.event.itemDeleted(e,t.id),e})).catch((function(e){throw salla.cart.event.itemDeletedFailed(e,t.id),e}))},a.updateItem=async function(e){var t,a=this.getCartPayload(e);if(!a.id){var n='There is no "id"!';return salla.cart.event.itemUpdatedFailed(n),salla.api.errorPromise(n)}var r=await salla.api.cart.getCurrentCartId(false,"salla.api.cart.updateItem");return "Object"===(null==(t=a.payload.constructor)?void 0:t.name)?a.payload._method="PUT":a.payload.append("_method","PUT"),this.request(["updateItem",r,a.id],a.payload).then((function(e){return salla.cart.event.itemUpdated(e,a.id),e})).catch((function(e){throw salla.cart.event.itemUpdatedFailed(e,a.id),e}))},a.deleteImage=async function(e){if(!(e=salla.form.getPossibleValue(e,["id","image_id","photo_id"]))){var t='There is no "id"!';return salla.cart.event.imageNotDeleted(t),salla.api.errorPromise(t)}var a=await salla.api.cart.getCurrentCartId(false,"salla.api.cart.deleteImage");return this.request(["deleteImage",a,e]).then((function(t){return salla.cart.event.imageDeleted(t,e),t})).catch((function(t){throw salla.cart.event.imageNotDeleted(t,e),t}))},a.status=async function(e,t){ void 0===t&&(t=false),e=e||await salla.api.cart.getCurrentCartId(false,"salla.api.cart.status");var a={has_apple_pay:salla.helpers.hasApplePay()};t&&(a.guest_checkout=1);try{await salla.cart.event.submitting();}catch(e){salla.log("Error on: salla.cart.event.submitting()");}return this.request(["status",e],{params:a})},a.submit=async function(e,t){if(void 0===e&&(e=false),void 0===t&&(t=false),console.log("salla.cart.api.submit",{isGuestCheckout:e}),salla.config.isGuest()&&!e)return salla.log("it looks that the current user is not logged-in, lets login then submit"),salla.cart.loginOnCartPage();var a;if(t)try{var n,r=await Salla.api.cart.assign();a=null==r||null==(n=r.data)?void 0:n.cart_id;}catch(e){Salla.log("Error on assign after login from submit",e);}this.status(null!=a?a:await salla.api.cart.getCurrentCartId(false,"salla.api.cart.submit"),e).then((function(e){var t,a=null==(t=e.data.next_step)?void 0:t.to;if(a||(window.history.pushState({},"",salla.url.addParamToUrl("reload","empty_next_step")),window.history.pushState({},"",salla.url.addParamToUrl("acitve",false===e.data.active?"false":"true_or_undfined")),salla.cart.reset(),window.location.reload()),!["checkout","refresh","login"].includes(a)){var n="Can't find next_step );";throw salla.cart.reset(),salla.cart.event.submitFailed(n),n}return salla.cart.event.submitted(e),"login"===a?salla.cart.loginOnCartPage():"checkout"===a?window.location.href=e.data.next_step.url+(salla.helpers.hasApplePay()?"?has_apple_pay=true":""):(window.history.pushState({},"",salla.url.addParamToUrl("reload","refresh")),void window.location.reload())})).catch((function(e){var t;salla.cart.api.tries=salla.cart.api.tries||0,salla.cart.reset();var a=404===(null==e||null==(t=e.response)||null==(t=t.data)?void 0:t.status);if(a&&0===salla.cart.api.tries)return salla.cart.api.tries++,salla.log("we recived that the current cart is not found, we will try to re-submit one more time"),salla.cart.submit();throw a&&salla.error(salla.lang.get("pages.checkout.try_again")),salla.cart.event.submitFailed(e),e}));},a.getCartPayload=function(e){var t,a=(null==(t=e)?void 0:t.data)||("object"==typeof e?e:void 0);return {id:e=a?salla.form.getPossibleValue(a,["prod_id","product_id","item_id","id"]):e,payload:a="object"==typeof a?a:void 0}},a.normalRequest=function(t,a,n){var r=this;return void 0===a&&(a=void 0),void 0===n&&(n=null),e.prototype.normalRequest.call(this,t,a,n).catch((async function(e){var t;throw 403===(null==e||null==(t=e.response)?void 0:t.status)&&(r.reset(),salla.error(salla.lang.get("pages.checkout.try_again"))),e}))},a.reset=function(){salla.api.cart.latestCart=null,salla.storage.remove("cart"),salla.cookie.clearCookieByPrefix(salla.api.cart.getCartCookiePrefix()),salla.cart.event.successReset();},a.addCoupon=async function(e){if(e=e.data||e,!(e=salla.form.getPossibleValue(e,["coupon"]))){var t=new Error('There is no "Coupon Code"!');return t.name="EmptyCoupon",salla.event.cart.couponAdditionFailed(t),salla.api.errorPromise(t)}var a=await salla.cart.api.getCurrentCartId(false,"salla.api.cart.addCoupon");return this.request(["addCoupon",a],{coupon:e}).then((function(e){var t,n=salla.storage.get("cart");return n&&null!=(t=e.data)&&null!=(t=t.cart)&&t.coupon&&(n.coupon=e.data.cart.coupon,salla.storage.set("cart",n)),salla.event.cart.couponAdded(e,a),e})).catch((function(e){throw salla.event.cart.couponAdditionFailed(e,a),e}))},a.deleteCoupon=async function(){var e=await salla.cart.api.getCurrentCartId(false,"salla.api.cart.deleteCoupon");return this.request(["deleteCoupon",e],{}).then((function(t){var a=salla.storage.get("cart");return a&&a.coupon&&(delete a.coupon,salla.storage.set("cart",a)),salla.event.cart.couponDeleted(t,e),t})).catch((function(t){throw salla.event.cart.couponDeletionFailed(t,e),t}))},a.getQuickOrderSettings=function(){return this.request("getQuickOrderSettings").then((function(e){return salla.event.cart.quickOrderSettingFetched(e),e})).catch((function(e){throw salla.event.cart.quickOrderSettingFailed(e),e}))},a.createQuickOrder=function(e){return this.request("createQuickOrder",e).then((function(e){return salla.event.cart.quickOrderSucceeded(e),e})).catch((function(e){throw salla.event.cart.quickOrderFailed(e),e}))},a.priceQuote=async function(e){return salla.config.isGuest()?(salla.auth.api.setAfterLoginEvent("cart::priceQuote",e),void salla.event.dispatch("login::open")):this.request(["priceQuote",e||await salla.api.cart.getCurrentCartId(false,"salla.api.cart.priceQuote")]).then((function(e){return salla.cart.api.reset(),salla.event.cart.priceQuoteSucceeded(e).then((function(){return setTimeout((function(){return window.location.href=salla.url.get("/")}),1e3),e}))})).catch((function(e){return salla.event.cart.priceQuoteFailed(e).then((function(){var t;throw 404===(null==(t=e.error)?void 0:t.code)&&window.location.reload(),e}))}))},a.loginOnCartPage=function(){salla.auth.setCanRedirect(false),salla.event.dispatch("login::open",{withoutReload:true,source:"cart-submit"}),salla.auth.event.onLoggedIn((function(){salla.event.dispatch("login::close"),salla.cart.submit(false,true);}));},a.set=function(e){salla.storage.set("cart",e),salla.api.cart.syncGuestCart();},a.offers=async function(){var e=await salla.cart.api.getCurrentCartId(false,"salla.api.cart.offers");return this.request(["offers",e]).then((function(e){return salla.event.cart.offersFetched(e),e})).catch((function(e){throw salla.event.cart.offersFailed(e),e}))},a.getGiftCartDetails=async function(){var e=await salla.api.cart.getCurrentCartId(false,"salla.api.cart.getGiftCartDetails");return this.request(["giftCartDetails",e]).then((function(t){return salla.product.event.giftFetched(t,e),t})).catch((function(t){throw salla.product.event.giftFetchFailed(t,e),t}))},a.addCartGiftToCart=async function(e,t){ void 0===t&&(t=false);var a=await salla.api.cart.getCurrentCartId(false,"salla.api.cart.addCartGiftToCart");return this.request(["cartGiftToCart",a],e).then((function(e){return salla.product.event.addGiftToCartSucceeded(e,a),t&&(window.location.href=e.redirect),e})).catch((function(e){throw salla.product.event.addGiftToCartFailed(e,a),e}))},a.syncGuestCart=async function(){if(salla.config.isGuest()){var e=salla.api.cart.getCartCookiePrefix(),t=salla.cookie.getCookieByPrefix(e),a=salla.storage.get("cart.id");if(!a&&t.length)try{var n,r=null==(n=(await salla.api.cart.latest()).data)||null==(n=n.cart)?void 0:n.id;r&&salla.api.cart.setCartCookie(e,r);}catch(e){salla.log("Failed to fetch latest cart:",e);}salla.cookie.clearCookieByPrefix(e),a&&(salla.config.set("headers.s-cart-id",a),salla.api.cart.setCartCookie(e,a));}},a.assign=async function(){var e=this;if(Salla.api.cart._pendingAssignRequest)return Salla.api.cart._pendingAssignRequest;var t=Salla.storage.get("cart.id");return !(!t||Salla.api.cart.guestCartAssigned)&&(Salla.api.cart._pendingAssignRequest=async function(){try{var a=await e.request(["assign",t]);return Salla.api.cart.guestCartAssigned=true,a}catch(e){throw e}finally{Salla.api.cart._pendingAssignRequest=null;}}(),Salla.api.cart._pendingAssignRequest)},a.setCartCookie=function(e,t){salla.cookie.set(e+"-"+t,t,1);},a.getCartCookiePrefix=function(){return "cart-id-"+salla.config.get("store.id")},t}(G),W=function(e){function t(){var t;return (t=e.call(this)||this).namespace="loyalty",t.endpoints={getProgram:"loyalty",exchange:"loyalty/exchange",reset:"loyalty/exchange"},t.endpointsMethods={getProgram:"get",reset:"put"},t.after_init(),t}g(t,e);var a=t.prototype;return a.getProgram=function(){return this.request("getProgram").then((function(e){return salla.loyalty.event.programFetched(e),e})).catch((function(e){throw salla.loyalty.event.programNotFetched(e),e}))},a.exchange=async function(e,t){if(void 0===t&&(t=null),!(e=salla.form.getPossibleValue(e,["id","loyalty_prize_id","prize_id"]))){var a="Unable to find cart id. Please provide one.";return salla.loyalty.event.exchangeFailed(a),salla.api.errorPromise(a)}if(!(t=t||await salla.cart.getCurrentCartId(false,"salla.api.loyalty.exchange"))){var n="Unable to find cart id. Please provide one.";return salla.loyalty.event.exchangeFailed(n),salla.api.errorPromise(n)}return this.request("exchange",{loyalty_prize_id:e,cart_id:t}).then((function(t){return salla.loyalty.event.exchangeSucceeded(t,e),t})).catch((function(t){throw salla.loyalty.event.exchangeFailed(t,e),t}))},a.reset=async function(e){if(void 0===e&&(e=null),!(e=e||await salla.cart.getCurrentCartId(false,"salla.api.loyalty.reset"))){var t="Unable to find cart id. Please provide one.";return salla.loyalty.event.resetFailed(t),salla.api.errorPromise(t)}return this.request("reset",{cart_id:e}).then((function(e){return salla.loyalty.event.resetSucceeded(e),e})).catch((function(e){throw salla.loyalty.event.resetFailed(e),e}))},t}(G),B=function(e){function t(){var t;return (t=e.call(this)||this).namespace="auth",t.canRedirect_=true,t.afterLoginEvent={event:null,payload:null},t.endpoints={login:"auth/{type}/send_verification",resend:"auth/resend_verification",verify:"auth/{type}/verify",register:"auth/register",logout:"logout",refresh:"auth/refresh"},t.webEndpoints=["logout","auth/jwt","refresh"],t.endpointsMethods={logout:"get"},t.inIframe=salla.helpers.isIframe(),Salla.event.on("twilight::init",(function(){if(Salla.config.isGuest()&&location.href.includes("force_logout"))return delete Salla.api.axios.defaults.headers.common.Authorization,Salla.api.auth.logout("twilight",false)})),t.after_init(),t}g(t,e);var a=t.prototype;return a.setAfterLoginEvent=function(e,t){salla.api.auth.afterLoginEvent={event:e,payload:t};},a.setCanRedirect=function(e){salla.api.auth.canRedirect_=e;},a.canRedirect=function(){return salla.api.auth.canRedirect_&&!salla.api.auth.afterLoginEvent.event},a.login=function(e){var t;null!=(t=e)&&t.data&&(e=e.data);var a=salla.form.getPossibleValue(e,["type"]);if(!["email","mobile"].includes(a)){var n="Login type should be in: [email, mobile]";return salla.auth.event.codeNotSent(n),salla.api.errorPromise(n)}return this.request(["login",a],e).then((function(e){return salla.auth.event.codeSent(e,a),e})).catch((function(e){throw salla.auth.event.codeNotSent(e,a),salla.auth.api.trackBlockedError(e,"login"),e}))},a.verify=async function(e,t){ void 0===t&&(t=true);var a=salla.form.getPossibleValue(e,["type"]);if(!a){var n="Failed to know what's login type!";return salla.auth.event.verificationFailed(n),salla.api.errorPromise(n)}t=false!==salla.form.getPossibleValue(e,["supportWebAuth"])&&t,salla.auth.event.next_event&&(e.next_event=salla.auth.event.next_event);var r=await salla.auth.api.request(["verify",a],e);return 200!==(null==r?void 0:r.status)?(salla.auth.event.verificationFailed(r,a),salla.api.errorPromise(r)):salla.auth.api.handlAfterAuthenticatedResponse(r,t)},a.handlAfterAuthenticatedResponse=async function(e,t){var a;e.data||(e={data:e});var n="authenticated"===(null==(a=e.data)?void 0:a.case);return n&&salla.auth.event.tokenFetched(e.data.token),t&&!this.inIframe&&!this.isSessionless()&&await salla.auth.api.request("auth/jwt",{callerName:"salla.auth.api.handlAfterAuthenticatedResponse"}),n&&await salla.auth.event.loggedIn(e).then((function(){return salla.auth.api.afterUserLogin()})),await salla.auth.event.verified(e,e.data.verification.type),salla.api.successPromise(e)},a.resend=function(e){var t;return (e=e.data||e).type=e.type||"mobile","mobile"!==e.type||e.phone&&e.country_code?"email"!==e.type||e.email?this.request("resend",e).then((function(t){return salla.auth.event.codeSent(t,e),t})).catch((function(t){throw salla.auth.event.codeNotSent(t,e),salla.auth.api.trackBlockedError(t,"resend"),t})):(salla.auth.event.codeNotSent(t="There is no email!",e),salla.api.errorPromise(t)):(salla.auth.event.codeNotSent(t="There is no phone or country_code!",e),salla.api.errorPromise(t))},a.register=function(e){var t,a=this;return e.data&&(t=e.element,e=e.data),salla.auth.event.next_event&&(e.next_event=salla.auth.event.next_event),this.request("register",e).then((async function(e){var n;return salla.auth.event.registered.call(t,e),"authenticated"===(null==(n=e.data)?void 0:n.case)&&(salla.auth.event.tokenFetched(e.data.token),!a.inIframe&&!a.isSessionless()&&await salla.auth.request("auth/jwt",{callerName:"salla.auth.api.register"}),salla.auth.event.loggedIn(e),salla.auth.api.afterUserLogin()),e})).catch((function(e){throw salla.auth.event.registrationFailed.call(t,e),salla.auth.api.trackBlockedError(e,"register"),e}))},a.handleIframeReadyAction=function(e,t){var a;null==(a=e.contentWindow)||a.postMessage({source:"logout",type:"init",data:{id:salla.config.get("store.id"),lang:"ar",appUrl:t,apiUrl:salla.config.get("store.api").replace(/\/+$/,""),settings:salla.config.all(),storage:{}}},"*");},a.appendIframeAndLogout=function(){var e=this;return new Promise((function(t){var a=salla.config.get("login.url","https://accounts.salla.com"),n=document.createElement("iframe");n.style.display="none",n.src=a+"/logout";var r=function(i){if("login"===i.data.source){var o=i.data.type.replace("iframe::","");if(salla.log("iframe::logout-iframe message received",i.data),["logged-out","ready"].includes(o)){if("ready"===o)return e.handleIframeReadyAction(n,a);window.removeEventListener("message",r),n.remove(),t();}}};window.addEventListener("message",r),document.body.appendChild(n);}))},a.logout=function(e,t){var a=this;return void 0===e&&(e="twilight"),void 0===t&&(t=true),salla.storage.clearAll(),salla.cookie.clearAll(),e=encodeURI(e),salla.auth.event.loggedOut().then((function(){return a.appendIframeAndLogout()})).then((function(){if(t){var a=salla.url.get("logout?from="+e);console.log("Going to "+a+", to do any thing before this action use: salla.auth.even.onLoggedOut(()=>{...})");try{location.href=a;}catch(e){salla.log(e);}}})).catch((function(e){return console.error("Error during logout:",e)}))},a.refresh=function(){return this.request("refresh").then((function(e){return salla.auth.event.tokenFetched(e.data.token),e})).catch((function(e){throw salla.auth.event.refreshFailed(e),e}))},a.afterUserLogin=function(){this.afterLoginEvent.event&&salla.event.emit(this.afterLoginEvent.event,this.afterLoginEvent.payload);},a.isSessionless=function(){return "sessionless"===salla.config.get("auth.mode")},a.trackBlockedError=function(e,t){var a;blockedByProxy=void 0===(null==e||null==(a=e.response)||null==(a=a.headers)?void 0:a["s-ray"]),blockedByProxy&&salla.analytics.track("BlockedByProxy",{class:"auth",function:t,reason:"non-server-request",message:e.message});},t}(G),Q=function(e){function t(){var t;return (t=e.call(this)||this).namespace="order",t.endpoints={cancel:"orders/cancel/{id}",createCartFromOrder:"reorder/{id}",reorderProduct:"reorder/product/{id}",sendInvoice:"orders/send/{id}",fetch:"orders"},t.endpointsMethods={createCartFromOrder:"get",fetch:"get"},t.after_init(),t}g(t,e);var a=t.prototype;return a.show=function(e){var t=salla.form.getPossibleValue((null==e?void 0:e.data)||e,["id","order_id"]);salla.event.dispatch("mobile::order.placed",{order_id:t}),location.href=salla.form.getPossibleValue((null==e?void 0:e.data)||e,["url"]);},a.cancel=function(e){return e=e||Salla.config.get("page.id"),this.request(["cancel",e],{params:{has_apple_pay:salla.helpers.hasApplePay()}}).then((function(t){return salla.event.order.canceled(t,e),t})).catch((function(t){throw salla.event.order.notCanceled(t,e),t}))},a.createCartFromOrder=function(e){return e=e||salla.config.get("page.id"),this.request(["createCartFromOrder",e]).then((function(t){return salla.cart.reset(),salla.event.order.orderCreated(t,e),window.location.href=t.data.url,t})).catch((function(t){throw salla.event.order.orderCreationFailed(t,e),t}))},a.reorderProduct=function(e){return e=e||salla.config.get("page.id"),this.request(["reorderProduct",e]).then((function(e){return salla.event.order.orderCreated(e,e.data.order_id),window.location.href=e.data.url,e})).catch((function(e){throw e}))},a.sendInvoice=function(e){var t=salla.form.getPossibleValue(e,["id"])||salla.config.get("page.id");if(!t||isNaN(t)){var a="There is no id!";return salla.order.event.invoiceNotSent(a),salla.api.errorPromise(a)}return this.request(["sendInvoice",t],e).then((function(e){return salla.event.order.invoiceSent(e,t),e})).catch((function(e){throw salla.event.order.invoiceNotSent(e,t),e}))},a.fetch=function(e){return this.request(["fetch"],{params:e}).then((function(e){return salla.event.order.ordersFetched(e),e})).catch((function(e){throw salla.event.order.ordersNotFetched(e),e}))},t}(G),K=function(e){function t(){var t;return (t=e.call(this)||this).namespace="product",t.previousQuery="",t.endpoints={getPrice:"products/{id}/price",availabilitySubscribe:"products/{id}/availability-notify",search:"products/search",details:"products/{product_id}/details",categories:"products/categories/{?id}",offers:"products/{product_id}/specialoffer",getSizeGuides:"products/{prod_id}/size-guides",giftProductDetails:"products/{product_id}/buy-as-gift",productGiftToCart:"products/{product_id}/buy-as-gift",giftImage:"products/buy-as-gift/image",buyNow:"products/{product_id}/buy-now",fetch:"products",fetchOptions:"products/options"},t.endpointsMethods={details:"get",giftProductDetails:"get",fetch:"get",offers:"get",fetchOptions:"get"},t.after_init(),t}g(t,e);var a=t.prototype;return a.getPrice=function(e){var t=e.data||e,a=salla.form.getPossibleValue(t,["id","prod_id","product_id"]);return this.request(["getPrice",a],"object"==typeof t?t:void 0).then((function(e){return salla.product.event.priceUpdated(e,a),e})).catch((function(e){throw salla.product.event.priceUpdateFailed(e,a),e}))},a.categories=function(e){return this.request(["categories",e||""],null,"get").then((function(e){return salla.product.event.categoriesFetched(e),e})).catch((function(e){throw salla.product.event.categoriesFailed(e),e}))},a.availabilitySubscribe=function(e){var t=e.data||e;return e=salla.form.getPossibleValue(t,["id","prod_id"]),this.request(["availabilitySubscribe",e],"object"==typeof t?t:void 0).then((function(t){return salla.product.event.availabilitySubscribed(t,e),t})).catch((function(t){throw salla.product.event.availabilitySubscribeFailed(t,e),t}))},a.search=function(e){var t,a=e.data;if(a||(a={params:"string"==typeof e?{query:e}:e}),!(e=a instanceof FormData?a.get("query"):a.query||(null==(t=a.params)?void 0:t.query))){var n='There is no "query"!';return salla.product.event.searchFailed(n),salla.api.errorPromise(n)}if(e===salla.api.product.previousQuery){var r="Query is same as previous one!";return salla.product.event.searchFailed(r),salla.api.product.previousQuery=null,salla.api.errorPromise(r)}return salla.api.product.previousQuery=e,this.request("search",a,"get").then((function(t){return salla.product.event.searchResults(t,e),t})).catch((function(t){throw salla.product.event.searchFailed(t,e),t}))},a.offers=function(e){var t;if(!(e=salla.form.getPossibleValue((null==(t=e)?void 0:t.data)|e,["product_id","id"]))){var a='There is no "product_id"!';return salla.product.event.fetchOffersFailed(a),salla.api.errorPromise(a)}return this.request(["offers",e]).then((function(t){return salla.product.event.offersFetched(t,e),t})).catch((function(t){throw salla.product.event.fetchOffersFailed(t,e),t}))},a.getSizeGuides=function(e){return this.request("products/"+e+"/size-guides",null,"get").then((function(t){return salla.product.event.sizeGuideFetched(t,e),t})).catch((function(t){throw salla.product.event.sizeGuideFetchFailed(t,e),t}))},a.getGiftProductDetails=function(e){return this.request(["giftProductDetails",e]).then((function(t){return salla.product.event.giftFetched(t,e),t})).catch((function(t){throw salla.product.event.giftFetchFailed(t,e),t}))},a.getDetails=function(e,t){if(void 0===t&&(t=[]),!Array.isArray(t)){var a="withItems should be array.";return salla.product.event.detailFetchFailed(a),salla.api.errorPromise(a)}if(!e){var n="productId is not passed.";return salla.product.event.detailFetchFailed(n),salla.api.errorPromise(n)}return this.request(["details",e],{params:{with:t}}).then((function(t){return salla.product.event.detailFetched(t,e),t})).catch((function(t){throw salla.product.event.availabilitySubscribeFailed(t,e),t}))},a.addProductGiftToCart=function(e,t,a){return void 0===a&&(a=false),this.request(["productGiftToCart",e],t).then((function(t){return salla.product.event.addGiftToCartSucceeded(t,e),a&&(window.location.href=t.redirect),t})).catch((function(t){throw salla.product.event.addGiftToCartFailed(t,e),t}))},a.uploadGiftImage=function(e){return this.request("giftImage",e).then((function(e){return salla.product.event.giftImageUploadSucceeded(e),e})).catch((function(e){throw salla.product.event.giftImageUploadFailed(e),e}))},a.fetch=function(e){if(!e.source){var t="Source cannot be empty. Please provide one.";return salla.product.event.productListFetchFailed(t),salla.api.errorPromise(t)}var a=!e.source_value,n="string"==typeof e.source_value&&"[]"===e.source_value,r=Array.isArray(e.source_value)&&!e.source_value.length;if((a||n||r)&&!["offers","latest","sales","wishlist","top-rated","reorder"].includes(e.source)){var i="Source value cannot be empty. Please provide one.";return salla.product.event.productListFetchFailed(i),salla.api.errorPromise(i)}if(["categories","brands","tags","selected"].includes(e.source)&&!Array.isArray(e.source_value)){var o="SourceValue type error. Expected an array.";return salla.product.event.productListFetchFailed(o),salla.api.errorPromise(o)}if("search"===e.source&&"string"!=typeof e.source_value){var s="SourceValue type error. Expected a string.";return salla.product.event.productListFetchFailed(s),salla.api.errorPromise(s)}if("related"===e.source&&isNaN(e.source_value)){var l="SourceValue type error. Expected a number.";return salla.product.event.productListFetchFailed(l),salla.api.errorPromise(l)}return this.request(this.endpoints.fetch,{params:e},"get").then((async function(e){return salla.product.event.productListFetchSucceeded(e),e})).catch((function(e){throw salla.product.event.productListFetchFailed(e),e}))},a.fetchOptions=function(e,t){if(void 0===t&&(t={}),!e||0===e.length){var a="At least one product ID is required. Please provide a valid list of product IDs.";return salla.product.event.productOptionsNotFetched(a),salla.api.errorPromise(a)}var n=t.with,r=void 0===n?[]:n,i={selected:e};return r.length>0&&(i.with=r),this.request(this.endpoints.fetchOptions,{params:i},"get").then((function(e){return salla.product.event.productOptionsFetched(e),e})).catch((function(e){throw salla.product.event.productOptionsNotFetched(e),e}))},t}(G),J=function(e){function t(){var t;return (t=e.call(this)||this).namespace="profile",t.endpoints={info:"auth/user",update:"profile/update",updateContacts:"profile/contacts/update",updateCustomFields:"profile/fields",updateSettings:"profile/settings",verify:"profile/verify",delete:"profile"},t.endpointsMethods={delete:"delete"},t.after_init(),t}g(t,e);var a=t.prototype;return a.syncUserData=function(e){var t={id:e.id,type:"user",email:e.email,mobile:e.phone.code+e.phone.number,country_code:e.phone.country,language_code:e.language,currency_code:e.currency,notifications:e.notifications,pending_orders:e.pending_orders,avatar:e.avatar,first_name:e.first_name,last_name:e.last_name,is_hidden_name:e.is_hidden_name,is_notifiable:e.is_notifiable,can_comment:salla.config.get("user.can_comment"),fetched_at:Date.now()};salla.config.set("user",t),salla.storage.set("user",t);},a.info=function(){var e=this;return this.request("info",null,"get").then((function(t){return e.syncUserData(t.data),salla.profile.event.infoFetched(t),t})).catch((function(e){throw salla.profile.event.infoNotFetched(e),e}))},a.update=function(e){var t=this;if(Salla.config.get("store.features",[]).includes("sso-login")){var a="SSO login is enabled. You cannot update your profile.";return Salla.error(a),Promise.reject(new Error(a))}return this.request("update",e).then((function(e){return t.syncUserData(e.data),salla.profile.event.updated(e),e})).catch((function(e){throw salla.event.profile.updateFailed(e),e}))},a.updateCustomFields=function(e){var t=this;if(Salla.config.get("store.features",[]).includes("sso-login")){var a="SSO login is enabled. You cannot update your profile.";return Salla.error(a),Promise.reject(new Error(a))}return this.request("updateCustomFields",e).then((function(e){return t.syncUserData(e.data),salla.profile.event.updated(e),e})).catch((function(e){throw salla.event.profile.updateFailed(e),e}))},a.updateContacts=function(e){return this.request("updateContacts",e).then((function(e){return salla.profile.event.verificationCodeSent(e),e})).catch((function(e){throw salla.event.profile.updateContactsFailed(e),e}))},a.verify=function(e){return this.request("verify",e).then((function(e){return salla.profile.event.verified(e),e})).catch((function(e){throw salla.event.profile.unverified(e),e}))},a.updateSettings=function(e){return this.request("updateSettings",e).then((function(e){return salla.event.profile.settingsUpdated(e),e})).catch((function(e){throw salla.event.profile.updateSettingsFailed(e),e}))},a.delete=function(){return this.request("delete").then((function(e){return salla.storage.clearAll(),salla.cookie.clearAll(),salla.auth.api.appendIframeAndLogout().then((function(){salla.event.profile.deleted(e),window.location.href=salla.url.get("logout");})),e})).catch((function(e){throw salla.event.profile.notDeleted(e),e}))},t}(G),X=function(e){function t(){var t;return (t=e.call(this)||this).namespace="comment",t.endpoints={addComment:"{type}/{id}/comments",comments:"/comments"},t.after_init(),t}g(t,e);var a=t.prototype;return a.add=function(e){var t;if(null!=(t=e)&&t.data&&(e=e.data),"string"==typeof(e=this.getCommentPayload(e,true)))return salla.event.comment.additionFailed(e),salla.api.errorPromise(e);if(!e.comment){var a="can't find comment content!";return salla.event.comment.additionFailed(a),salla.api.errorPromise(a)}return this.request(["addComment","blog"==e.type?"blogs":e.type,e.id],{comment:e.comment}).then((function(t){return salla.event.comment.added(t,e.id),t})).catch((function(t){throw salla.event.comment.additionFailed(t,e.id),t}))},a.getCommentPayload=function(e,t){ void 0===t&&(t=false);var a={};if(["id","type","comment","per_page","page","sort"].forEach((function(t){var n=salla.form.getPossibleValue(e,[t]);n&&(a[t]=n);})),!t){var n=e.ids;if(n&&(a.ids=Array.isArray(n)?n:[n]),!a.ids||!a.ids.length)return "Failed to get ids!"}return a.type&&["products","pages","product","page","blogs","blog"].includes(a.type)?(a.type+=["product","page"].includes(a.type)?"s":"",a):"Failed to get type one of:(products, product, page, pages, blog, blogs)!"},a.fetchComments=function(e){if("string"==typeof(e=this.getCommentPayload(e)))return salla.event.comment.fetchFailed(e),salla.api.errorPromise(e);var t={per_page:e.per_page||5,page:e.page||1,type:e.type,ids:e.ids};return e.sort&&(t.sort=e.sort),this.request(["comments"],{params:t},"get").then((function(t){return salla.event.comment.fetched(t,e),t})).catch((function(t){throw salla.event.comment.fetchFailed(t,e),t}))},a.getComments=function(e,t,a,n,r){ void 0===a&&(a=1),void 0===n&&(n=5);var i=Array.isArray(t)?t:[t];return this.fetchComments({ids:i,type:e+"s",page:a,per_page:n,sort:r})},t}(G),Z=function(e){function t(){var t;return (t=e.call(this)||this).namespace="currency",t.endpoints={change:"/",list:"currencies"},t.endpointsMethods={change:"get",list:"get"},t.webEndpoints=["change"],t.after_init(),t}g(t,e);var a=t.prototype;return a.change=function(e){if(!(e=salla.form.getPossibleValue(e.data||e,["currency","code"]))){var t="Can't find currency code!";return salla.currency.event.failed(t),salla.api.errorPromise(t)}return this.request("change",{params:{change_currency:"",currency:e}}).then((function(t){return salla.cookie.set("fresh_summary",1),salla.storage.set("cart",""),salla.currency.event.changed(t,e),t})).catch((function(t){throw salla.currency.event.failed(t,e),t}))},a.list=function(){return this.request("list").then((function(e){return salla.currency.event.fetched(e),e})).catch((function(e){throw salla.currency.event.failedToFetch(e),e}))},t}(G),$=function(e){function t(){var t;return (t=e.call(this)||this).namespace="document",t}return g(t,e),t.prototype.reload=function(){window.location.reload();},t}(G),Y=function(e){function t(){var t;return (t=e.call(this)||this).namespace="rating",t.endpoints={store:"rating/store",products:"rating/products",shipping:"rating/shipping",order:"rating/{order_id}"},t.endpointsMethods={order:"get"},t.after_init(),t}g(t,e);var a=t.prototype;return a.order=function(e){var t="object"==typeof e?e:{},a=salla.form.getPossibleValue((null==e?void 0:e.data)||e,["order_id","id"]);if(!a){var n='There is no "order_id"!';return salla.event.rating.orderNotFetched(n),salla.api.errorPromise(n)}return this.request(["order",a],t).then((function(e){return salla.event.rating.orderFetched(e,a),e})).catch((function(e){throw salla.event.rating.orderNotFetched(e,a),e}))},a.store=function(e){var t;if(!(e=(null==(t=e)?void 0:t.data)||e)){var a='There is no "data"!';return salla.event.rating.storeFailed(a),salla.api.errorPromise(a)}return this.request("store",e).then((function(t){return salla.event.rating.storeRated(t,e),t})).catch((function(t){throw salla.event.rating.storeFailed(t,e),t}))},a.products=function(e){var t;if(!(e=(null==(t=e)?void 0:t.data)||e)){var a='There is no "data"!';return salla.event.rating.productsFailed(a),salla.api.errorPromise(a)}return this.request("products",e).then((function(t){return salla.event.rating.productsRated(t,e),t})).catch((function(t){throw salla.event.rating.productsFailed(t,e),t}))},a.shipping=function(e){var t;if(!(e=(null==(t=e)?void 0:t.data)||e)){var a='There is no "data"!';return salla.event.rating.shippingFailed(a),salla.api.errorPromise(a)}return this.request("shipping",e).then((function(t){return salla.event.rating.shippingRated(t,e),t})).catch((function(t){throw salla.event.rating.shippingFailed(t,e),t}))},t}(G),ee=function(e){function t(){var t;return (t=e.call(this)||this).namespace="wishlist",t.endpoints={add:"products/favorites/{id}",remove:"products/favorites/{id}"},t.endpointsMethods={remove:"delete"},Salla.onReady((function(){var e;"customer.wishlist"===Salla.config.get("page.slug")&&(null!=(e=Salla.storage.getWithTTL("s-utms"))&&e["s-utm-source"]||t.injectSourceIntoRequest());})),t}g(t,e);var a=t.prototype;return a.injectSourceIntoRequest=function(){Salla.api.axios.interceptors.request.use((function(e){return e.headers=f({},e.headers,{"s-utm-source":"wishlist"}),e}),(function(e){return Promise.reject(e)}));},a.toggle=function(e){return salla.storage.get("salla::wishlist",[]).includes(e)?this.remove(e):this.add(e)},a.add=function(e){var t,a,n=this;return salla.config.isGuest()?(salla.wishlist.event.additionFailed(a=salla.lang.get("common.messages.must_login")),salla.error(a),salla.api.errorPromise(a)):(e=salla.form.getPossibleValue((null==(t=e)?void 0:t.data)||e,["product_id","id"]))?this.request(["add",e]).then((function(t){return n.updateWishlistStorage(e),salla.wishlist.event.added(t,e),t})).catch((function(t){throw salla.wishlist.event.additionFailed(t,e),t})):(salla.wishlist.event.additionFailed(a="Failed to get product id!"),salla.api.errorPromise(a))},a.remove=function(e){var t,a,n=this;return salla.config.isGuest()?(salla.wishlist.event.additionFailed(a=salla.lang.get("common.messages.must_login")),salla.error(a),salla.api.errorPromise(a)):(e=salla.form.getPossibleValue((null==(t=e)?void 0:t.data)||e,["product_id","id"]))?this.request(["remove",e]).then((function(t){return n.updateWishlistStorage(e,false),salla.wishlist.event.removed(t,e),t})).catch((function(t){throw salla.wishlist.event.removingFailed(t,e),t})):(salla.wishlist.event.removingFailed(a="Failed to get id!"),salla.api.errorPromise(a))},a.updateWishlistStorage=function(e,t){ void 0===t&&(t=true);var a=salla.storage.get("salla::wishlist",[]);t?a.push(e):a.splice(a.indexOf(e),1),salla.storage.set("salla::wishlist",a);},t}(G),te=function(e){function t(){var t;return (t=e.call(this)||this).namespace="scopes",t.endpoints={get:"scopes",change:"scopes",getProductAvailability:"scopes/availability?product_id={id}"},t.after_init(),t}g(t,e);var a=t.prototype;return a.get=function(){return this.request("scopes",null,"get").then((function(e){return salla.scope.event.fetched(e),e})).catch((function(e){throw salla.scope.event.notFetched(e),e}))},a.change=function(e){return this.request("scopes",e).then((function(e){return salla.scope.event.changeSucceeded(e),e})).catch((function(e){throw salla.scope.event.changeFailed(e),e}))},a.getProductAvailability=function(e){return void 0===e&&(e=null),this.request("scopes/availability?product_id="+e,null,"get").then((function(t){return salla.scope.event.productAvailabilityFetched(t,e),t})).catch((function(e){throw salla.scope.event.productAvailabilityNotFetched(e),e}))},t}(G),ae=function(e){function t(){var t;return (t=e.call(this)||this).namespace="booking",t.endpoints={add:"cart/booking/product/{id}"},t.endpointsMethods={add:"get"},t}return g(t,e),t.prototype.add=async function(e,t){if(void 0===t&&(t=true),!e){var a="Please provide product id.";return salla.booking.event.additionFailed(a),salla.api.errorPromise(a)}return this.request(["add",e]).then((function(e){return salla.booking.event.added(e),t&&"booking"===e.data.redirect.to&&(window.location.href=e.data.redirect.url),e})).catch((function(e){throw salla.booking.event.additionFailed(e),e}))},t}(G),ne=function(e){function t(){var t;return (t=e.call(this)||this).namespace="landing",t.endpoints={getDetails:"landing/{landing_page_id}",createCartFromPage:"landing/{landing_page_id}",breadcrumbs:"breadcrumbs"},t.endpointsMethods={getDetails:"get",breadcrumbs:"get"},t.after_init(),t}g(t,e);var a=t.prototype;return a.getDetails=function(e){if(!e){var t="page landing id not passed";return salla.event.landing.getDetailsFailed(t),salla.api.errorPromise(t)}return this.request(["getDetails",e]).then((function(t){return salla.event.landing.detailsFetched(t,e),t})).catch((function(t){throw salla.event.landing.getDetailsFailed(t,e),t}))},a.createCartFromPage=function(e){if(!e){var t="page landing id not passed";return salla.event.landing.orderCreationFailed(t),salla.api.errorPromise(t)}return salla.config.isGuest()?(salla.auth.api.setAfterLoginEvent("landing::createCartFromPage",e),salla.event.dispatch("login::open"),salla.api.successPromise("")):this.request(["createCartFromPage",e]).then((function(t){return salla.event.landing.orderCreated(t,e).then((function(){return location.href=t.data.url})),t})).catch((function(t){throw salla.event.landing.orderCreationFailed(t,e),t}))},a.fetchBreadcrumbs=function(e){if(!e.page){var t="The 'page' parameter is required for the Breadcrumb API. Please provide a valid 'page' parameter.";return salla.event.landing.breadcrumbFetchFailed(t),salla.api.errorPromise(t)}if("product.single"===e.page&&!e.id&&!e.parent_id){var a="The 'id' and 'parent_id' parameters are required when the 'page' parameter is set to 'product.single'. Please provide valid values for both parameters.";return salla.event.landing.breadcrumbFetchFailed(a),salla.api.errorPromise(a)}if(["product.index","customer.orders.single","product.index.tag","page-single","landing-page","brands.single","blog.single","blog.index.author","blog.index.category","blog.index.tag"].includes(e.page)&&!e.id){var n="The 'id' parameter is required when the 'page' parameter is set to "+e.page+". Please provide valid value for the 'ID' parameter.";return salla.event.landing.breadcrumbFetchFailed(n),salla.api.errorPromise(n)}return this.request("breadcrumbs",{params:e}).then((function(e){return salla.event.landing.breadcrumbFetched(e),e})).catch((function(e){throw salla.event.landing.breadcrumbFetchFailed(e),e}))},t}(G),re=function(e){function t(){var t;return (t=e.call(this)||this).namespace="notifications",t.endpoints={fetch:"notifications"},t.endpointsMethods={fetch:"get"},t.after_init(),t}return g(t,e),t.prototype.fetch=function(e){return this.request(["fetch"],{params:e}).then((function(e){return salla.event.notifications.fetched(e),e})).catch((function(e){throw salla.event.notifications.fetchFailed(e),e}))},t}(G),ie=function(){function e(){var e,t=this;this.inIframe=salla.helpers.isIframe(),salla.event.on("twilight::before.ready",(async function(e){return await t.initiateRequest(e)})),salla.event.on("profile::info.fetched",(function(e){return t.setCurrencyAndLanguage(e)})),salla.event.on("auth::token.fetched",(function(e){salla.storage.set("token",e),t.inIframe&&salla.log("token fetched iframe"),t.inIframe&&salla.cookie.set("s-token",e,60),t.setToken(e);})),salla.event.on("auth::token.invalid",(function(){salla.storage.remove("user"),salla.storage.remove("token");})),this.notifier_handler_disabled=false,this.axios=axios.create({baseURL:Salla.config.get("store.api",Salla.config.get("store.url")),headers:{common:{"X-Requested-With":"XMLHttpRequest","S-SOURCE":"twilight","S-APP-VERSION":(null==(e=Salla)||null==(e=e.versions)?void 0:e.twilight)||"2.0.0","S-APP-OS":"browser","cache-control":"no-cache"}}}),this.axios.interceptors.request.use((function(e){"preview"===Salla.config.get("theme.mode")&&(e.url=Salla.url.addParamToUrl("use_username_url",1,e.url));try{var t=Salla.config.get("swoole",[]),a=new RegExp(t.join("|"),"i");t.length>0&&a.test(e.url)&&(e.headers["s-store-api-version"]="swoole");}catch(e){console.log(e);}return e}),(function(e){return Promise.reject(e)}));}var t=e.prototype;return t.getHeaders=function(){var e=f({},this.axios.defaults.headers.common);return delete e["Content-Type"],e},t.getHeader=function(e){var t;return null==(t=Object.entries(this.getHeaders()).filter((function(t){return t[0].toLowerCase()===e.toLowerCase()}))[0])?void 0:t[1]},t.setHeaders=function(e){var t=this;return Object.entries(e).forEach((function(e){return t.setHeader(e[0],e[1])})),this},t.setHeader=function(e,t){return salla.infiniteScroll.fetchOptions.headers[e]=this.axios.defaults.headers.common[e]=t,this},t.withoutNotifier=async function(e){var t=this;return this.notifier_handler_disabled=true,await e().finally((function(){t.notifier_handler_disabled=false;}))},t.initiateRequest=async function(e){var t,a,n;this.axios.defaults.baseURL=Salla.config.get("store.api",Salla.config.get("store.url")),this.setHeaders(f({"Store-Identifier":Salla.config.get("store.id"),currency:(null==(t=e.user)?void 0:t.currency_code)||"SAR","accept-language":salla.lang.getLocale(),"s-user-id":null==(a=e.user)?void 0:a.id,"s-country":null==(n=e.user)?void 0:n.country_code},e.headers||{}));var r=Salla.config.get("store.scope",Salla.storage.get("scope")),i=new URLSearchParams(window.location.search).get("scope");i&&r&&!Salla.url.is_page("cart")&&(r.id=i,Salla.storage.set("scope",r),Salla.cart.reset()),r&&this.setHeaders({"s-scope-type":r.type,"s-scope-id":r.id});var o=Salla.storage.getWithTTL("s-utms");if(o){var s={};Object.entries(o).forEach((function(e){var t=e[0],a=e[1];s[t]="string"==typeof a&&/[^\x00-\x7F]/.test(a)?encodeURIComponent(a):a;})),this.setHeaders(s);}await this.injectTokenToTheRequests(e),salla.storage.get("affiliate_code")&&this.setHeader("s-affiliate-code",salla.storage.get("affiliate_code"));},t.injectTokenToTheRequests=async function(e){var t,a,n,i=this,o=this.getToken(),s="guest"===(null==(t=e.user)?void 0:t.type),l=parseInt((null==(a=e.user)?void 0:a.id)||0),c=parseInt(salla.storage.get("user.id")||0),u=salla.auth.api.isSessionless(),d=function(e){i.setToken(e),salla.event.emit("api::initiated");},p=async function(){s||u||!l?salla.auth.event.tokenInvalid():(salla.log("Api:: case 1 => current is is guest & web session available"),await salla.auth.api.refresh().then((async function(){await salla.profile.info();})).catch((function(){return salla.auth.event.tokenInvalid()})));};if(!o)return salla.log("Api:: case 1 => current is is guest"),void await p();try{n=jwtDecode(o);}catch(e){return Salla.logger.warn("Failed to decode JWT token",e),void Salla.auth.event.tokenInvalid()}return Date.now()/1e3>n.exp?(salla.log("Api:: case 2 => current user is logged-in and there is a token, but it's expired"),void await p()):(u?parseInt(n.sub)!==c:!c||!l||c!==l||parseInt(n.sub)!==l)?(salla.log("Api:: case 3 => there is a token and user in session/local missing or mismatch"),salla.log("sub:"+n.sub+" userIdInWeb:"+l+" userIdInStorage:"+c+", isSessionless:"+u,n.sub,l,c),this.setHeader("Authorization","Bearer "+o),void await salla.profile.info().then((async function(e){!i.inIframe&&!u&&await salla.auth.api.request("auth/jwt",{callerName:"salla.auth.request.injectTokenToTheRequests"}),d(o);})).catch((function(){salla.log("Api:: case 3 => failed get fresh profile"),i.setHeader("Authorization",null),salla.auth.event.tokenInvalid();}))):(salla.log("Api:: case 4 => current user is logged-in and there is a token, and it's not expired"),void d(o))},t.setToken=function(e){return this.setHeader("Authorization","Bearer "+e),salla.event.emit("api::token.injected",e),this.token=e,this},t.cleanupTokenFromUrl=function(){try{var e=new URL(window.location.href);if(!e.searchParams.has("token"))return;e.searchParams.delete("token"),window.history.replaceState({},document.title,e.toString());}catch(e){Salla.logger.warn("Failed to cleanup token from URL",e);}},t.setCurrencyAndLanguage=function(e){return this.setHeaders({currency:e.data.currency,"accept-language":e.data.language})},t.request=function(e,t,a,n){var r=this;void 0===t&&(t=void 0),void 0===a&&(a="get"),void 0===n&&(n={});var i={endPoint:e,payload:t,method:a,options:n},o="undefined"!=typeof event?event.currentTarget:null,s=false;return "SALLA-BUTTON"===(null==o?void 0:o.tagName)&&(s=true),s&&(null==o||o.load()),this.axios[i.method](i.endPoint,i.payload,i.options).then((function(e){return s&&(null==o||o.stop()),e.data&&e.request&&(e=e.data),r.handleAfterResponseActions(e),e})).catch((function(e){throw s&&(null==o||o.stop()),salla.event.document.requestFailed(i,e),r.handleErrorResponse(e),e}))},t.handleAfterResponseActions=function(e){if(e){var t=e.data,a=e.googleTags,n=void 0===a?null:a,r=t&&t.googleTags?t.googleTags:n;try{dataLayer&&r&&dataLayer.push(r);}catch(e){salla.logger.error(e.message);}this.fireEventsForResponse(e),this.showAlert(e);}},t.fireEventsForResponse=function(e){var t,a,n=(null==e?void 0:e.events)||(null==(t=e.data)?void 0:t.events)||(null==(a=e.error)?void 0:a.events);"string"==typeof n&&(n=JSON.parse(n)),n&&Object.keys(n).forEach((function(e){return salla.event.dispatch(e,n[e])}));},t.handleErrorResponse=function(e){if(e.response&&e.response.data)return e.response.data.error&&e.response.data.error.fields&&!this.notifier_handler_disabled?this.handleInvalidFields(e):this.handleAfterResponseActions(e.response.data)},t.showAlert=function(e){var t,a;if(e&&!this.notifier_handler_disabled)return e.case&&e.msg?salla.notify.fire(e.msg,e.case,e):e.hasOwnProperty("success")&&null!=(t=e.data)&&t.message?salla.notify.fire(null==(a=e.data)?void 0:a.message,e.success?salla.notify.types.success:salla.notify.types.error,e):e.error&&e.error.message&&"FORBIDDEN"!==e.error.message?salla.error(e.error.message,e):void 0},t.handleInvalidFields=function(e){var t=e.response.data.error.fields,a=[];Object.keys(t).forEach((function(e){var n=t[e];Array.isArray(n)?n.forEach((function(e){return a.push(e)})):a.push(n);}));var n=(a.length>1?"* ":"")+a.join("\n* ");salla.error(n,e);},t.isFastRequestsAllowed=function(){return Salla.config.get("fastRequests")},t.promise=function(e,t){return void 0===t&&(t=true),new Promise((function(a,n){return t?a(e):n(e)}))},t.errorPromise=function(e){return this.promise(e,false)},t.successPromise=function(e){return this.promise(e,true)},t.getToken=function(){if(Salla.storage.get("token"))return Salla.storage.get("token");try{var e,t=null==(e=new URLSearchParams(window.location.search))?void 0:e.get("token");if(!t)return;if(3!==t.split(".").length)return;return this.cleanupTokenFromUrl(),t}catch(e){Salla.logger.warn("Failed to extract or validate token from URL",e);}},e}(),oe=function(e){function t(){var t;return (t=e.call(this)||this).namespace="component",t.endpoints={getMenus:"menus/{headOrFoot}?store_id={store}&lang={lang}",reviews:"reviews"},t.endpointsMethods={getMenus:"get",reviews:"get"},t}g(t,e);var a=t.prototype;return a.getMenus=async function(e){return void 0===e&&(e="header"),this.request(["getMenus",e,salla.config.get("store.id"),salla.lang.getLocale()]).then((function(e){return salla.event.component.menuFetched(e),e})).catch((function(e){throw salla.event.component.menuFetchFailed(e),e}))},a.getReviews=async function(e){var t=e.per_page,a=void 0===t?5:t,n=e.type,r=void 0===n?"all":n,i=e.items,o=void 0===i?void 0:i;if(!r){var s="Review type cannot be empty. Please provide one.";return salla.event.component.reviewsFetchFailed(s),salla.api.errorPromise(s)}var l=!o||"string"==typeof o&&"[]"===o||Array.isArray(o)&&!o.length;if(!new Set(["all","store","categories","products","json"]).has(r)){var c="Invalid review type. Please provide a valid type.";return salla.event.component.reviewsFetchFailed(c),salla.api.errorPromise(c)}if("all"!==r&&"store"!==r&&l){var u="Items cannot be empty. Please provide one.";return salla.event.component.reviewsFetchFailed(u),salla.api.errorPromise(u)}if(new Set(["products","categories"]).has(r)&&!Array.isArray(o)){var d="Items value must be an array of "+r+" id for review type of "+r+".";return salla.event.component.reviewsFetchFailed(d),salla.api.errorPromise(d)}return this.request(["reviews"],{params:{per_page:a,type:r,items:o}},"get").then((function(e){return salla.event.component.reviewsFetched(e),e})).catch((function(e){throw salla.event.component.reviewsFetchFailed(e),e}))},t}(G),se=function(e){function t(){var t;return (t=e.call(this)||this).namespace="booking",t.endpoints={fetch:"advertisements"},t.endpointsMethods={fetch:"get"},t}return g(t,e),t.prototype.fetch=async function(e){ void 0===e&&(e=null);var t=e?{page:e}:{};return this.request(["fetch"],{params:t}).then((function(e){return salla.event.advertisement.fetched(e),e})).catch((function(e){throw salla.event.advertisement.fetchFailed(e),e}))},t}(G),le=function(e){function t(){var t;return (t=e.call(this)||this).namespace="navigation",t.endpoints={breadcrumbs:"breadcrumbs"},t.endpointsMethods={breadcrumbs:"get"},t.after_init(),t}return g(t,e),t.prototype.fetchBreadcrumbs=function(e){if(!e.page){var t="The 'page' parameter is required for the Breadcrumb API. Please provide a valid 'page' parameter.";return salla.event.navigation.breadcrumbFetchFailed(t),salla.api.errorPromise(t)}if(["product.single","product.index","customer.orders.single","product.index.tag","page-single","landing-page","brands.single","blog.single","blog.index.author","blog.index.category","blog.index.tag"].includes(e.page)&&!e.id){var a="The 'id' parameter is required when the 'page' parameter is set to "+e.page+". Please provide valid value for the 'ID' parameter.";return salla.event.navigation.breadcrumbFetchFailed(a),salla.api.errorPromise(a)}return this.request("breadcrumbs",{params:e}).then((function(e){return salla.event.navigation.breadcrumbFetched(e),e})).catch((function(e){throw salla.event.navigation.breadcrumbFetchFailed(e),e}))},t}(G),ce=function(e){function t(){var t;return (t=e.call(this)||this).namespace="metadata",t.endpoints={fetchValues:"https://api.salla.dev/store/v1/metadata/values"},t.endpointsMethods={fetchValues:"get"},t}return g(t,e),t.prototype.fetchValues=async function(e,t){if(!e||!t){var a="Please provide entity type and entity ids.";return salla.metadata.event.valueNotFetch(a),salla.api.errorPromise(a)}var n={type:e,entities:Array.isArray(t)?t:[t]};return this.request(this.endpoints.fetchValues,{params:n},"get").then((function(e){return salla.metadata.event.valueFetched(e),e})).catch((function(e){throw salla.metadata.event.valueNotFetch(e),e}))},t}(G),ue=function(e){function t(){var t;return (t=e.call(this)||this).auth=new B,t.cart=new z,t.loyalty=new W,t.order=new Q,t.rating=new Y,t.product=new K,t.profile=new J,t.comment=new X,t.currency=new Z,t.document=new $,t.wishlist=new ee,t.scope=new te,t.booking=new ae,t.landing=new ne,t.notifications=new re,t.component=new oe,t.advertisement=new se,t.navigation=new le,t.metadata=new ce,t}return g(t,e),t.prototype.beaconRequest=function(e,t){var a,n,r,i;if(void 0===t&&(t={}),null==(a=window.navigator)||!a.sendBeacon)return fetch(e,t);var o="string"==typeof(null==(n=t)?void 0:n.body)?null==(r=t)?void 0:r.body:JSON.stringify((null==(i=t)?void 0:i.body)||{}),s=new Blob([o],{type:"application/json"});return Salla.log("Beacon payload size: "+s.size+" bytes (~"+(s.size/1024).toFixed(2)+" KB)"),navigator.sendBeacon(e,s),Promise.resolve(new Response('{"status":"sent_via_beacon"}',{status:200,headers:{"Content-Type":"application/json"}}))},t}(ie),de=function(){function t(t){var a,n;if("ready"!==N$3.status)if(t){var r;if(N$3.config.merge(t),!["salla.sa","salla.group"].includes(location.hostname)||null!=(a=N$3.config.get("store.url"))&&a.includes(location.hostname)||!N$3.config.get("store.username")||N$3.config.set("store.url",window.location.origin+"/"+N$3.config.get("store.username")),(null==t?void 0:t.events)&&N$3.event.dispatchEvents(null==t?void 0:t.events),t._token&&salla.api.setHeader("X-CSRF-TOKEN",t._token),window.self===window.top&&(this.injectMaintenanceAlert(),this.injectThemePreviewAlert()),this.injectTemplateStoreAlert(),this.injectAppInstallAlert(),this.applyContentCopyright(),this.injectEditAlert(),null!=t&&null!=(n=t.user)&&n.language_code)salla.lang.setLocale(null==t||null==(r=t.user)?void 0:r.language_code);salla.lang.loadStoreTranslations(),this.setSallaReady(t),this.afterInit();}else this.setSallaReady(t);else salla.log("Trying to re-initiate Salla, while its status === 'ready'!");}var a=t.prototype;return a.afterInit=function(){N$3.url.is_page("product.single")&&N$3.config.isGuest()&&window.addEventListener("mini-checkout::before-init",(function(t){t.preventDefault(),N$3.event.emit("login::open");}));},a.applyContentCopyright=function(){if(N$3.config.get("store.settings.content_copyright")){["contextmenu","selectstart","copy"].forEach((function(e){document.addEventListener(e,(function(e){(function(e){var t;if(!e)return  false;var a=null==(t=e.tagName)?void 0:t.toLowerCase();return "input"===a||"textarea"===a})(e.target)||e.preventDefault();}));})),document.addEventListener("keydown",(function(e){var t=e.key.toLowerCase();("f12"===t||e.ctrlKey&&e.shiftKey&&["i","j","c"].includes(t)||e.ctrlKey&&"u"===t)&&(e.preventDefault(),e.stopPropagation());}));var t=document.createElement("style");t.textContent="\n            body {\n                -webkit-touch-callout: none;\n                -webkit-user-select: none;\n                -moz-user-select: none;\n                -ms-user-select: none;\n                user-select: none;\n            }\n            input, textarea {\n                -webkit-touch-callout: auto;\n                -webkit-user-select: auto;\n                -moz-user-select: auto;\n                -ms-user-select: auto;\n                user-select: auto;\n            }\n            img {\n                pointer-events: none;\n                -webkit-user-drag: none;\n            }\n        ",document.head.appendChild(t);}},a.injectMaintenanceAlert=function(){salla.config.get("maintenance")&&(document.body.classList.add("has-maintenance-bar"),document.querySelector("salla-maintenance-alert")?salla.logger.warn("salla-maintenance-alert element Existed before!"):salla.lang.onLoaded((function(){return document.body.prepend(document.createElement("salla-maintenance-alert"))})));},a.injectTemplateStoreAlert=function(){salla.config.get("store.template")&&(document.body.classList.add("has-bottom-alert"),document.querySelector("salla-bottom-alert")?salla.logger.warn("salla-bottom-alert element Existed before!"):salla.lang.onLoaded((function(){return document.body.append(document.createElement("salla-bottom-alert"))})));},a.injectAppInstallAlert=function(){salla.config.get("store.app_install_prompt")&&salla.config.get("store.apps")&&!salla.storage.get("app_install_prompt_disabled")&&!salla.config.isMobileApp()&&(document.body.classList.add("has-app-install-alert"),document.querySelector("salla-app-install-alert")?salla.logger.warn("salla-app-install-alert element Existed before!"):salla.lang.onLoaded((function(){return document.body.append(document.createElement("salla-app-install-alert"))})));},a.injectThemePreviewAlert=function(){"preview"===salla.config.get("theme.mode")&&(document.body.classList.add("has-preview-bar"),document.querySelector("#s-theme_preview_bar")?salla.logger.warn("#s-theme_preview_bar element Existed before!"):salla.lang.onLoaded((function(){var e=document.createElement("div");e.id="s-theme_preview_bar",e.setAttribute("style","display: flex; justify-content: space-between; text-align: center; background-color: #232323; color: #fff; padding: 10px; font-size: 0.875rem; line-height: 1.25rem; position: relative;"),e.innerHTML='\n              <div style="display:flex; align-items:center;">\n                <img width="32" src="https://cdn.salla.network/images/logo/logo-light.svg">\n                <span style="margin:0 10px;">'+salla.lang.get("blocks.header.preview_mode")+': <span style="background:rgba(255,255,255,0.25);border-radius:15px; padding:2px 15px 4px">'+salla.config.get("theme.name")+'</span></span>\n              </div>\n              <a href="'+salla.url.get("preview_theme/cancel/preview")+'" style="line-height:32px; width:32px;"><i class="sicon-cancel"></i></a>\n            ',document.body.prepend(e);})));},a.injectEditAlert=function(){var e=salla.config.get("edit");e&&(document.querySelector("#s-edit-alert")?salla.logger.warn("#s-edit-alert element Existed before!"):salla.lang.onLoaded((function(){var t=document.createElement("div");t.id="s-edit-alert",t.innerHTML='\n              <a href="'+e+'" style="display:block; background-color:'+salla.config.get("theme.color.primary","#5cd5c4")+"; color:"+salla.config.get("theme.color.reverse","#fff")+'; padding: 10px; text-align:center; font-size: 0.875rem; line-height: 1.25rem;">\n                <i class="sicon-edit"></i> \n                '+salla.lang.get("pages.products.quick_edit")+"\n              </a>\n            ",document.body.prepend(t);})));},a.handleElementAjaxRequest=function(e,t){var a=this;if(!(t instanceof HTMLFormElement||t instanceof HTMLAnchorElement))return salla.logger.warn("trying to call ajax from non Element!!"),false;e.preventDefault();var n=t.getAjaxFormData(e),r=n.method?n.method.toLowerCase():void 0;salla.api.request(n.url,n.formData,r).then((function(e){return e.data&&e.request&&(e=e.data),salla.api.handleAfterResponseActions(e),a.callAjaxEvent(n.events.success,e,n.formData),e})).catch((function(e){throw salla.api.handleErrorResponse(e),a.callAjaxEvent(n.events.fail,e,n.formData),e}));},a.callAjaxEvent=function(e,t,a){if(e){if(a instanceof FormData){var n={};Array.from(a.entries()).forEach((function(e){n[e[0]]=e[1];})),a=n;}window[e]?window[e](t,a):salla.event.dispatch(e,t,a);}},a.setSallaReady=function(t){this.storeUTMs(),N$3.event.emitAsync("twilight::before.ready",t),N$3.status="ready",N$3.event.dispatch("twilight::initiated",t),window.dispatchEvent(new CustomEvent("twilight::initiated",{detail:t}));},a.storeUTMs=function(){var e={fbclid:"facebook",gad_source:"google",ttclid:"tiktok",twclid:"twitter",scid:"snapchat",sccid:"snapchat"},t=Object.keys(e),a=["utm_source","utm_medium","utm_campaign","utm_term","utm_content"].concat(t),n={},r={};window.location.search.replace("?","").split("&").map((function(e){return e.split("=")})).filter((function(e){var t=e[0];return a.includes(t.toLowerCase())})).forEach((function(e){var t=e[0],a=e[1],r=a||"";try{r=decodeURIComponent(a);}catch(e){console.warn("Failed to decode UTM param:",t,a,e);}n[t.toLowerCase()]=r;}));var i=t.find((function(e){return n[e]}));!n.utm_source&&i&&(n.utm_source=e[i],n.utm_campaign=n.utm_campaign||"Using the CLICKID "+i+" provided by "+n.utm_source,n.utm_term=n.utm_term||i+": "+n[i]),n.utm_source&&(Object.entries(n).filter((function(e){var a=e[0];return !t.includes(a)})).forEach((function(e){var t=e[0],a=e[1];r["s-"+t.replace("_","-")]=a;})),r["s-utm-referrer"]=document.referrer,salla.storage.setWithTTL("s-utms",r,129600),this.logUTMVisitData(r));},a.logUTMVisitData=async function(e){var t=e["s-utm-source"],a=e["s-utm-medium"],n=e["s-utm-campaign"];e&&"affiliate"===t&&a&&n&&fetch(salla.config.get("affiliate.utm_url"),{method:"POST",mode:"cors",headers:{"Content-Type":"application/json","s-utm-source":t,"s-utm-medium":a,"s-utm-campaign":n}}).then((function(e){if(e.ok){var t=new URL(window.location.href),a=window.history.state;t.searchParams.delete("utm_source"),t.searchParams.delete("utm_medium"),t.searchParams.delete("utm_campaign"),window.history.replaceState(a,"",t);}}));},t}(),pe=function(){function e(){var e=this;Salla.onReady((function(){return e.init()}));}var t=e.prototype;return t.init=function(){var e,t=this;if(salla.config.get("store.features",[]).includes("sso-login")){if(window.location.hostname.includes("salla"))return salla.log("SSO is not supported yet for stores without custom domain.");salla.auth.event.onLoggedOut((function(){return new Promise((function(e){var t=document.createElement("iframe");t.style.display="none",t.src=salla.url.get("sso/logout"),document.body.appendChild(t),t.onload=function(){document.body.removeChild(t),e();};}))})),null==(e=document.querySelector("salla-login-modal"))||e.remove(),Salla.event.removeAllListeners("login::open"),Salla.event.prependListener("login::open",(function(){return t.redirect()})),window.addEventListener("mini-checkout::before-init",(function(e){Salla.config.isUser()||(e.preventDefault(),t.redirect());}));}},t.redirect=function(){var e=window.location.pathname+window.location.search,t=window.location.origin+"/sso/login?intended_to="+encodeURIComponent(e);return console.log("Redirecting to:",t),window.location.href=t,true},e}(),he=function(){function e(e){this.item=e[0];}return e.prototype.toSegment=function(){var e,t,a,n;return {event:"Product Added",properties:{cart_id:null==(e=this.item.cart_id)?void 0:e.toString(),product_id:null==(t=this.item.id)?void 0:t.toString(),category:this.item.category,currency:null==(a=Salla.config.currency())?void 0:a.code,name:this.item.name,brand:this.item.brand,variant:null==(n=this.item.variant)?void 0:n.toString(),price:this.item.price,quantity:this.item.quantity,sku:this.item.sku,coupon:this.item.coupon,position:this.item.position,url:this.item.url,image_url:this.item.image_url}}},e.shouldSend=function(){return "customer.wishlist"!==salla.config.get("page.slug")},e}(),fe=function(){function e(e){this.product=e[0];}return e.prototype.toSegment=function(){var e;return {event:"Product Viewed",properties:{product_id:null==(e=this.product.id)?void 0:e.toString(),category:this.product.category,name:this.product.name,brand:this.product.brand,variant:this.product.variant,price:this.product.price,quantity:this.product.quantity,currency:this.product.currency,coupon:this.product.coupon,position:this.product.position,value:this.product.value,sku:this.product.sku,url:this.product.url,image_url:this.product.image_url}}},e}(),ge=function(){function e(e){this.cart=e[0];}return e.prototype.toSegment=function(){var e;return {event:"Cart Viewed",properties:{cart_id:null==(e=this.cart.cart_id)?void 0:e.toString(),products:this.cart.products.map((function(e){var t,a;return {product_id:null==(t=e.id)?void 0:t.toString(),name:e.name,price:e.price,category:e.category,sku:e.sku,position:e.position,url:e.url,image_url:e.image_url,brand:e.brand,currency:null==(a=Salla.config.currency())?void 0:a.code,variant:e.variant,coupon:e.coupon,quantity:e.quantity}}))}}},e}(),ve=function(){function e(e){var t=null==e?void 0:e.nextPage;this.listId=salla.config.get("page.slug"),Salla.config.get("page.id")&&(this.listId+="_"+salla.config.get("page.id")),this.sorts=null;try{if(t){var a=new URL(t).searchParams.get("sort");a&&(this.sorts=[{type:"sort",value:a}]);}e.source&&(this.listId=this.listId+"_"+e.source),e.sourceValue&&(this.listId=this.listId+"_"+(Array.isArray(e.sourceValue)?e.sourceValue.join("_"):e.sourceValue));}catch(e){salla.logger.error(e);}this.products=null==e?void 0:e.data;}return e.prototype.toSegment=function(){return {event:"Product List Viewed",properties:{list_id:this.listId,category:salla.config.get("page.title"),sorts:this.sorts,products:this.products.map((function(e){var t,a,n,r,i,o;return {product_id:e.id,category:null==(t=e.category)?void 0:t.name,currency:null==(a=Salla.config.currency())?void 0:a.code,name:e.name,brand:null==(n=e.brand)?void 0:n.name,variant:null==(r=e.variant)?void 0:r.toString(),coupon:null==(i=e.coupon)?void 0:i.toString(),price:e.price,quantity:Number(e.quantity),sku:e.sku,position:0,url:e.url,image_url:null==(o=e.image)?void 0:o.url}}))}}},e.shouldSend=function(e){return !((null==e?void 0:e.nextPage)||"").includes("filters")&&!["index","customer.wishlist"].includes(salla.config.get("page.slug"))},e}(),me=function(){function e(e){this.query=e;}return e.prototype.toSegment=function(){return {event:"Products Searched",properties:{query:this.query}}},e}(),ye=function(){function e(){this.user=JSON.parse(localStorage.getItem("user"));}return e.prototype.toSegment=function(){var e,t,a,n,r;return {event:"Signed In",properties:{first_name:null==(e=this.user)?void 0:e.first_name,last_name:null==(t=this.user)?void 0:t.last_name,type:null==(a=this.user)?void 0:a.type,mobile:null==(n=this.user)?void 0:n.mobile,email:null==(r=this.user)?void 0:r.email}}},e.shouldSend=function(){return "user"===Salla.config.get("user.type")?!Salla.analytics.history.find((function(e){return "Signed In"===e.eventName})):(Salla.profile.event.onInfoFetched((function(){return Salla.event.emit("Signed In")})),false)},e}(),we=function(e){function t(){return e.apply(this,arguments)||this}return g(t,e),t.prototype.toSegment=function(){var t=e.prototype.toSegment.call(this);return {event:"Signed Up",properties:null==t?void 0:t.properties}},t.shouldSend=function(){return "user"===Salla.config.get("user.type")||(Salla.profile.event.onInfoFetched((function(){return Salla.event.emit("Signed Up")})),false)},t}(ye),Se=function(){function e(){}return e.prototype.toSegment=function(){return {event:"Signed Out",properties:{}}},e}(),be=function(){function e(e){this.item=e[0];}return e.prototype.toSegment=function(){var e,t,a,n,r,i,o,s,l,c,u,d,p,h;return {event:"Product Removed",properties:{cart_id:null==(e=this.item)||null==(e=e.cart_id)?void 0:e.toString(),product_id:null==(t=this.item)||null==(t=t.id)?void 0:t.toString(),category:null==(a=this.item)?void 0:a.category,currency:null==(n=Salla.config.currency())?void 0:n.code,name:null==(r=this.item)?void 0:r.name,brand:null==(i=this.item)?void 0:i.brand,variant:null==(o=this.item)?void 0:o.variant,price:null==(s=this.item)?void 0:s.price,quantity:null==(l=this.item)?void 0:l.quantity,sku:null==(c=this.item)?void 0:c.sku,coupon:null==(u=this.item)?void 0:u.coupon,position:null==(d=this.item)?void 0:d.position,url:null==(p=this.item)?void 0:p.url,image_url:null==(h=this.item)?void 0:h.image_url}}},e}(),_e=function(){function e(e){this.product=e.data.product;}return e.prototype.toSegment=function(){var e,t,a,n;return {event:"Product Added to Wishlist",properties:(n={wishlist_id:salla.config.get("store.id")+"_"+salla.config.get("user.id"),wishlist_name:salla.config.get("store.name"),product_id:null==(e=this.product.id)?void 0:e.toString(),name:this.product.name,brand:this.product.brand,variant:this.product.variant,price:this.product.price,quantity:Math.max(1,Number(this.product.quantity)),sku:this.product.sku||null,position:Number(this.product.position||0),url:this.product.url,image_url:(null==(t=this.product)?void 0:t.image)||null,category:this.product.category,currency:null==(a=Salla.config.currency())?void 0:a.code},n.brand=this.product.brand,n)}},e}(),Fe=function(){function e(e){this.product=e.data.product;}return e.prototype.toSegment=function(){var e,t,a,n;return {event:"Product Removed from Wishlist",properties:(n={wishlist_id:salla.config.get("store.id")+"_"+salla.config.get("user.id"),wishlist_name:salla.config.get("store.name"),product_id:null==(e=this.product.id)?void 0:e.toString(),name:this.product.name,brand:this.product.brand,variant:this.product.variant,price:this.product.price,quantity:Math.max(1,Number(this.product.quantity)),sku:this.product.sku||null,coupon:this.product.coupon||null,position:Number(this.product.position||0),currency:null==(t=Salla.config.currency())?void 0:t.code,url:this.product.url,image_url:(null==(a=this.product)?void 0:a.image)||null,category:this.product.category},n.brand=this.product.brand,n)}},e}(),ke=function(){function e(e){this.details=e[0];}return e.prototype.toSegment=function(){return {event:"Order Completed",properties:this.details}},e}(),Ce=function(){function e(e){this.item=e[0];}return e.prototype.toSegment=function(){var e,t;return {event:"Wishlist Product Added to Cart",properties:{wishlist_id:salla.config.get("store.id")+"_"+salla.config.get("user.id"),wishlist_name:salla.config.get("store.name"),cart_id:null==(e=this.item.cart_id)?void 0:e.toString(),product_id:null==(t=this.item.id)?void 0:t.toString(),category:this.item.category,name:this.item.name,brand:this.item.brand,variant:this.item.variant,price:this.item.price,quantity:this.item.quantity,sku:this.item.sku,coupon:this.item.coupon,position:this.item.position,url:this.item.url,image_url:this.item.image_url}}},e.shouldSend=function(){return "customer.wishlist"===salla.config.get("page.slug")},e}(),Pe=function(){function e(e){this.data=e;}return e.prototype.toSegment=function(){var e,t=(null==(e=Salla.analytics.history.find((function(e){return "Product Viewed"===e.eventName})))?void 0:e.payload)||{};return t.share_via=this.data.share_via,{event:"Product Shared",properties:t}},e.shouldSend=function(){return "product.single"===salla.config.get("page.slug")},e}(),Ae=function(){function e(e){this.details=e;}return e.prototype.toSegment=function(){return {event:"Product Reviewed",properties:this.details}},e.registerEvent=function(){salla.event.rating.onProductsRated((function(e,t){var a=t.products,n=t.order_id;Object.values(a).forEach((function(e){var t;Salla.event.emit("Product Reviewed",{product_id:null==(t=e.product_id)?void 0:t.toString(),review_id:null==n?void 0:n.toString(),review_body:e.comment,rating:e.rating});}));}));},e}(),qe=function(){function e(e){this.promotion=e[0];}return e.prototype.toSegment=function(){var e;return {event:"Promotion Viewed",properties:{promotion_id:null==(e=this.promotion.id)?void 0:e.toString(),creative:this.promotion.creative,name:this.promotion.name,position:this.promotion.position}}},e}(),Ee=function(){function e(e){this.promotion=e[0];}return e.prototype.toSegment=function(){var e;return {event:"Promotion Clicked",properties:{promotion_id:null==(e=this.promotion.id)?void 0:e.toString(),creative:this.promotion.creative,name:this.promotion.name,position:this.promotion.position}}},e}(),Ie=function(){function e(e){this.transaction=e;}var t=e.prototype;return t.getCartId=function(){var e,t;return "cart"===salla.config.get("page.slug")?null==(t=salla.config.get("page.id"))?void 0:t.toString():(null==(e=this.transaction)||null==(e=e.data)||null==(e=e.cart)||null==(e=e.id)?void 0:e.toString())||""},t.toSegment=function(){var e,t;return {event:"Coupon Applied",properties:{cart_id:this.getCartId(),coupon_name:(null==(e=this.transaction)||null==(e=e.data)||null==(e=e.cart)?void 0:e.coupon)||"",discount:(null==(t=this.transaction)||null==(t=t.data)||null==(t=t.cart)?void 0:t.discount)||0,currency:salla.config.get("user.currency")||""}}},e}(),Te=function(){function e(e){this.transaction=e;}var t=e.prototype;return t.getCartId=function(){var e;return "cart"===salla.config.get("page.slug")?null==(e=salla.config.get("page.id"))?void 0:e.toString():""},t.getCouponCode=function(){try{var e,t,a=null==(e=this.transaction.response)||null==(e=e.config)?void 0:e.data;return a?null==(t=JSON.parse(a))?void 0:t.coupon:""}catch(e){return ""}},t.toSegment=function(){var e;return {event:"Coupon Denied",properties:{cart_id:this.getCartId(),coupon_name:this.getCouponCode(),reason:(null==(e=this.transaction.response)||null==(e=e.data)||null==(e=e.error)?void 0:e.message)||"Unknown error"}}},e}(),xe=function(){function e(e){this.transaction=e;}var t=e.prototype;return t.getCartId=function(){var e,t;return "cart"===salla.config.get("page.slug")?null==(t=salla.config.get("page.id"))?void 0:t.toString():(null==(e=this.transaction)||null==(e=e.data)||null==(e=e.cart)||null==(e=e.id)?void 0:e.toString())||""},t.toSegment=function(){var e,t;return {event:"Coupon Removed",properties:{cart_id:this.getCartId(),coupon_name:(null==(e=this.transaction)?void 0:e.coupon)||"",discount:(null==(t=this.transaction)||null==(t=t.data)||null==(t=t.cart)?void 0:t.discount)||0,currency:salla.config.get("user.currency")||""}}},e}(),Le=function(){function e(e){this.details=null==e?void 0:e.data;}return e.prototype.toSegment=function(){var t=this,a=["first_name","last_name","birthday","gender"].filter((function(a){var n,r;return e.user[a]!==(null==(n=t.details)?void 0:n[a])&&(void 0!==e.user[a]||void 0!==(null==(r=t.details)?void 0:r[a]))}));return e.setUser(this.details),{event:"User Profile Updated",properties:{updated_fields:a}}},e.registerEvent=function(){Salla.onReady((function(){salla.url.is_page("customer.profile")&&e.setUser(Salla.config.get("user"));}));},e.setUser=function(t){e.user={first_name:null==t?void 0:t.first_name,last_name:null==t?void 0:t.last_name,gender:null==t?void 0:t.gender,birthday:null==t?void 0:t.birthday,avatar:null==t?void 0:t.avatar};},e.shouldSend=function(){return "user"===Salla.config.get("user.type")},e}();Le.user={};var Re=function(e){function t(t){var a;a=e.call(this,t)||this;var n=(null==t?void 0:t.nextPage)||"";return a.filters=a.extractFilters(n),a}g(t,e);var a=t.prototype;return a.extractFilters=function(e){if(!e)return null;try{var t=new URL(e),a=[];return Array.from(t.searchParams.entries()).forEach((function(e){var t=e[0],n=e[1];if(t.startsWith("filters[")){var r=t.match(/^filters\[(.*?)\]/),i=r?r[1]:t;a.push({type:i,value:n});}})),a.length>0?a:null}catch(e){return console.warn("Error extracting filters from URL:",e),null}},a.toSegment=function(){var t=e.prototype.toSegment.call(this);return {event:"Product List Filtered",properties:f({},null==t?void 0:t.properties,{filters:this.filters})}},t.shouldSend=function(e){return ((null==e?void 0:e.nextPage)||"").includes("filters")},t}(ve),Oe=function(){function e(e){this.cart=e;}return e.prototype.toSegment=function(){var e,t,a,n,r=this;return {event:"Cart Updated",properties:{cart_id:null==(e=this.cart.id)?void 0:e.toString(),value:this.cart.total,revenue:this.cart.sub_total,tax:this.cart.tax_amount,discount:this.cart.total_discount,shipping:this.cart.real_shipping_cost,currency:null==(t=Salla.config.currency())?void 0:t.code,affiliation:null==(a=Salla.storage.getWithTTL("s-utms"))?void 0:a["s-utm-source"],products:null==(n=this.cart.items)?void 0:n.map((function(e){var t,a,n,i,o,s;return {product_id:null==(t=e.product_id)?void 0:t.toString(),name:e.product_name,price:e.product_price,category:null==(a=e.category)?void 0:a.toString(),sku:null==(n=e.product_sku)?void 0:n.toString(),position:e.position,url:e.url,image_url:e.product_image,brand:null==(i=e.brand)?void 0:i.toString(),currency:null==(o=Salla.config.currency())?void 0:o.code,variant:null==(s=e.variant)?void 0:s.toString(),coupon:r.cart.coupon,quantity:e.quantity}}))}}},e.shouldSend=function(){return "cart"===salla.config.get("page.slug")},e}(),je=function(){function e(e){this.scope=e.data;}var t=e.prototype;return t.toSegment=function(){return {event:"Market Selected",properties:f({},this.getScope(this.scope),{prev:this.getScope(Salla.config.get("store.scope"))})}},t.getScope=function(e){var t;return {id:null==(t=(e=e||{}).id)?void 0:t.toString(),country:this.getScopeAttribute(e,"countries"),currency:this.getScopeAttribute(e,"currencies"),locale:this.getScopeAttribute(e,"languages")}},t.getScopeAttribute=function(e,t){return e=e[t],Array.isArray(e)?e[0]:e},e}(),De=function(){function e(){}return e.registerEvents=function(){Object.values(this.events).forEach((function(e){e.forEach((function(e){"function"==typeof e.registerEvent&&e.registerEvent();}));}));},e.transform=function(e,t){try{for(var a,n=h$1(this.events[e]||[]);!(a=n()).done;){var r=a.value;if(r&&("function"!=typeof r.shouldSend||r.shouldSend(t))){var i=new r(t).toSegment();return {event:i.event,properties:i.properties}}}return null}catch(e){return console.error("Failed to transform event:",e),null}},e}();De.events={"Order Completed":[ke],"Product Added":[he,Ce],"Product Removed":[be],"Product Viewed":[fe],"Product Added to Wishlist":[_e],"Product Removed from Wishlist":[Fe],"Cart Viewed":[ge],"Products Searched":[me],"Product List Viewed":[ve],"Product List Filtered":[Re],"Signed Up":[we],"Signed In":[ye],"Signed Out":[Se],"Product Reviewed":[Ae],"Product Shared":[Pe],"Promotion Viewed":[qe],"Promotion Clicked":[Ee],"Coupon Applied":[Ie],"Coupon Removed":[xe],"Coupon Denied":[Te],"User Profile Updated":[Le],"Cart Updated":[Oe],"Market Selected":[je]};var Ue=function(){function e(){var e=this;this.history=[],this.customTrackers=[],this.mappedEvents={"wishlist::added":"Product Added to Wishlist","wishlist::removed":"Product Removed from Wishlist","salla-products-list::products.fetched":["Product List Viewed","Product List Filtered"],"auth::registered":"Signed Up","auth::logged.in":"Signed In","auth::logged.out":"Signed Out","share-element":"Product Shared","promotion::viewed":"Promotion Viewed","promotion::clicked":"Promotion Clicked","cart::coupon.added":"Coupon Applied","cart::coupon.deleted":"Coupon Removed","cart::coupon.addition.failed":"Coupon Denied","profile::updated":"User Profile Updated","cart::updated":"Cart Updated","scope::changed":"Market Selected"},Salla.event.onAny((function(t,a){try{if(Object.keys(e.mappedEvents).includes(t)){var n=e.mappedEvents[t];return void(Array.isArray(n)?n:[n]).forEach((function(e){return Salla.event.emit(e,a)}))}if(!Salla.config.get("jitsu.events",[]).includes(t))return;var r=De.transform(t,a);r&&e.track(r.event,r.properties);}catch(e){Salla.log("Error in analytics event handling:",e);}})),Salla.event.on("twilight::before.ready",(function(t){var a,n,r,o,s;e.debugAnalytics=jitsuAnalytics({host:e.getAnalyticsHost(t),writeKey:"bbLD6Xqr1OKsDJfxZBCy7SJN1RIsrkBp:WEa99iY220v9qX7KiuAlML9ldSFJKW2p",fetch:e.customFetch}),e.debugAnalytics.setContextProperty("library",{twilight:Salla.versions});var l=(null==t?void 0:t.jitsu)||{},c=l.host,u=l.key;if(e.jitsuAnalytics=null,c&&u){var d;if(De.registerEvents(),e.initVisitorData(),e.jitsuAnalytics=jitsuAnalytics({host:e.getAnalyticsHost(t),writeKey:u,cookieCapture:{vsc:"vsc"}}),e.setContext("store_id",null==(a=t.store)?void 0:a.id),e.setContext("version",null==(n=t.jitsu)?void 0:n.version),e.setContext("library",{twilight:Salla.versions}),null!=(r=t.jitsu)&&null!=(r=r.context)&&r.extra&&e.setExtraContext(t.jitsu.context.extra),null!=(o=t.store)&&null!=(o=o.scope)&&o.id)e.setContext("scope",null==(d=t.store)?void 0:d.scope);"user"===(null==t||null==(s=t.user)?void 0:s.type)&&e.setContext("traits",e.getFormattedUser(t.user)),e.registerTracker({name:"DefaultSallaTracker",track:function(t,a){return e.jitsuAnalytics.track(t,a)},page:function(t){return e.jitsuAnalytics.page(t)}});}else salla.log("Jitsu configuration is missing. Analytics will not be tracked.");})),Salla.onReady((function(){var t,a={name:Salla.config.get("page.slug",""),id:null==(t=Salla.config.get("page.id",""))?void 0:t.toString()};e.setContext("page",a),e.page(a);}));}var t=e.prototype;return t.setExtraContext=function(e){var t;null!=e&&null!=(t=e.headers)&&t["s-app-os"]&&(this.setContext("app",{version:e.headers["s-app-os-version"],app_release_tag:e.headers["s-app-version"],platform:e.headers["s-app-os"].toLowerCase()}),delete e.headers["s-app-os"],delete e.headers["s-app-os-version"],delete e.headers["s-app-version"],delete e.headers["s-source"]),this.setContext("system",e);},t.getAnalyticsHost=function(e){var t,a="https://salla.cloud/_app/e";if(null==e||null==(t=e.store)||!t.url)return Salla.log("Error getting store url - no config or store URL provided"),a;var n=e.store.url;try{var r="",i=n;if(/https:\/\/demostore\.salla\.sa/.test(i))return Salla.log("demostore.salla.sa detected, using fallback URL"),a;var o=i.match(/(salla\.sa)\/(?:(ar|en)\/)?((?!ar$|en$)[a-zA-Z0-9.-]+)/);if(o){var s=o[3];if(!s||0===s.trim().length||"ar"===s||"en"===s)return Salla.log("Error: invalid or empty store name in salla.sa URL"),a;r=new URL(i).origin+"/"+s;}else {r=new URL(i).origin;}return r+"/_app/e"}catch(e){return Salla.log("Error getting store url, forwarding to salla.cloud:",e),a}},t.setContext=function(e,t){var a,n;null==(a=this.jitsuAnalytics)||a.setContextProperty(e,t),null==(n=this.debugAnalytics)||n.setContextProperty(e,t);},t.customFetch=function(e,t){var a;return Salla.api.beaconRequest(e+"?writekey="+(null==t||null==(a=t.headers)?void 0:a["X-Write-Key"]),t)},t.track=function(e,t){ void 0===t&&(t={}),t=this.finalPayload(t),this.history.push({action:"track",eventName:e,payload:t}),this.pushEventToCustomTrackers("track",e,t);},t.log=function(e,t){var a;return void 0===t&&(t={}),null==(a=this.debugAnalytics)?void 0:a.track(e,t).catch((function(e){return salla.log("Error tracking event:",e),Promise.reject(e)}))},t.page=function(e){var t,a;void 0===e&&(e={}),(e=this.finalPayload(e)).id=null==(t=e.id||Salla.config.get("page.id",""))?void 0:t.toString(),e.name=e.name||Salla.config.get("page.slug"),e.keywords=e.keywords||(null==(a=document.querySelector("meta[name=keywords]"))?void 0:a.content),e.referrer=e.referrer||document.referrer,this.history.push({action:"page",payload:e}),this.pushEventToCustomTrackers("page",e);},t.finalPayload=function(e){ void 0===e&&(e={});var t=Salla.storage.getWithTTL("s-utms");if(t){var a,n=t["s-utm-campaign"],r=t["s-utm-source"],i=t["s-utm-medium"],o=t["s-utm-term"],s=t["s-utm-content"],l=t["s-utm-referrer"];null==(a=Salla.analytics)||a.setContext("campaign",{name:n,source:r,medium:i,term:o,content:s,referrer:l});}return f({},{},e)},t.registerTracker=function(e){"object"==typeof e?"string"==typeof e.name&&e.name?"function"==typeof e.track?"function"==typeof e.page?this.customTrackers.find((function(t){return t.name===e.name}))?Salla.log("tracker with the same name already exists!"):(this.customTrackers.push(e),this.history.forEach((function(t){return "track"===t.action?e.track(t.eventName,t.payload):"page"===t.action?e.page(t.payload):void 0}))):Salla.log("tracker.page most be a function!"):Salla.log("tracker.track most be a function!"):Salla.log("tracker.name most be a string!"):Salla.log('tracker most be an object {name:"tracker name", track: callback, page: callback}!');},t.pushEventToCustomTrackers=function(e,t,a){var n=this;void 0===a&&(a={});var r="page"===e?[t]:[t,a];return Promise.allSettled(this.customTrackers.map((function(t){return n.pushEventToCustomTracker(t[e],r)}))).then((function(t){return t.filter((function(e){return "rejected"===e.status})).map((function(t){return Salla.log("Error on customTracker to send "+e,t)}))}))},t.pushEventToCustomTracker=function(e,t){try{var a=e.apply(void 0,t);return Promise.resolve(a).catch((function(e){return Promise.reject(e)}))}catch(e){return Promise.reject(e)}},t.getFormattedUser=function(e){return e.phone=e.mobile,e.country=e.country_code,e.language=e.language_code,e.currency=e.currency_code,e},t.initVisitorData=function(){null!=Salla.cookie.get("vsc")||Salla.cookie.set("vsc",""+Date.now(),1);},e}(),Ne=function(){function e(){var e=this;Salla.onReady((function(){return e.init()}));}var t=e.prototype;return t.init=function(){if(!Salla.config.isUser()){var e=new URLSearchParams(window.location.search);if(e.has("intended_to"))try{var t=new URL(e.get("intended_to"));if(t.hostname!==window.location.hostname)return;return this.handleAfterLoginEvent(t)}catch(e){return void console.warn("Invalid URL provided in intended_to parameter")}}},t.handleAfterLoginEvent=function(e){var t="intend::user.logged.in";Salla.event.on(t,(function(){return window.location=e})),Salla.api.auth.setAfterLoginEvent(t),Salla.api.auth.setCanRedirect(false),Salla.event.on("salla-login::ready",(function(){return Salla.event.emit("login::open",{withoutReload:true})}));},e}(),Me=function(){function e(e){var t=this;void 0===e&&(e={}),this.config=f({WHITELIST:[location.hostname,"salla.com","salla.sa","salla.dev","salla.network","salla.group","mtjr.at"],POLL_INTERVAL_MS:500,WHITELIST_PAGES:["customer.orders.single","page-single","blog.single","blog.index"]},e),this.originalMethods={},this.isInitialized=false,Salla.onReady((function(){return t.init()}));}var t=e.prototype;return t.normalizeUrl=function(e){try{return new URL(e,location.href)}catch(e){return null}},t.shouldIgnoreUrl=function(e){if(!e)return  false;var t="string"==typeof e?e:e.href||String(e),a=t.toLowerCase();if(["tel:","mailto:","javascript:"].some((function(e){return a.startsWith(e)})))return  true;try{var n=new URL(t,location.href).hostname.toLowerCase();return ["facebook.com","fb.com","twitter.com","x.com","instagram.com","linkedin.com","youtube.com","youtu.be","tiktok.com","snapchat.com","pinterest.com","whatsapp.com","wa.me","iwtsp.com","telegram.org","t.me","discord.com","discord.gg","reddit.com","tumblr.com","google.com","forms.gle","maps.app.goo.gl","goo.gl","apple.com","smsaexpress.com","aramex.com","aj-ex.com","redboxsa.com","fastcoo-tech.com","express.dhl","najizxpress.net","jtexpress.me","jtexpress-sa.com","tamex.com.sa","aymakan.com.sa","fastlo.com","sls-express.com","logestechs.com","massuul.com","tamara.co","gov.sa","org.sa","stc.com.sa","sa","addtoany.com","wchat.freshchat.com","getbutton.io","heyzine.com","linktr.ee"].some((function(e){return n===e||n.endsWith("."+e)}))}catch(e){return  false}},t.isWhitelisted=function(e){if(!e)return  false;for(var t,a=e.hostname.toLowerCase(),n=h$1(this.config.WHITELIST);!(t=n()).done;){var r=t.value,i=String(r||"").toLowerCase().trim();if(i&&(a===i||a.endsWith("."+i)))return  true}return  false},t.emit=function(e){try{window.__redirectLogs||(window.__redirectLogs=[]),window.__redirectLogs.push(e);try{Salla.analytics.log("redirect",e);}catch(e){}}catch(e){}},t.logRedirect=function(e,t,a){if(!this.shouldIgnoreUrl(t)){var n=this.normalizeUrl(t),r=this.normalizeUrl(location.href),i=this.isWhitelisted(n),o={redirect_source:e,redirect_from:r?r.href:String(location.href),redirect_to:n?n.href:String(t),redirect_host:n?n.hostname:null,redirect_referrer:document.referrer||null,page_slug:Salla.config.get("page.slug"),whitelisted:i,stack:a&&a.stack?String(a.stack):void 0,meta:a||void 0};i||this.emit(o);}},t.hookHistoryAPIs=function(){var e=this;["pushState","replaceState"].forEach((function(t){try{var a=history[t];"function"==typeof a&&(e.originalMethods["history."+t]=a,history[t]=function(){for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];try{var o;e.logRedirect(t,null!=(o=r[2])?o:location.href);}catch(e){}return a.apply(history,r)});}catch(e){}})),window.addEventListener("popstate",(function(){e.logRedirect("popstate",location.href);})),window.addEventListener("hashchange",(function(){e.logRedirect("hashchange",location.href);}));},t.hookLocationMethods=function(){var e=this;try{var t=location.assign.bind(location);this.originalMethods["location.assign"]=t,location.assign=function(a){return e.logRedirect("location.assign",a,{stack:(new Error).stack}),t(a)};}catch(e){}try{var a=location.replace.bind(location);this.originalMethods["location.replace"]=a,location.replace=function(t){return e.logRedirect("location.replace",t,{stack:(new Error).stack}),a(t)};}catch(e){}},t.hookWindowOpen=function(){var e=this;try{var t=window.open;this.originalMethods["window.open"]=t,window.open=function(a){a&&e.logRedirect("window.open",a,{stack:(new Error).stack});for(var n=arguments.length,r=new Array(n>1?n-1:0),i=1;i<n;i++)r[i-1]=arguments[i];return t.apply(window,[a].concat(r))};}catch(e){}},t.setupEventListeners=function(){var e=this;this.handleLinkClick=function(t){var a=t.target&&t.target.closest?t.target.closest("a[href]"):null;if(a){var n=a.getAttribute("href");if(n&&!n.startsWith("#")&&!e.shouldIgnoreUrl(n)){var r=a.getAttribute("target")||"_self";setTimeout((function(){e.logRedirect("link-click",n,{target:r});}),0);}}},document.addEventListener("click",this.handleLinkClick,true),this.handleFormSubmit=function(t){var a=t.target,n=a&&a.getAttribute&&a.getAttribute("action")||location.href,r=(a&&a.method?String(a.method):"GET").toUpperCase();e.logRedirect("form-submit",n,{method:r});},document.addEventListener("submit",this.handleFormSubmit,true);},t.setupPerformanceObserver=function(){var e=this;try{this.performanceObserver=new PerformanceObserver((function(t){for(var a,n=h$1(t.getEntries());!(a=n()).done;){var r=a.value;"navigation"===r.entryType&&e.logRedirect("performance-navigation",location.href,{type:r.type,redirectCount:r.redirectCount});}})),this.performanceObserver.observe({type:"navigation",buffered:true});}catch(e){}},t.init=function(){if(!this.config.WHITELIST_PAGES.includes(Salla.config.get("page.slug"))&&!this.isInitialized){var e=new URL(Salla.config.get("store.url")).hostname.split(".").slice(-2).join(".");this.config.WHITELIST.includes(e)||this.config.WHITELIST.push(e),this.hookHistoryAPIs(),this.hookLocationMethods(),this.hookWindowOpen(),this.setupEventListeners(),this.setupPerformanceObserver(),this.isInitialized=true;}},t.destroy=function(){var e=this;this.isInitialized&&(Object.keys(this.originalMethods).forEach((function(t){var a=t.split("."),n=a[0],r=a[1];"history"===n&&e.originalMethods[t]?history[r]=e.originalMethods[t]:"location"===n&&e.originalMethods[t]?location[r]=e.originalMethods[t]:"window"===n&&"open"===r&&e.originalMethods[t]&&(window.open=e.originalMethods[t]);})),this.handleLinkClick&&document.removeEventListener("click",this.handleLinkClick,true),this.handleFormSubmit&&document.removeEventListener("submit",this.handleFormSubmit,true),this.performanceObserver&&this.performanceObserver.disconnect(),this.isInitialized=false);},e}(),He=function(){function e(){this._store=new Map,this._whitelist=new Map([["salla-add-product-button",new Set(["validate","componentDidLoad"])],["salla-products-list",new Set(["componentDidLoad"])]]),this._componentHistory=new Map;}var t=e.prototype;return t.registerHook=function(e,t,a,n){var r=this;if(void 0===n&&(n={}),!this._isAllowed(e,t))return console.warn('[Hooks] Hook "'+e+":"+t+'" is not allowed'),function(){};var i=0|n.priority,o=!!n.once,s=this._ensureTag(e),l=s.get(t)||[];return l.push({cb:a,p:i,once:o}),l.sort((function(e,t){return t.p-e.p})),s.set(t,l),"componentDidLoad"===t&&this._callForLoadedComponents(e,a),function(){return r.removeHook(e,t,a)}},t.registerHookOnce=function(e,t,a,n){return void 0===n&&(n={}),this.registerHook(e,t,a,f({},n,{once:true}))},t.call=async function(e,t,a){var n=this._store.get(e);if(n){var r=n.get(t);if(r&&0!==r.length)for(var i=0,o=[].concat(r);i<o.length;i++){var s=o[i];try{await s.cb(a);}catch(a){console.warn('[Hooks] "'+e+":"+t+'" callback failed:',a);}s.once&&this.removeHook(e,t,s.cb);}}},t.removeHook=function(e,t,a){var n=this._store.get(e);if(!n)return  false;if(!n.has(t))return  false;if(!a)return n.delete(t),0===n.size&&this._store.delete(e),true;var r=n.get(t),i=r.findIndex((function(e){return e.cb===a}));return i>-1&&(r.splice(i,1),0===r.length&&n.delete(t),0===n.size&&this._store.delete(e),true)},t.clear=function(e){e?this._store.delete(e):this._store.clear();},t.get=function(e,t){var a,n=this._store.get(e);return n&&(null==(a=n.get(t))?void 0:a.map((function(e){return e.cb})))||[]},t._ensureTag=function(e){var t=this._store.get(e);return t||(t=new Map,this._store.set(e,t)),t},t._isAllowed=function(e,t){var a=this._whitelist.get(e);return a?!!a.has(t)||(console.warn('[Hooks] Hook "'+t+'" is not allowed for tag "'+e+'"'),false):(console.warn('[Hooks] Tag "'+e+'" is not in the whitelist'),false)},t.registerComponent=function(e,t){this._componentHistory.has(e)||this._componentHistory.set(e,new Set);var a=this._componentHistory.get(e);if(!a.has(t))return a.add(t),this.call(e,"componentDidLoad",t)},t._callForLoadedComponents=async function(e,t){var a=this._componentHistory.get(e);if(a&&0!==a.size)for(var n,r=h$1(a);!(n=r()).done;){var i=n.value;try{await t(i);}catch(t){console.warn('[Hooks] "'+e.replace(/[^a-zA-Z0-9-_]/g,"")+':componentDidLoad" callback failed:',t);}}},e}();N$3.onInitiated=function(e){return salla.event.once("twilight::initiated",e)},N$3.onReady=N$3.onReady||function(t){return new Promise((function(a){return "ready"===salla.status?a(t?t(salla.config.all()):salla.config.all()):N$3.onInitiated((function(e){return a(t?t(e):e)}))}))},N$3.status="loading",N$3.notify=c,N$3.lang=new V,N$3.form=new H,N$3.infiniteScroll=new M(void 0,salla.event.infiniteScroll),N$3.api=new ue,N$3.sso=new pe,N$3.intend=new Ne,N$3.hooks=new He,["cart","auth","order","scope","rating","comment","loyalty","product","profile","currency","document","wishlist","booking","landing","metadata"].forEach((function(t){return N$3[t]=new u(N$3.api[t],N$3.event[t])})),N$3.call=function(t){for(var a=N$3,n=t.split(".");n.length&&(a=a[n.shift()]););return a},N$3.analytics=new Ue,N$3.init=function(e){return new de(e)},new Me,salla.event.once("twilight::init",salla.init),salla.event.on("twilight::api",(function(e){var t=null==e?void 0:e.events;t&&salla.event.dispatchEvents(t);})),N$3.success=N$3.notify.success,N$3.error=N$3.notify.error,N$3.versions.twilight="2.14.310",window.dispatchEvent(new CustomEvent("salla::created"));

var lazyload_min$1 = {exports: {}};

var lazyload_min = lazyload_min$1.exports;

var hasRequiredLazyload_min;

function requireLazyload_min () {
	if (hasRequiredLazyload_min) return lazyload_min$1.exports;
	hasRequiredLazyload_min = 1;
	(function (module, exports) {
		!function(n,t){module.exports=t();}(lazyload_min,(function(){function n(){return n=Object.assign||function(n){for(var t=1;t<arguments.length;t++){var e=arguments[t];for(var i in e)Object.prototype.hasOwnProperty.call(e,i)&&(n[i]=e[i]);}return n},n.apply(this,arguments)}var t="undefined"!=typeof window,e=t&&!("onscroll"in window)||"undefined"!=typeof navigator&&/(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent),i=t&&"IntersectionObserver"in window,o=t&&"classList"in document.createElement("p"),a=t&&window.devicePixelRatio>1,r={elements_selector:".lazy",container:e||t?document:null,threshold:300,thresholds:null,data_src:"src",data_srcset:"srcset",data_sizes:"sizes",data_bg:"bg",data_bg_hidpi:"bg-hidpi",data_bg_multi:"bg-multi",data_bg_multi_hidpi:"bg-multi-hidpi",data_bg_set:"bg-set",data_poster:"poster",class_applied:"applied",class_loading:"loading",class_loaded:"loaded",class_error:"error",class_entered:"entered",class_exited:"exited",unobserve_completed:true,unobserve_entered:false,cancel_on_exit:true,callback_enter:null,callback_exit:null,callback_applied:null,callback_loading:null,callback_loaded:null,callback_error:null,callback_finish:null,callback_cancel:null,use_native:false,restore_on_error:false},c=function(t){return n({},r,t)},l=function(n,t){var e,i="LazyLoad::Initialized",o=new n(t);try{e=new CustomEvent(i,{detail:{instance:o}});}catch(n){(e=document.createEvent("CustomEvent")).initCustomEvent(i,false,false,{instance:o});}window.dispatchEvent(e);},u="src",s="srcset",d="sizes",f="poster",_="llOriginalAttrs",g="data",v="loading",b="loaded",p="applied",m="error",h="native",E="data-",I="ll-status",y=function(n,t){return n.getAttribute(E+t)},k=function(n){return y(n,I)},w=function(n,t){return function(n,t,e){var i="data-ll-status";null!==e?n.setAttribute(i,e):n.removeAttribute(i);}(n,0,t)},A=function(n){return w(n,null)},L=function(n){return null===k(n)},O=function(n){return k(n)===h},x=[v,b,p,m],C=function(n,t,e,i){n&&"function"==typeof n&&(void 0===i?void 0===e?n(t):n(t,e):n(t,e,i));},N=function(n,t){""!==t&&(o?n.classList.add(t):n.className+=(n.className?" ":"")+t);},M=function(n,t){""!==t&&(o?n.classList.remove(t):n.className=n.className.replace(new RegExp("(^|\\s+)"+t+"(\\s+|$)")," ").replace(/^\s+/,"").replace(/\s+$/,""));},z=function(n){return n.llTempImage},T=function(n,t){if(t){var e=t._observer;e&&e.unobserve(n);}},R=function(n,t){n&&(n.loadingCount+=t);},G=function(n,t){n&&(n.toLoadCount=t);},j=function(n){for(var t,e=[],i=0;t=n.children[i];i+=1)"SOURCE"===t.tagName&&e.push(t);return e},D=function(n,t){var e=n.parentNode;e&&"PICTURE"===e.tagName&&j(e).forEach(t);},H=function(n,t){j(n).forEach(t);},V=[u],F=[u,f],B=[u,s,d],J=[g],P=function(n){return !!n[_]},S=function(n){return n[_]},U=function(n){return delete n[_]},$=function(n,t){if(!P(n)){var e={};t.forEach((function(t){e[t]=n.getAttribute(t);})),n[_]=e;}},q=function(n,t){if(P(n)){var e=S(n);t.forEach((function(t){!function(n,t,e){e?n.setAttribute(t,e):n.removeAttribute(t);}(n,t,e[t]);}));}},K=function(n,t,e){N(n,t.class_applied),w(n,p),e&&(t.unobserve_completed&&T(n,t),C(t.callback_applied,n,e));},Q=function(n,t,e){N(n,t.class_loading),w(n,v),e&&(R(e,1),C(t.callback_loading,n,e));},W=function(n,t,e){e&&n.setAttribute(t,e);},X=function(n,t){W(n,d,y(n,t.data_sizes)),W(n,s,y(n,t.data_srcset)),W(n,u,y(n,t.data_src));},Y={IMG:function(n,t){D(n,(function(n){$(n,B),X(n,t);})),$(n,B),X(n,t);},IFRAME:function(n,t){$(n,V),W(n,u,y(n,t.data_src));},VIDEO:function(n,t){H(n,(function(n){$(n,V),W(n,u,y(n,t.data_src));})),$(n,F),W(n,f,y(n,t.data_poster)),W(n,u,y(n,t.data_src)),n.load();},OBJECT:function(n,t){$(n,J),W(n,g,y(n,t.data_src));}},Z=["IMG","IFRAME","VIDEO","OBJECT"],nn=function(n,t){!t||function(n){return n.loadingCount>0}(t)||function(n){return n.toLoadCount>0}(t)||C(n.callback_finish,t);},tn=function(n,t,e){n.addEventListener(t,e),n.llEvLisnrs[t]=e;},en=function(n,t,e){n.removeEventListener(t,e);},on=function(n){return !!n.llEvLisnrs},an=function(n){if(on(n)){var t=n.llEvLisnrs;for(var e in t){var i=t[e];en(n,e,i);}delete n.llEvLisnrs;}},rn=function(n,t,e){!function(n){delete n.llTempImage;}(n),R(e,-1),function(n){n&&(n.toLoadCount-=1);}(e),M(n,t.class_loading),t.unobserve_completed&&T(n,e);},cn=function(n,t,e){var i=z(n)||n;on(i)||function(n,t,e){on(n)||(n.llEvLisnrs={});var i="VIDEO"===n.tagName?"loadeddata":"load";tn(n,i,t),tn(n,"error",e);}(i,(function(o){!function(n,t,e,i){var o=O(t);rn(t,e,i),N(t,e.class_loaded),w(t,b),C(e.callback_loaded,t,i),o||nn(e,i);}(0,n,t,e),an(i);}),(function(o){!function(n,t,e,i){var o=O(t);rn(t,e,i),N(t,e.class_error),w(t,m),C(e.callback_error,t,i),e.restore_on_error&&q(t,B),o||nn(e,i);}(0,n,t,e),an(i);}));},ln=function(n,t,e){!function(n){return Z.indexOf(n.tagName)>-1}(n)?function(n,t,e){!function(n){n.llTempImage=document.createElement("IMG");}(n),cn(n,t,e),function(n){P(n)||(n[_]={backgroundImage:n.style.backgroundImage});}(n),function(n,t,e){var i=y(n,t.data_bg),o=y(n,t.data_bg_hidpi),r=a&&o?o:i;r&&(n.style.backgroundImage='url("'.concat(r,'")'),z(n).setAttribute(u,r),Q(n,t,e));}(n,t,e),function(n,t,e){var i=y(n,t.data_bg_multi),o=y(n,t.data_bg_multi_hidpi),r=a&&o?o:i;r&&(n.style.backgroundImage=r,K(n,t,e));}(n,t,e),function(n,t,e){var i=y(n,t.data_bg_set);if(i){var o=i.split("|"),a=o.map((function(n){return "image-set(".concat(n,")")}));n.style.backgroundImage=a.join(),""===n.style.backgroundImage&&(a=o.map((function(n){return "-webkit-image-set(".concat(n,")")})),n.style.backgroundImage=a.join()),K(n,t,e);}}(n,t,e);}(n,t,e):function(n,t,e){cn(n,t,e),function(n,t,e){var i=Y[n.tagName];i&&(i(n,t),Q(n,t,e));}(n,t,e);}(n,t,e);},un=function(n){n.removeAttribute(u),n.removeAttribute(s),n.removeAttribute(d);},sn=function(n){D(n,(function(n){q(n,B);})),q(n,B);},dn={IMG:sn,IFRAME:function(n){q(n,V);},VIDEO:function(n){H(n,(function(n){q(n,V);})),q(n,F),n.load();},OBJECT:function(n){q(n,J);}},fn=function(n,t){((function(n){var t=dn[n.tagName];t?t(n):function(n){if(P(n)){var t=S(n);n.style.backgroundImage=t.backgroundImage;}}(n);}))(n),function(n,t){L(n)||O(n)||(M(n,t.class_entered),M(n,t.class_exited),M(n,t.class_applied),M(n,t.class_loading),M(n,t.class_loaded),M(n,t.class_error));}(n,t),A(n),U(n);},_n=["IMG","IFRAME","VIDEO"],gn=function(n){return n.use_native&&"loading"in HTMLImageElement.prototype},vn=function(n,t,e){n.forEach((function(n){return function(n){return n.isIntersecting||n.intersectionRatio>0}(n)?function(n,t,e,i){var o=function(n){return x.indexOf(k(n))>=0}(n);w(n,"entered"),N(n,e.class_entered),M(n,e.class_exited),function(n,t,e){t.unobserve_entered&&T(n,e);}(n,e,i),C(e.callback_enter,n,t,i),o||ln(n,e,i);}(n.target,n,t,e):function(n,t,e,i){L(n)||(N(n,e.class_exited),function(n,t,e,i){e.cancel_on_exit&&function(n){return k(n)===v}(n)&&"IMG"===n.tagName&&(an(n),function(n){D(n,(function(n){un(n);})),un(n);}(n),sn(n),M(n,e.class_loading),R(i,-1),A(n),C(e.callback_cancel,n,t,i));}(n,t,e,i),C(e.callback_exit,n,t,i));}(n.target,n,t,e)}));},bn=function(n){return Array.prototype.slice.call(n)},pn=function(n){return n.container.querySelectorAll(n.elements_selector)},mn=function(n){return function(n){return k(n)===m}(n)},hn=function(n,t){return function(n){return bn(n).filter(L)}(n||pn(t))},En=function(n,e){var o=c(n);this._settings=o,this.loadingCount=0,function(n,t){i&&!gn(n)&&(t._observer=new IntersectionObserver((function(e){vn(e,n,t);}),function(n){return {root:n.container===document?null:n.container,rootMargin:n.thresholds||n.threshold+"px"}}(n)));}(o,this),function(n,e){t&&(e._onlineHandler=function(){!function(n,t){var e;(e=pn(n),bn(e).filter(mn)).forEach((function(t){M(t,n.class_error),A(t);})),t.update();}(n,e);},window.addEventListener("online",e._onlineHandler));}(o,this),this.update(e);};return En.prototype={update:function(n){var t,o,a=this._settings,r=hn(n,a);G(this,r.length),!e&&i?gn(a)?function(n,t,e){n.forEach((function(n){ -1!==_n.indexOf(n.tagName)&&function(n,t,e){n.setAttribute("loading","lazy"),cn(n,t,e),function(n,t){var e=Y[n.tagName];e&&e(n,t);}(n,t),w(n,h);}(n,t,e);})),G(e,0);}(r,a,this):(o=r,function(n){n.disconnect();}(t=this._observer),function(n,t){t.forEach((function(t){n.observe(t);}));}(t,o)):this.loadAll(r);},destroy:function(){this._observer&&this._observer.disconnect(),t&&window.removeEventListener("online",this._onlineHandler),pn(this._settings).forEach((function(n){U(n);})),delete this._observer,delete this._settings,delete this._onlineHandler,delete this.loadingCount,delete this.toLoadCount;},loadAll:function(n){var t=this,e=this._settings;hn(n,e).forEach((function(n){T(n,t),ln(n,e,t);}));},restoreAll:function(){var n=this._settings;pn(n).forEach((function(t){fn(t,n);}));}},En.load=function(n,t){var e=c(t);ln(n,e);},En.resetStatus=function(n){A(n);},t&&function(n,t){if(t)if(t.length)for(var e,i=0;e=t[i];i+=1)l(n,e);else l(n,t);}(En,window.lazyLoadOptions),En})); 
	} (lazyload_min$1));
	return lazyload_min$1.exports;
}

var lazyload_minExports = requireLazyload_min();
var LazyLoad = /*@__PURE__*/getDefaultExportFromCjs(lazyload_minExports);

function appGlobalScript () {
    // Only initialize it one time for the entire application
    if (!document.lazyLoadInstance) {
        document.lazyLoadInstance = new LazyLoad({
            use_native: true, //native not support lazyLoad backgrounds
            // restore_on_error: true,
            // Your custom settings go here
            // callback_finish: () => document.lazyLoadBackgrounds.update(document.querySelectorAll('.lazy[data-bg]:not(.loaded)'))
        });
        document.lazyLoadBackgrounds = new LazyLoad({
            elements_selector: '.lazy[data-bg]:not(.loaded)',
        });
        //native way doesn't load backgrounds
        // document.lazyLoadBackgrounds = new LazyLoad();
    }
    //make sure that lazyLoad will be fired after loading the page too.
    if (document.readyState !== 'complete') {
        document.addEventListener("DOMContentLoaded", () => document.lazyLoadInstance.update());
        document.addEventListener("DOMContentLoaded", () => document.lazyLoadBackgrounds.update());
    }
    // fire it after each load more request;
    // @ts-ignore
    salla.infiniteScroll.event.onAppend(() => {
        document.lazyLoadInstance.update();
        document.lazyLoadBackgrounds.update();
    });
}

const globalScripts = appGlobalScript;
const globalStyles = "";

/*
 Stencil Client Platform v4.35.1 | MIT Licensed | https://stenciljs.com
 */
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/utils/constants.ts
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var PrimitiveType = /* @__PURE__ */ ((PrimitiveType2) => {
  PrimitiveType2["Undefined"] = "undefined";
  PrimitiveType2["Null"] = "null";
  PrimitiveType2["String"] = "string";
  PrimitiveType2["Number"] = "number";
  PrimitiveType2["SpecialNumber"] = "number";
  PrimitiveType2["Boolean"] = "boolean";
  PrimitiveType2["BigInt"] = "bigint";
  return PrimitiveType2;
})(PrimitiveType || {});
var NonPrimitiveType = /* @__PURE__ */ ((NonPrimitiveType2) => {
  NonPrimitiveType2["Array"] = "array";
  NonPrimitiveType2["Date"] = "date";
  NonPrimitiveType2["Map"] = "map";
  NonPrimitiveType2["Object"] = "object";
  NonPrimitiveType2["RegularExpression"] = "regexp";
  NonPrimitiveType2["Set"] = "set";
  NonPrimitiveType2["Channel"] = "channel";
  NonPrimitiveType2["Symbol"] = "symbol";
  return NonPrimitiveType2;
})(NonPrimitiveType || {});
var TYPE_CONSTANT = "type";
var VALUE_CONSTANT = "value";
var SERIALIZED_PREFIX = "serialized:";

// src/client/client-host-ref.ts
var getHostRef = (ref) => {
  if (ref.__stencil__getHostRef) {
    return ref.__stencil__getHostRef();
  }
  return void 0;
};
var registerInstance = (lazyInstance, hostRef) => {
  lazyInstance.__stencil__getHostRef = () => hostRef;
  hostRef.$lazyInstance$ = lazyInstance;
};
var registerHost = (hostElement, cmpMeta) => {
  const hostRef = {
    $flags$: 0,
    $hostElement$: hostElement,
    $cmpMeta$: cmpMeta,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  {
    hostRef.$onInstancePromise$ = new Promise((r) => hostRef.$onInstanceResolve$ = r);
  }
  {
    hostRef.$onReadyPromise$ = new Promise((r) => hostRef.$onReadyResolve$ = r);
    hostElement["s-p"] = [];
    hostElement["s-rc"] = [];
  }
  const ref = hostRef;
  hostElement.__stencil__getHostRef = () => ref;
  return ref;
};
var isMemberInElement = (elm, memberName) => memberName in elm;
var consoleError = (e, el) => (0, console.error)(e, el);

// src/client/client-load-module.ts
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId) => {
  const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
  const bundleId = cmpMeta.$lazyBundleId$;
  if (!bundleId) {
    return void 0;
  }
  const module = cmpModules.get(bundleId) ;
  if (module) {
    return module[exportName];
  }
  
        if (!hmrVersionId || !BUILD.hotModuleReplacement) {
          const processMod = importedModule => {
              cmpModules.set(bundleId, importedModule);
              return importedModule[exportName];
          }
          switch(bundleId) {
              
                case 'salla-advertisement':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-advertisement.entry.js').then(processMod, consoleError);
                case 'salla-app-install-alert':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-app-install-alert.entry.js').then(processMod, consoleError);
                case 'salla-apps-icons':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-apps-icons.entry.js').then(processMod, consoleError);
                case 'salla-custom-fields':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-custom-fields.entry.js').then(processMod, consoleError);
                case 'salla-filters':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-filters.entry.js').then(processMod, consoleError);
                case 'salla-installment':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-installment.entry.js').then(processMod, consoleError);
                case 'salla-loyalty-prize-item':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-loyalty-prize-item.entry.js').then(processMod, consoleError);
                case 'salla-loyalty-program':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-loyalty-program.entry.js').then(processMod, consoleError);
                case 'salla-metadata':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-metadata.entry.js').then(processMod, consoleError);
                case 'salla-notifications':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-notifications.entry.js').then(processMod, consoleError);
                case 'salla-order-details':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-order-details.entry.js').then(processMod, consoleError);
                case 'salla-order-totals-card':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-order-totals-card.entry.js').then(processMod, consoleError);
                case 'salla-orders':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-orders.entry.js').then(processMod, consoleError);
                case 'salla-payments':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-payments.entry.js').then(processMod, consoleError);
                case 'salla-trust-badges':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-trust-badges.entry.js').then(processMod, consoleError);
                case 'salla-wallet':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-wallet.entry.js').then(processMod, consoleError);
                case 'salla-filters-widget':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-filters-widget.entry.js').then(processMod, consoleError);
                case 'salla-notification-item':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-notification-item.entry.js').then(processMod, consoleError);
                case 'salla-order-details-multiple-bundle-product':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-order-details-multiple-bundle-product.entry.js').then(processMod, consoleError);
                case 'salla-tooltip':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-tooltip.entry.js').then(processMod, consoleError);
                case 'salla-conditional-offer':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-conditional-offer.entry.js').then(processMod, consoleError);
                case 'salla-offer':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-offer.entry.js').then(processMod, consoleError);
                case 'salla-reviews':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-reviews.entry.js').then(processMod, consoleError);
                case 'salla-verify':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-verify.entry.js').then(processMod, consoleError);
                case 'salla-order-details-options':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-order-details-options.entry.js').then(processMod, consoleError);
                case 'salla-price-range':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-price-range.entry.js').then(processMod, consoleError);
                case 'salla-cart-item-offers':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-cart-item-offers.entry.js').then(processMod, consoleError);
                case 'salla-contacts':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-contacts.entry.js').then(processMod, consoleError);
                case 'salla-review-card':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-review-card.entry.js').then(processMod, consoleError);
                case 'salla-order-summary':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-order-summary.entry.js').then(processMod, consoleError);
                case 'salla-social':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-social.entry.js').then(processMod, consoleError);
                case 'salla-tiered-offer':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-tiered-offer.entry.js').then(processMod, consoleError);
                case 'salla-reviews-page':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-reviews-page.entry.js').then(processMod, consoleError);
                case 'salla-accordion_62':
                    return import(
                      /* webpackMode: "lazy" */
                      './salla-accordion_62.entry.js').then(processMod, consoleError);
          }
      }
  return import(
    /* @vite-ignore */
    /* webpackInclude: /\.entry\.js$/ */
    /* webpackExclude: /\.system\.entry\.js$/ */
    /* webpackMode: "lazy" */
    `./${bundleId}.entry.js${""}`
  ).then(
    (importedModule) => {
      {
        cmpModules.set(bundleId, importedModule);
      }
      return importedModule[exportName];
    },
    (e) => {
      consoleError(e, hostRef.$hostElement$);
    }
  );
};

// src/client/client-style.ts
var styles = /* @__PURE__ */ new Map();

// src/runtime/runtime-constants.ts
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var COMMENT_NODE_ID = "c";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var HYDRATED_CSS = "{visibility:hidden}.hydrated{visibility:inherit}";
var SLOT_FB_CSS = "slot-fb{display:contents}slot-fb[hidden]{display:none}";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var win = typeof window !== "undefined" ? window : {};
var plt = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (h2) => h2(),
  raf: (h2) => requestAnimationFrame(h2),
  ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),
  rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),
  ce: (eventName, opts) => new CustomEvent(eventName, opts)
};
var supportsListenerOptions = /* @__PURE__ */ (() => {
  var _a;
  let supportsListenerOptions2 = false;
  try {
    (_a = win.document) == null ? void 0 : _a.addEventListener(
      "e",
      null,
      Object.defineProperty({}, "passive", {
        get() {
          supportsListenerOptions2 = true;
        }
      })
    );
  } catch (e) {
  }
  return supportsListenerOptions2;
})();
var promiseResolve = (v) => Promise.resolve(v);
var supportsConstructableStylesheets = /* @__PURE__ */ (() => {
  try {
    new CSSStyleSheet();
    return typeof new CSSStyleSheet().replaceSync === "function";
  } catch (e) {
  }
  return false;
})() ;
var queuePending = false;
var queueDomReads = [];
var queueDomWrites = [];
var queueTask = (queue, write) => (cb) => {
  queue.push(cb);
  if (!queuePending) {
    queuePending = true;
    if (write && plt.$flags$ & 4 /* queueSync */) {
      nextTick(flush);
    } else {
      plt.raf(flush);
    }
  }
};
var consume = (queue) => {
  for (let i2 = 0; i2 < queue.length; i2++) {
    try {
      queue[i2](performance.now());
    } catch (e) {
      consoleError(e);
    }
  }
  queue.length = 0;
};
var flush = () => {
  consume(queueDomReads);
  {
    consume(queueDomWrites);
    if (queuePending = queueDomReads.length > 0) {
      plt.raf(flush);
    }
  }
};
var nextTick = (cb) => promiseResolve().then(cb);
var writeTask = /* @__PURE__ */ queueTask(queueDomWrites, true);
var isComplexType = (o) => {
  o = typeof o;
  return o === "object" || o === "function";
};

// src/utils/query-nonce-meta-tag-content.ts
function queryNonceMetaTagContent(doc) {
  var _a, _b, _c;
  return (_c = (_b = (_a = doc.head) == null ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) == null ? void 0 : _b.getAttribute("content")) != null ? _c : void 0;
}

// src/utils/regular-expression.ts
var escapeRegExpSpecialCharacters = (text) => {
  return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};

// src/utils/remote-value.ts
var RemoteValue = class _RemoteValue {
  /**
   * Deserializes a LocalValue serialized object back to its original JavaScript representation
   *
   * @param serialized The serialized LocalValue object
   * @returns The original JavaScript value/object
   */
  static fromLocalValue(serialized) {
    const type = serialized[TYPE_CONSTANT];
    const value = VALUE_CONSTANT in serialized ? serialized[VALUE_CONSTANT] : void 0;
    switch (type) {
      case "string" /* String */:
        return value;
      case "boolean" /* Boolean */:
        return value;
      case "bigint" /* BigInt */:
        return BigInt(value);
      case "undefined" /* Undefined */:
        return void 0;
      case "null" /* Null */:
        return null;
      case "number" /* Number */:
        if (value === "NaN") return NaN;
        if (value === "-0") return -0;
        if (value === "Infinity") return Infinity;
        if (value === "-Infinity") return -Infinity;
        return value;
      case "array" /* Array */:
        return value.map((item) => _RemoteValue.fromLocalValue(item));
      case "date" /* Date */:
        return new Date(value);
      case "map" /* Map */:
        const map2 = /* @__PURE__ */ new Map();
        for (const [key, val] of value) {
          const deserializedKey = typeof key === "object" && key !== null ? _RemoteValue.fromLocalValue(key) : key;
          const deserializedValue = _RemoteValue.fromLocalValue(val);
          map2.set(deserializedKey, deserializedValue);
        }
        return map2;
      case "object" /* Object */:
        const obj = {};
        for (const [key, val] of value) {
          obj[key] = _RemoteValue.fromLocalValue(val);
        }
        return obj;
      case "regexp" /* RegularExpression */:
        const { pattern, flags } = value;
        return new RegExp(pattern, flags);
      case "set" /* Set */:
        const set = /* @__PURE__ */ new Set();
        for (const item of value) {
          set.add(_RemoteValue.fromLocalValue(item));
        }
        return set;
      case "symbol" /* Symbol */:
        return Symbol(value);
      default:
        throw new Error(`Unsupported type: ${type}`);
    }
  }
  /**
   * Utility method to deserialize multiple LocalValues at once
   *
   * @param serializedValues Array of serialized LocalValue objects
   * @returns Array of deserialized JavaScript values
   */
  static fromLocalValueArray(serializedValues) {
    return serializedValues.map((value) => _RemoteValue.fromLocalValue(value));
  }
  /**
   * Verifies if the given object matches the structure of a serialized LocalValue
   *
   * @param obj Object to verify
   * @returns boolean indicating if the object has LocalValue structure
   */
  static isLocalValueObject(obj) {
    if (typeof obj !== "object" || obj === null) {
      return false;
    }
    if (!obj.hasOwnProperty(TYPE_CONSTANT)) {
      return false;
    }
    const type = obj[TYPE_CONSTANT];
    const hasTypeProperty = Object.values({ ...PrimitiveType, ...NonPrimitiveType }).includes(type);
    if (!hasTypeProperty) {
      return false;
    }
    if (type !== "null" /* Null */ && type !== "undefined" /* Undefined */) {
      return obj.hasOwnProperty(VALUE_CONSTANT);
    }
    return true;
  }
};

// src/utils/result.ts
var result_exports = {};
__export(result_exports, {
  err: () => err,
  map: () => map,
  ok: () => ok,
  unwrap: () => unwrap,
  unwrapErr: () => unwrapErr
});
var ok = (value) => ({
  isOk: true,
  isErr: false,
  value
});
var err = (value) => ({
  isOk: false,
  isErr: true,
  value
});
function map(result, fn) {
  if (result.isOk) {
    const val = fn(result.value);
    if (val instanceof Promise) {
      return val.then((newVal) => ok(newVal));
    } else {
      return ok(val);
    }
  }
  if (result.isErr) {
    const value = result.value;
    return err(value);
  }
  throw "should never get here";
}
var unwrap = (result) => {
  if (result.isOk) {
    return result.value;
  } else {
    throw result.value;
  }
};
var unwrapErr = (result) => {
  if (result.isErr) {
    return result.value;
  } else {
    throw result.value;
  }
};

// src/utils/serialize.ts
function deserializeProperty(value) {
  if (typeof value !== "string" || !value.startsWith(SERIALIZED_PREFIX)) {
    return value;
  }
  return RemoteValue.fromLocalValue(JSON.parse(atob(value.slice(SERIALIZED_PREFIX.length))));
}
function createShadowRoot(cmpMeta) {
  const shadowRoot = this.attachShadow({ mode: "open" });
  if (supportsConstructableStylesheets) {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync(globalStyles);
    shadowRoot.adoptedStyleSheets.push(sheet);
  }
}
var updateFallbackSlotVisibility = (elm) => {
  const childNodes = internalCall(elm, "childNodes");
  if (elm.tagName && elm.tagName.includes("-") && elm["s-cr"] && elm.tagName !== "SLOT-FB") {
    getHostSlotNodes(childNodes, elm.tagName).forEach((slotNode) => {
      if (slotNode.nodeType === 1 /* ElementNode */ && slotNode.tagName === "SLOT-FB") {
        if (getSlotChildSiblings(slotNode, getSlotName(slotNode), false).length) {
          slotNode.hidden = true;
        } else {
          slotNode.hidden = false;
        }
      }
    });
  }
  let i2 = 0;
  for (i2 = 0; i2 < childNodes.length; i2++) {
    const childNode = childNodes[i2];
    if (childNode.nodeType === 1 /* ElementNode */ && internalCall(childNode, "childNodes").length) {
      updateFallbackSlotVisibility(childNode);
    }
  }
};
var getSlottedChildNodes = (childNodes) => {
  const result = [];
  for (let i2 = 0; i2 < childNodes.length; i2++) {
    const slottedNode = childNodes[i2]["s-nr"] || void 0;
    if (slottedNode && slottedNode.isConnected) {
      result.push(slottedNode);
    }
  }
  return result;
};
function getHostSlotNodes(childNodes, hostName, slotName) {
  let i2 = 0;
  let slottedNodes = [];
  let childNode;
  for (; i2 < childNodes.length; i2++) {
    childNode = childNodes[i2];
    if (childNode["s-sr"] && (!hostName || childNode["s-hn"] === hostName) && (slotName === void 0)) {
      slottedNodes.push(childNode);
    }
    slottedNodes = [...slottedNodes, ...getHostSlotNodes(childNode.childNodes, hostName, slotName)];
  }
  return slottedNodes;
}
var getSlotChildSiblings = (slot, slotName, includeSlot = true) => {
  const childNodes = [];
  if (includeSlot && slot["s-sr"] || !slot["s-sr"]) childNodes.push(slot);
  let node = slot;
  while (node = node.nextSibling) {
    if (getSlotName(node) === slotName && (includeSlot || !node["s-sr"])) childNodes.push(node);
  }
  return childNodes;
};
var isNodeLocatedInSlot = (nodeToRelocate, slotName) => {
  if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
    if (nodeToRelocate.getAttribute("slot") === null && slotName === "") {
      return true;
    }
    if (nodeToRelocate.getAttribute("slot") === slotName) {
      return true;
    }
    return false;
  }
  if (nodeToRelocate["s-sn"] === slotName) {
    return true;
  }
  return slotName === "";
};
var addSlotRelocateNode = (newChild, slotNode, prepend, position) => {
  if (newChild["s-ol"] && newChild["s-ol"].isConnected) {
    return;
  }
  const slottedNodeLocation = document.createTextNode("");
  slottedNodeLocation["s-nr"] = newChild;
  if (!slotNode["s-cr"] || !slotNode["s-cr"].parentNode) return;
  const parent = slotNode["s-cr"].parentNode;
  const appendMethod = internalCall(parent, "appendChild");
  if (typeof position !== "undefined") {
    slottedNodeLocation["s-oo"] = position;
    const childNodes = internalCall(parent, "childNodes");
    const slotRelocateNodes = [slottedNodeLocation];
    childNodes.forEach((n) => {
      if (n["s-nr"]) slotRelocateNodes.push(n);
    });
    slotRelocateNodes.sort((a, b) => {
      if (!a["s-oo"] || a["s-oo"] < (b["s-oo"] || 0)) return -1;
      else if (!b["s-oo"] || b["s-oo"] < a["s-oo"]) return 1;
      return 0;
    });
    slotRelocateNodes.forEach((n) => appendMethod.call(parent, n));
  } else {
    appendMethod.call(parent, slottedNodeLocation);
  }
  newChild["s-ol"] = slottedNodeLocation;
  newChild["s-sh"] = slotNode["s-hn"];
};
var getSlotName = (node) => typeof node["s-sn"] === "string" ? node["s-sn"] : node.nodeType === 1 && node.getAttribute("slot") || void 0;
function patchSlotNode(node) {
  if (node.assignedElements || node.assignedNodes || !node["s-sr"]) return;
  const assignedFactory = (elementsOnly) => (function(opts) {
    const toReturn = [];
    const slotName = this["s-sn"];
    if (opts == null ? void 0 : opts.flatten) {
      console.error(`
          Flattening is not supported for Stencil non-shadow slots.
          You can use \`.childNodes\` to nested slot fallback content.
          If you have a particular use case, please open an issue on the Stencil repo.
        `);
    }
    const parent = this["s-cr"].parentElement;
    const slottedNodes = parent.__childNodes ? parent.childNodes : getSlottedChildNodes(parent.childNodes);
    slottedNodes.forEach((n) => {
      if (slotName === getSlotName(n)) {
        toReturn.push(n);
      }
    });
    if (elementsOnly) {
      return toReturn.filter((n) => n.nodeType === 1 /* ElementNode */);
    }
    return toReturn;
  }).bind(node);
  node.assignedElements = assignedFactory(true);
  node.assignedNodes = assignedFactory(false);
}
function internalCall(node, method) {
  if ("__" + method in node) {
    const toReturn = node["__" + method];
    if (typeof toReturn !== "function") return toReturn;
    return toReturn.bind(node);
  } else {
    if (typeof node[method] !== "function") return node[method];
    return node[method].bind(node);
  }
}
var createTime = (fnName, tagName = "") => {
  {
    return () => {
      return;
    };
  }
};
var uniqueTime = (key, measureText) => {
  {
    return () => {
      return;
    };
  }
};
var h = (nodeName, vnodeData, ...children) => {
  let child = null;
  let key = null;
  let slotName = null;
  let simple = false;
  let lastSimple = false;
  const vNodeChildren = [];
  const walk = (c) => {
    for (let i2 = 0; i2 < c.length; i2++) {
      child = c[i2];
      if (Array.isArray(child)) {
        walk(child);
      } else if (child != null && typeof child !== "boolean") {
        if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
          child = String(child);
        }
        if (simple && lastSimple) {
          vNodeChildren[vNodeChildren.length - 1].$text$ += child;
        } else {
          vNodeChildren.push(simple ? newVNode(null, child) : child);
        }
        lastSimple = simple;
      }
    }
  };
  walk(children);
  if (vnodeData) {
    if (vnodeData.key) {
      key = vnodeData.key;
    }
    if (vnodeData.name) {
      slotName = vnodeData.name;
    }
    {
      const classData = vnodeData.className || vnodeData.class;
      if (classData) {
        vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k) => classData[k]).join(" ");
      }
    }
  }
  if (typeof nodeName === "function") {
    return nodeName(
      vnodeData === null ? {} : vnodeData,
      vNodeChildren,
      vdomFnUtils
    );
  }
  const vnode = newVNode(nodeName, null);
  vnode.$attrs$ = vnodeData;
  if (vNodeChildren.length > 0) {
    vnode.$children$ = vNodeChildren;
  }
  {
    vnode.$key$ = key;
  }
  {
    vnode.$name$ = slotName;
  }
  return vnode;
};
var newVNode = (tag, text) => {
  const vnode = {
    $flags$: 0,
    $tag$: tag,
    $text$: text,
    $elm$: null,
    $children$: null
  };
  {
    vnode.$attrs$ = null;
  }
  {
    vnode.$key$ = null;
  }
  {
    vnode.$name$ = null;
  }
  return vnode;
};
var Host = {};
var isHost = (node) => node && node.$tag$ === Host;
var vdomFnUtils = {
  forEach: (children, cb) => children.map(convertToPublic).forEach(cb),
  map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node) => ({
  vattrs: node.$attrs$,
  vchildren: node.$children$,
  vkey: node.$key$,
  vname: node.$name$,
  vtag: node.$tag$,
  vtext: node.$text$
});
var convertToPrivate = (node) => {
  if (typeof node.vtag === "function") {
    const vnodeData = { ...node.vattrs };
    if (node.vkey) {
      vnodeData.key = node.vkey;
    }
    if (node.vname) {
      vnodeData.name = node.vname;
    }
    return h(node.vtag, vnodeData, ...node.vchildren || []);
  }
  const vnode = newVNode(node.vtag, node.vtext);
  vnode.$attrs$ = node.vattrs;
  vnode.$children$ = node.vchildren;
  vnode.$key$ = node.vkey;
  vnode.$name$ = node.vname;
  return vnode;
};

// src/runtime/client-hydrate.ts
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {
  var _a;
  const endHydrate = createTime("hydrateClient", tagName);
  const shadowRoot = hostElm.shadowRoot;
  const childRenderNodes = [];
  const slotNodes = [];
  const slottedNodes = [];
  const shadowRootNodes = shadowRoot ? [] : null;
  const vnode = newVNode(tagName, null);
  vnode.$elm$ = hostElm;
  const members = Object.entries(((_a = hostRef.$cmpMeta$) == null ? void 0 : _a.$members$) || {});
  members.forEach(([memberName, [memberFlags, metaAttributeName]]) => {
    var _b;
    if (!(memberFlags & 31 /* Prop */)) {
      return;
    }
    const attributeName = metaAttributeName || memberName;
    const attrVal = hostElm.getAttribute(attributeName);
    if (attrVal !== null) {
      const attrPropVal = parsePropertyValue(
        attrVal,
        memberFlags);
      (_b = hostRef == null ? void 0 : hostRef.$instanceValues$) == null ? void 0 : _b.set(memberName, attrPropVal);
    }
  });
  if (win.document && (!plt.$orgLocNodes$ || !plt.$orgLocNodes$.size)) {
    initializeDocumentHydrate(win.document.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
  }
  hostElm[HYDRATE_ID] = hostId;
  hostElm.removeAttribute(HYDRATE_ID);
  hostRef.$vnode$ = clientHydrate(
    vnode,
    childRenderNodes,
    slotNodes,
    shadowRootNodes,
    hostElm,
    hostElm,
    hostId,
    slottedNodes
  );
  let crIndex = 0;
  const crLength = childRenderNodes.length;
  let childRenderNode;
  for (crIndex; crIndex < crLength; crIndex++) {
    childRenderNode = childRenderNodes[crIndex];
    const orgLocationId = childRenderNode.$hostId$ + "." + childRenderNode.$nodeId$;
    const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
    const node = childRenderNode.$elm$;
    if (!shadowRoot) {
      node["s-hn"] = tagName.toUpperCase();
      if (childRenderNode.$tag$ === "slot") {
        node["s-cr"] = hostElm["s-cr"];
      }
    }
    if (childRenderNode.$tag$ === "slot") {
      childRenderNode.$name$ = childRenderNode.$elm$["s-sn"] || childRenderNode.$elm$["name"] || null;
      if (childRenderNode.$children$) {
        childRenderNode.$flags$ |= 2 /* isSlotFallback */;
        if (!childRenderNode.$elm$.childNodes.length) {
          childRenderNode.$children$.forEach((c) => {
            childRenderNode.$elm$.appendChild(c.$elm$);
          });
        }
      } else {
        childRenderNode.$flags$ |= 1 /* isSlotReference */;
      }
    }
    if (orgLocationNode && orgLocationNode.isConnected) {
      if (shadowRoot && orgLocationNode["s-en"] === "") {
        orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
      }
      orgLocationNode.parentNode.removeChild(orgLocationNode);
      if (!shadowRoot) {
        node["s-oo"] = parseInt(childRenderNode.$nodeId$);
      }
    }
    plt.$orgLocNodes$.delete(orgLocationId);
  }
  const hosts = [];
  const snLen = slottedNodes.length;
  let snIndex = 0;
  let slotGroup;
  let snGroupIdx;
  let snGroupLen;
  let slottedItem;
  for (snIndex; snIndex < snLen; snIndex++) {
    slotGroup = slottedNodes[snIndex];
    if (!slotGroup || !slotGroup.length) continue;
    snGroupLen = slotGroup.length;
    snGroupIdx = 0;
    for (snGroupIdx; snGroupIdx < snGroupLen; snGroupIdx++) {
      slottedItem = slotGroup[snGroupIdx];
      if (!hosts[slottedItem.hostId]) {
        hosts[slottedItem.hostId] = plt.$orgLocNodes$.get(slottedItem.hostId);
      }
      if (!hosts[slottedItem.hostId]) continue;
      const hostEle = hosts[slottedItem.hostId];
      if (!hostEle.shadowRoot || !shadowRoot) {
        slottedItem.slot["s-cr"] = hostEle["s-cr"];
        if (!slottedItem.slot["s-cr"] && hostEle.shadowRoot) {
          slottedItem.slot["s-cr"] = hostEle;
        } else {
          slottedItem.slot["s-cr"] = (hostEle.__childNodes || hostEle.childNodes)[0];
        }
        addSlotRelocateNode(slottedItem.node, slottedItem.slot, false, slottedItem.node["s-oo"]);
      }
      if (hostEle.shadowRoot && slottedItem.node.parentElement !== hostEle) {
        hostEle.appendChild(slottedItem.node);
      }
    }
  }
  if (shadowRoot && !shadowRoot.childNodes.length) {
    let rnIdex = 0;
    const rnLen = shadowRootNodes.length;
    if (rnLen) {
      for (rnIdex; rnIdex < rnLen; rnIdex++) {
        shadowRoot.appendChild(shadowRootNodes[rnIdex]);
      }
      Array.from(hostElm.childNodes).forEach((node) => {
        if (typeof node["s-en"] !== "string" && typeof node["s-sn"] !== "string") {
          if (node.nodeType === 1 /* ElementNode */ && node.slot && node.hidden) {
            node.removeAttribute("hidden");
          } else if (node.nodeType === 8 /* CommentNode */ || node.nodeType === 3 /* TextNode */ && !node.wholeText.trim()) {
            node.parentNode.removeChild(node);
          }
        }
      });
    }
  }
  plt.$orgLocNodes$.delete(hostElm["s-id"]);
  hostRef.$hostElement$ = hostElm;
  endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId, slottedNodes = []) => {
  let childNodeType;
  let childIdSplt;
  let childVNode;
  let i2;
  if (node.nodeType === 1 /* ElementNode */) {
    childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
    if (childNodeType) {
      childIdSplt = childNodeType.split(".");
      if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
        childVNode = createSimpleVNode({
          $flags$: 0,
          $hostId$: childIdSplt[0],
          $nodeId$: childIdSplt[1],
          $depth$: childIdSplt[2],
          $index$: childIdSplt[3],
          $tag$: node.tagName.toLowerCase(),
          $elm$: node,
          // If we don't add the initial classes to the VNode, the first `vdom-render.ts` patch
          // won't try to reconcile them. Classes set on the node will be blown away.
          $attrs$: { class: node.className || "" }
        });
        childRenderNodes.push(childVNode);
        node.removeAttribute(HYDRATE_CHILD_ID);
        if (!parentVNode.$children$) {
          parentVNode.$children$ = [];
        }
        const slotName = childVNode.$elm$.getAttribute("s-sn");
        if (typeof slotName === "string") {
          if (childVNode.$tag$ === "slot-fb") {
            addSlot(
              slotName,
              childIdSplt[2],
              childVNode,
              node,
              parentVNode,
              childRenderNodes,
              slotNodes,
              shadowRootNodes,
              slottedNodes
            );
          }
          childVNode.$elm$["s-sn"] = slotName;
          childVNode.$elm$.removeAttribute("s-sn");
        }
        if (childVNode.$index$ !== void 0) {
          parentVNode.$children$[childVNode.$index$] = childVNode;
        }
        parentVNode = childVNode;
        if (shadowRootNodes && childVNode.$depth$ === "0") {
          shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
        }
      }
    }
    if (node.shadowRoot) {
      for (i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--) {
        clientHydrate(
          parentVNode,
          childRenderNodes,
          slotNodes,
          shadowRootNodes,
          hostElm,
          node.shadowRoot.childNodes[i2],
          hostId,
          slottedNodes
        );
      }
    }
    const nonShadowNodes = node.__childNodes || node.childNodes;
    for (i2 = nonShadowNodes.length - 1; i2 >= 0; i2--) {
      clientHydrate(
        parentVNode,
        childRenderNodes,
        slotNodes,
        shadowRootNodes,
        hostElm,
        nonShadowNodes[i2],
        hostId,
        slottedNodes
      );
    }
  } else if (node.nodeType === 8 /* CommentNode */) {
    childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
      childNodeType = childIdSplt[0];
      childVNode = createSimpleVNode({
        $hostId$: childIdSplt[1],
        $nodeId$: childIdSplt[2],
        $depth$: childIdSplt[3],
        $index$: childIdSplt[4] || "0",
        $elm$: node,
        $attrs$: null,
        $children$: null,
        $key$: null,
        $name$: null,
        $tag$: null,
        $text$: null
      });
      if (childNodeType === TEXT_NODE_ID) {
        childVNode.$elm$ = findCorrespondingNode(node, 3 /* TextNode */);
        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* TextNode */) {
          childVNode.$text$ = childVNode.$elm$.textContent;
          childRenderNodes.push(childVNode);
          node.remove();
          if (hostId === childVNode.$hostId$) {
            if (!parentVNode.$children$) {
              parentVNode.$children$ = [];
            }
            parentVNode.$children$[childVNode.$index$] = childVNode;
          }
          if (shadowRootNodes && childVNode.$depth$ === "0") {
            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
          }
        }
      } else if (childNodeType === COMMENT_NODE_ID) {
        childVNode.$elm$ = findCorrespondingNode(node, 8 /* CommentNode */);
        if (childVNode.$elm$ && childVNode.$elm$.nodeType === 8 /* CommentNode */) {
          childRenderNodes.push(childVNode);
          node.remove();
        }
      } else if (childVNode.$hostId$ === hostId) {
        if (childNodeType === SLOT_NODE_ID) {
          const slotName = node["s-sn"] = childIdSplt[5] || "";
          addSlot(
            slotName,
            childIdSplt[2],
            childVNode,
            node,
            parentVNode,
            childRenderNodes,
            slotNodes,
            shadowRootNodes,
            slottedNodes
          );
        } else if (childNodeType === CONTENT_REF_ID) {
          if (shadowRootNodes) {
            node.remove();
          } else {
            hostElm["s-cr"] = node;
            node["s-cn"] = true;
          }
        }
      }
    }
  } else if (parentVNode && parentVNode.$tag$ === "style") {
    const vnode = newVNode(null, node.textContent);
    vnode.$elm$ = node;
    vnode.$index$ = "0";
    parentVNode.$children$ = [vnode];
  } else {
    if (node.nodeType === 3 /* TextNode */ && !node.wholeText.trim()) {
      node.remove();
    }
  }
  return parentVNode;
};
var initializeDocumentHydrate = (node, orgLocNodes) => {
  if (node.nodeType === 1 /* ElementNode */) {
    const componentId = node[HYDRATE_ID] || node.getAttribute(HYDRATE_ID);
    if (componentId) {
      orgLocNodes.set(componentId, node);
    }
    let i2 = 0;
    if (node.shadowRoot) {
      for (; i2 < node.shadowRoot.childNodes.length; i2++) {
        initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
      }
    }
    const nonShadowNodes = node.__childNodes || node.childNodes;
    for (i2 = 0; i2 < nonShadowNodes.length; i2++) {
      initializeDocumentHydrate(nonShadowNodes[i2], orgLocNodes);
    }
  } else if (node.nodeType === 8 /* CommentNode */) {
    const childIdSplt = node.nodeValue.split(".");
    if (childIdSplt[0] === ORG_LOCATION_ID) {
      orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
      node.nodeValue = "";
      node["s-en"] = childIdSplt[3];
    }
  }
};
var createSimpleVNode = (vnode) => {
  const defaultVNode = {
    $flags$: 0,
    $hostId$: null,
    $nodeId$: null,
    $depth$: null,
    $index$: "0",
    $elm$: null,
    $attrs$: null,
    $children$: null,
    $key$: null,
    $name$: null,
    $tag$: null,
    $text$: null
  };
  return { ...defaultVNode, ...vnode };
};
function addSlot(slotName, slotId, childVNode, node, parentVNode, childRenderNodes, slotNodes, shadowRootNodes, slottedNodes) {
  node["s-sr"] = true;
  childVNode.$name$ = slotName || null;
  childVNode.$tag$ = "slot";
  const parentNodeId = (parentVNode == null ? void 0 : parentVNode.$elm$) ? parentVNode.$elm$["s-id"] || parentVNode.$elm$.getAttribute("s-id") : "";
  if (shadowRootNodes && win.document) {
    const slot = childVNode.$elm$ = win.document.createElement(childVNode.$tag$);
    if (childVNode.$name$) {
      childVNode.$elm$.setAttribute("name", slotName);
    }
    if (parentNodeId && parentNodeId !== childVNode.$hostId$) {
      parentVNode.$elm$.insertBefore(slot, parentVNode.$elm$.children[0]);
    } else {
      node.parentNode.insertBefore(slot, node);
    }
    addSlottedNodes(slottedNodes, slotId, slotName, node, childVNode.$hostId$);
    node.remove();
    if (childVNode.$depth$ === "0") {
      shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
    }
  } else {
    const slot = childVNode.$elm$;
    const shouldMove = parentNodeId && parentNodeId !== childVNode.$hostId$ && parentVNode.$elm$.shadowRoot;
    addSlottedNodes(slottedNodes, slotId, slotName, node, shouldMove ? parentNodeId : childVNode.$hostId$);
    patchSlotNode(node);
    if (shouldMove) {
      parentVNode.$elm$.insertBefore(slot, parentVNode.$elm$.children[0]);
    }
  }
  childRenderNodes.push(childVNode);
  slotNodes.push(childVNode);
  if (!parentVNode.$children$) {
    parentVNode.$children$ = [];
  }
  parentVNode.$children$[childVNode.$index$] = childVNode;
}
var addSlottedNodes = (slottedNodes, slotNodeId, slotName, slotNode, hostId) => {
  let slottedNode = slotNode.nextSibling;
  slottedNodes[slotNodeId] = slottedNodes[slotNodeId] || [];
  while (slottedNode && ((slottedNode["getAttribute"] && slottedNode.getAttribute("slot") || slottedNode["s-sn"]) === slotName || slotName === "" && !slottedNode["s-sn"] && (slottedNode.nodeType === 8 /* CommentNode */ && slottedNode.nodeValue.indexOf(".") !== 1 || slottedNode.nodeType === 3 /* TextNode */))) {
    slottedNode["s-sn"] = slotName;
    slottedNodes[slotNodeId].push({ slot: slotNode, node: slottedNode, hostId });
    slottedNode = slottedNode.nextSibling;
  }
};
var findCorrespondingNode = (node, type) => {
  let sibling = node;
  do {
    sibling = sibling.nextSibling;
  } while (sibling && (sibling.nodeType !== type || !sibling.nodeValue));
  return sibling;
};
var createSupportsRuleRe = (selector) => {
  const safeSelector2 = escapeRegExpSpecialCharacters(selector);
  return new RegExp(
    // First capture group: match any context before the selector that's not inside @supports selector()
    // Using negative lookahead to avoid matching inside @supports selector(...) condition
    `(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${safeSelector2}))(${safeSelector2}\\b)`,
    "g"
  );
};
createSupportsRuleRe("::slotted");
createSupportsRuleRe(":host");
createSupportsRuleRe(":host-context");
var parsePropertyValue = (propValue, propType, isFormAssociated) => {
  if (typeof propValue === "string" && (propValue.startsWith("{") && propValue.endsWith("}") || propValue.startsWith("[") && propValue.endsWith("]"))) {
    try {
      propValue = JSON.parse(propValue);
      return propValue;
    } catch (e) {
    }
  }
  if (typeof propValue === "string" && propValue.startsWith(SERIALIZED_PREFIX)) {
    propValue = deserializeProperty(propValue);
    return propValue;
  }
  if (propValue != null && !isComplexType(propValue)) {
    if (propType & 4 /* Boolean */) {
      {
        return propValue === "false" ? false : propValue === "" || !!propValue;
      }
    }
    if (propType & 2 /* Number */) {
      return typeof propValue === "string" ? parseFloat(propValue) : typeof propValue === "number" ? propValue : NaN;
    }
    if (propType & 1 /* String */) {
      return String(propValue);
    }
    return propValue;
  }
  return propValue;
};
var getElement = (ref) => getHostRef(ref).$hostElement$ ;

// src/runtime/event-emitter.ts
var createEvent = (ref, name, flags) => {
  const elm = getElement(ref);
  return {
    emit: (detail) => {
      return emitEvent(elm, name, {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail
      });
    }
  };
};
var emitEvent = (elm, name, opts) => {
  const ev = plt.ce(name, opts);
  elm.dispatchEvent(ev);
  return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS) => {
  let style = styles.get(scopeId2);
  if (supportsConstructableStylesheets && allowCS) {
    style = style || new CSSStyleSheet();
    if (typeof style === "string") {
      style = cssText;
    } else {
      style.replaceSync(cssText);
    }
  } else {
    style = cssText;
  }
  styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode) => {
  var _a;
  const scopeId2 = getScopeId(cmpMeta);
  const style = styles.get(scopeId2);
  if (!win.document) {
    return scopeId2;
  }
  styleContainerNode = styleContainerNode.nodeType === 11 /* DocumentFragment */ ? styleContainerNode : win.document;
  if (style) {
    if (typeof style === "string") {
      styleContainerNode = styleContainerNode.head || styleContainerNode;
      let appliedStyles = rootAppliedStyles.get(styleContainerNode);
      let styleElm;
      if (!appliedStyles) {
        rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
      }
      if (!appliedStyles.has(scopeId2)) {
        if (styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
          styleElm.innerHTML = style;
        } else {
          styleElm = win.document.createElement("style");
          styleElm.innerHTML = style;
          const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);
          if (nonce != null) {
            styleElm.setAttribute("nonce", nonce);
          }
          if (!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */)) {
            if (styleContainerNode.nodeName === "HEAD") {
              const preconnectLinks = styleContainerNode.querySelectorAll("link[rel=preconnect]");
              const referenceNode2 = preconnectLinks.length > 0 ? preconnectLinks[preconnectLinks.length - 1].nextSibling : styleContainerNode.querySelector("style");
              styleContainerNode.insertBefore(
                styleElm,
                (referenceNode2 == null ? void 0 : referenceNode2.parentNode) === styleContainerNode ? referenceNode2 : null
              );
            } else if ("host" in styleContainerNode) {
              if (supportsConstructableStylesheets) {
                const stylesheet = new CSSStyleSheet();
                stylesheet.replaceSync(style);
                styleContainerNode.adoptedStyleSheets = [stylesheet, ...styleContainerNode.adoptedStyleSheets];
              } else {
                const existingStyleContainer = styleContainerNode.querySelector("style");
                if (existingStyleContainer) {
                  existingStyleContainer.innerHTML = style + existingStyleContainer.innerHTML;
                } else {
                  styleContainerNode.prepend(styleElm);
                }
              }
            } else {
              styleContainerNode.append(styleElm);
            }
          }
          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
            styleContainerNode.insertBefore(styleElm, null);
          }
        }
        if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {
          styleElm.innerHTML += SLOT_FB_CSS;
        }
        if (appliedStyles) {
          appliedStyles.add(scopeId2);
        }
      }
    } else if (!styleContainerNode.adoptedStyleSheets.includes(style)) {
      styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];
    }
  }
  return scopeId2;
};
var attachStyles = (hostRef) => {
  const cmpMeta = hostRef.$cmpMeta$;
  const elm = hostRef.$hostElement$;
  const flags = cmpMeta.$flags$;
  const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
  const scopeId2 = addStyle(
    elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(),
    cmpMeta);
  if (flags & 10 /* needsScopedEncapsulation */) {
    elm["s-sc"] = scopeId2;
    elm.classList.add(scopeId2 + "-h");
  }
  endAttachStyles();
};
var getScopeId = (cmp, mode) => "sc-" + (cmp.$tagName$);
var convertScopedToShadow = (css) => css.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g, "$1{");
var hydrateScopedToShadow = () => {
  if (!win.document) {
    return;
  }
  const styles2 = win.document.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);
  let i2 = 0;
  for (; i2 < styles2.length; i2++) {
    registerStyle(styles2[i2].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles2[i2].innerHTML), true);
  }
};
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags, initialRender) => {
  if (oldValue === newValue) {
    return;
  }
  let isProp = isMemberInElement(elm, memberName);
  let ln = memberName.toLowerCase();
  if (memberName === "class") {
    const classList = elm.classList;
    const oldClasses = parseClassList(oldValue);
    let newClasses = parseClassList(newValue);
    if (elm["s-si"] && initialRender) {
      newClasses.push(elm["s-si"]);
      oldClasses.forEach((c) => {
        if (c.startsWith(elm["s-si"])) newClasses.push(c);
      });
      newClasses = [...new Set(newClasses)];
      classList.add(...newClasses);
    } else {
      classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));
      classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));
    }
  } else if (memberName === "style") {
    {
      for (const prop in oldValue) {
        if (!newValue || newValue[prop] == null) {
          if (prop.includes("-")) {
            elm.style.removeProperty(prop);
          } else {
            elm.style[prop] = "";
          }
        }
      }
    }
    for (const prop in newValue) {
      if (!oldValue || newValue[prop] !== oldValue[prop]) {
        if (prop.includes("-")) {
          elm.style.setProperty(prop, newValue[prop]);
        } else {
          elm.style[prop] = newValue[prop];
        }
      }
    }
  } else if (memberName === "key") ; else if (memberName === "ref") {
    if (newValue) {
      newValue(elm);
    }
  } else if ((!isProp ) && memberName[0] === "o" && memberName[1] === "n") {
    if (memberName[2] === "-") {
      memberName = memberName.slice(3);
    } else if (isMemberInElement(win, ln)) {
      memberName = ln.slice(2);
    } else {
      memberName = ln[2] + memberName.slice(3);
    }
    if (oldValue || newValue) {
      const capture = memberName.endsWith(CAPTURE_EVENT_SUFFIX);
      memberName = memberName.replace(CAPTURE_EVENT_REGEX, "");
      if (oldValue) {
        plt.rel(elm, memberName, oldValue, capture);
      }
      if (newValue) {
        plt.ael(elm, memberName, newValue, capture);
      }
    }
  } else {
    const isComplex = isComplexType(newValue);
    if ((isProp || isComplex && newValue !== null) && !isSvg) {
      try {
        if (!elm.tagName.includes("-")) {
          const n = newValue == null ? "" : newValue;
          if (memberName === "list") {
            isProp = false;
          } else if (oldValue == null || elm[memberName] != n) {
            if (typeof elm.__lookupSetter__(memberName) === "function") {
              elm[memberName] = n;
            } else {
              elm.setAttribute(memberName, n);
            }
          }
        } else if (elm[memberName] !== newValue) {
          elm[memberName] = newValue;
        }
      } catch (e) {
      }
    }
    let xlink = false;
    {
      if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
        memberName = ln;
        xlink = true;
      }
    }
    if (newValue == null || newValue === false) {
      if (newValue !== false || elm.getAttribute(memberName) === "") {
        if (xlink) {
          elm.removeAttributeNS(XLINK_NS, memberName);
        } else {
          elm.removeAttribute(memberName);
        }
      }
    } else if ((!isProp || flags & 4 /* isHost */ || isSvg) && !isComplex && elm.nodeType === 1 /* ElementNode */) {
      newValue = newValue === true ? "" : newValue;
      if (xlink) {
        elm.setAttributeNS(XLINK_NS, memberName, newValue);
      } else {
        elm.setAttribute(memberName, newValue);
      }
    }
  }
};
var parseClassListRegex = /\s/;
var parseClassList = (value) => {
  if (typeof value === "object" && value && "baseVal" in value) {
    value = value.baseVal;
  }
  if (!value || typeof value !== "string") {
    return [];
  }
  return value.split(parseClassListRegex);
};
var CAPTURE_EVENT_SUFFIX = "Capture";
var CAPTURE_EVENT_REGEX = new RegExp(CAPTURE_EVENT_SUFFIX + "$");

// src/runtime/vdom/update-element.ts
var updateElement = (oldVnode, newVnode, isSvgMode2, isInitialRender) => {
  const elm = newVnode.$elm$.nodeType === 11 /* DocumentFragment */ && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
  const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || {};
  const newVnodeAttrs = newVnode.$attrs$ || {};
  {
    for (const memberName of sortedAttrNames(Object.keys(oldVnodeAttrs))) {
      if (!(memberName in newVnodeAttrs)) {
        setAccessor(
          elm,
          memberName,
          oldVnodeAttrs[memberName],
          void 0,
          isSvgMode2,
          newVnode.$flags$,
          isInitialRender
        );
      }
    }
  }
  for (const memberName of sortedAttrNames(Object.keys(newVnodeAttrs))) {
    setAccessor(
      elm,
      memberName,
      oldVnodeAttrs[memberName],
      newVnodeAttrs[memberName],
      isSvgMode2,
      newVnode.$flags$,
      isInitialRender
    );
  }
};
function sortedAttrNames(attrNames) {
  return attrNames.includes("ref") ? (
    // we need to sort these to ensure that `'ref'` is the last attr
    [...attrNames.filter((attr) => attr !== "ref"), "ref"]
  ) : (
    // no need to sort, return the original array
    attrNames
  );
}
var contentRef;
var hostTagName;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var createElm = (oldParentVNode, newParentVNode, childIndex) => {
  var _a;
  const newVNode2 = newParentVNode.$children$[childIndex];
  let i2 = 0;
  let elm;
  let childNode;
  let oldVNode;
  if (!useNativeShadowDom) {
    checkSlotRelocate = true;
    if (newVNode2.$tag$ === "slot") {
      newVNode2.$flags$ |= newVNode2.$children$ ? (
        // slot element has fallback content
        // still create an element that "mocks" the slot element
        2 /* isSlotFallback */
      ) : (
        // slot element does not have fallback content
        // create an html comment we'll use to always reference
        // where actual slot content should sit next to
        1 /* isSlotReference */
      );
    }
  }
  if (newVNode2.$text$ !== null) {
    elm = newVNode2.$elm$ = win.document.createTextNode(newVNode2.$text$);
  } else if (newVNode2.$flags$ & 1 /* isSlotReference */) {
    elm = newVNode2.$elm$ = win.document.createTextNode("");
    {
      updateElement(null, newVNode2, isSvgMode);
    }
  } else {
    if (!isSvgMode) {
      isSvgMode = newVNode2.$tag$ === "svg";
    }
    if (!win.document) {
      throw new Error(
        "You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component."
      );
    }
    elm = newVNode2.$elm$ = win.document.createElementNS(
      isSvgMode ? SVG_NS : HTML_NS,
      !useNativeShadowDom && BUILD.slotRelocation && newVNode2.$flags$ & 2 /* isSlotFallback */ ? "slot-fb" : newVNode2.$tag$
    ) ;
    if (isSvgMode && newVNode2.$tag$ === "foreignObject") {
      isSvgMode = false;
    }
    {
      updateElement(null, newVNode2, isSvgMode);
    }
    if (newVNode2.$children$) {
      for (i2 = 0; i2 < newVNode2.$children$.length; ++i2) {
        childNode = createElm(oldParentVNode, newVNode2, i2);
        if (childNode) {
          elm.appendChild(childNode);
        }
      }
    }
    {
      if (newVNode2.$tag$ === "svg") {
        isSvgMode = false;
      } else if (elm.tagName === "foreignObject") {
        isSvgMode = true;
      }
    }
  }
  elm["s-hn"] = hostTagName;
  {
    if (newVNode2.$flags$ & (2 /* isSlotFallback */ | 1 /* isSlotReference */)) {
      elm["s-sr"] = true;
      elm["s-cr"] = contentRef;
      elm["s-sn"] = newVNode2.$name$ || "";
      elm["s-rf"] = (_a = newVNode2.$attrs$) == null ? void 0 : _a.ref;
      patchSlotNode(elm);
      oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
      if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
        {
          putBackInOriginalLocation(oldParentVNode.$elm$, false);
        }
      }
    }
  }
  return elm;
};
var putBackInOriginalLocation = (parentElm, recursive) => {
  plt.$flags$ |= 1 /* isTmpDisconnected */;
  const oldSlotChildNodes = Array.from(parentElm.__childNodes || parentElm.childNodes);
  for (let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--) {
    const childNode = oldSlotChildNodes[i2];
    if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
      insertBefore(referenceNode(childNode).parentNode, childNode, referenceNode(childNode));
      childNode["s-ol"].remove();
      childNode["s-ol"] = void 0;
      childNode["s-sh"] = void 0;
      checkSlotRelocate = true;
    }
    if (recursive) {
      putBackInOriginalLocation(childNode, recursive);
    }
  }
  plt.$flags$ &= -2 /* isTmpDisconnected */;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {
  let containerElm = parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
  let childNode;
  if (containerElm.shadowRoot && containerElm.tagName === hostTagName) {
    containerElm = containerElm.shadowRoot;
  }
  for (; startIdx <= endIdx; ++startIdx) {
    if (vnodes[startIdx]) {
      childNode = createElm(null, parentVNode, startIdx);
      if (childNode) {
        vnodes[startIdx].$elm$ = childNode;
        insertBefore(containerElm, childNode, referenceNode(before) );
      }
    }
  }
};
var removeVnodes = (vnodes, startIdx, endIdx) => {
  for (let index = startIdx; index <= endIdx; ++index) {
    const vnode = vnodes[index];
    if (vnode) {
      const elm = vnode.$elm$;
      nullifyVNodeRefs(vnode);
      if (elm) {
        {
          checkSlotFallbackVisibility = true;
          if (elm["s-ol"]) {
            elm["s-ol"].remove();
          } else {
            putBackInOriginalLocation(elm, true);
          }
        }
        elm.remove();
      }
    }
  }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh, isInitialRender = false) => {
  let oldStartIdx = 0;
  let newStartIdx = 0;
  let idxInOld = 0;
  let i2 = 0;
  let oldEndIdx = oldCh.length - 1;
  let oldStartVnode = oldCh[0];
  let oldEndVnode = oldCh[oldEndIdx];
  let newEndIdx = newCh.length - 1;
  let newStartVnode = newCh[0];
  let newEndVnode = newCh[newEndIdx];
  let node;
  let elmToMove;
  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx];
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx];
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx];
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newStartVnode, isInitialRender)) {
      patch(oldStartVnode, newStartVnode, isInitialRender);
      oldStartVnode = oldCh[++oldStartIdx];
      newStartVnode = newCh[++newStartIdx];
    } else if (isSameVnode(oldEndVnode, newEndVnode, isInitialRender)) {
      patch(oldEndVnode, newEndVnode, isInitialRender);
      oldEndVnode = oldCh[--oldEndIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldStartVnode, newEndVnode, isInitialRender)) {
      if ((oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
      }
      patch(oldStartVnode, newEndVnode, isInitialRender);
      insertBefore(parentElm, oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
      oldStartVnode = oldCh[++oldStartIdx];
      newEndVnode = newCh[--newEndIdx];
    } else if (isSameVnode(oldEndVnode, newStartVnode, isInitialRender)) {
      if ((oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
        putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
      }
      patch(oldEndVnode, newStartVnode, isInitialRender);
      insertBefore(parentElm, oldEndVnode.$elm$, oldStartVnode.$elm$);
      oldEndVnode = oldCh[--oldEndIdx];
      newStartVnode = newCh[++newStartIdx];
    } else {
      idxInOld = -1;
      {
        for (i2 = oldStartIdx; i2 <= oldEndIdx; ++i2) {
          if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
            idxInOld = i2;
            break;
          }
        }
      }
      if (idxInOld >= 0) {
        elmToMove = oldCh[idxInOld];
        if (elmToMove.$tag$ !== newStartVnode.$tag$) {
          node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld);
        } else {
          patch(elmToMove, newStartVnode, isInitialRender);
          oldCh[idxInOld] = void 0;
          node = elmToMove.$elm$;
        }
        newStartVnode = newCh[++newStartIdx];
      } else {
        node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx);
        newStartVnode = newCh[++newStartIdx];
      }
      if (node) {
        {
          insertBefore(
            referenceNode(oldStartVnode.$elm$).parentNode,
            node,
            referenceNode(oldStartVnode.$elm$)
          );
        }
      }
    }
  }
  if (oldStartIdx > oldEndIdx) {
    addVnodes(
      parentElm,
      newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$,
      newVNode2,
      newCh,
      newStartIdx,
      newEndIdx
    );
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx);
  }
};
var isSameVnode = (leftVNode, rightVNode, isInitialRender = false) => {
  if (leftVNode.$tag$ === rightVNode.$tag$) {
    if (leftVNode.$tag$ === "slot") {
      return leftVNode.$name$ === rightVNode.$name$;
    }
    if (!isInitialRender) {
      return leftVNode.$key$ === rightVNode.$key$;
    }
    if (isInitialRender && !leftVNode.$key$ && rightVNode.$key$) {
      leftVNode.$key$ = rightVNode.$key$;
    }
    return true;
  }
  return false;
};
var referenceNode = (node) => node && node["s-ol"] || node;
var patch = (oldVNode, newVNode2, isInitialRender = false) => {
  const elm = newVNode2.$elm$ = oldVNode.$elm$;
  const oldChildren = oldVNode.$children$;
  const newChildren = newVNode2.$children$;
  const tag = newVNode2.$tag$;
  const text = newVNode2.$text$;
  let defaultHolder;
  if (text === null) {
    {
      isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
    }
    {
      updateElement(oldVNode, newVNode2, isSvgMode, isInitialRender);
    }
    if (oldChildren !== null && newChildren !== null) {
      updateChildren(elm, oldChildren, newVNode2, newChildren, isInitialRender);
    } else if (newChildren !== null) {
      if (oldVNode.$text$ !== null) {
        elm.textContent = "";
      }
      addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
    } else if (
      // don't do this on initial render as it can cause non-hydrated content to be removed
      !isInitialRender && BUILD.updatable && oldChildren !== null
    ) {
      removeVnodes(oldChildren, 0, oldChildren.length - 1);
    }
    if (isSvgMode && tag === "svg") {
      isSvgMode = false;
    }
  } else if ((defaultHolder = elm["s-cr"])) {
    defaultHolder.parentNode.textContent = text;
  } else if (oldVNode.$text$ !== text) {
    elm.data = text;
  }
};
var relocateNodes = [];
var markSlotContentForRelocation = (elm) => {
  let node;
  let hostContentNodes;
  let j;
  const children = elm.__childNodes || elm.childNodes;
  for (const childNode of children) {
    if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
      hostContentNodes = node.parentNode.__childNodes || node.parentNode.childNodes;
      const slotName = childNode["s-sn"];
      for (j = hostContentNodes.length - 1; j >= 0; j--) {
        node = hostContentNodes[j];
        if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"] && (true)) {
          if (isNodeLocatedInSlot(node, slotName)) {
            let relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
            checkSlotFallbackVisibility = true;
            node["s-sn"] = node["s-sn"] || slotName;
            if (relocateNodeData) {
              relocateNodeData.$nodeToRelocate$["s-sh"] = childNode["s-hn"];
              relocateNodeData.$slotRefNode$ = childNode;
            } else {
              node["s-sh"] = childNode["s-hn"];
              relocateNodes.push({
                $slotRefNode$: childNode,
                $nodeToRelocate$: node
              });
            }
            if (node["s-sr"]) {
              relocateNodes.map((relocateNode) => {
                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                  relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);
                  if (relocateNodeData && !relocateNode.$slotRefNode$) {
                    relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                  }
                }
              });
            }
          } else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {
            relocateNodes.push({
              $nodeToRelocate$: node
            });
          }
        }
      }
    }
    if (childNode.nodeType === 1 /* ElementNode */) {
      markSlotContentForRelocation(childNode);
    }
  }
};
var nullifyVNodeRefs = (vNode) => {
  {
    vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
    vNode.$children$ && vNode.$children$.map(nullifyVNodeRefs);
  }
};
var insertBefore = (parent, newNode, reference) => {
  {
    return parent == null ? void 0 : parent.insertBefore(newNode, reference);
  }
};
var renderVdom = (hostRef, renderFnResults, isInitialLoad = false) => {
  var _a, _b, _c, _d;
  const hostElm = hostRef.$hostElement$;
  const cmpMeta = hostRef.$cmpMeta$;
  const oldVNode = hostRef.$vnode$ || newVNode(null, null);
  const isHostElement = isHost(renderFnResults);
  const rootVnode = isHostElement ? renderFnResults : h(null, null, renderFnResults);
  hostTagName = hostElm.tagName;
  if (cmpMeta.$attrsToReflect$) {
    rootVnode.$attrs$ = rootVnode.$attrs$ || {};
    cmpMeta.$attrsToReflect$.map(
      ([propName, attribute]) => rootVnode.$attrs$[attribute] = hostElm[propName]
    );
  }
  if (isInitialLoad && rootVnode.$attrs$) {
    for (const key of Object.keys(rootVnode.$attrs$)) {
      if (hostElm.hasAttribute(key) && !["key", "ref", "style", "class"].includes(key)) {
        rootVnode.$attrs$[key] = hostElm[key];
      }
    }
  }
  rootVnode.$tag$ = null;
  rootVnode.$flags$ |= 4 /* isHost */;
  hostRef.$vnode$ = rootVnode;
  rootVnode.$elm$ = oldVNode.$elm$ = hostElm.shadowRoot || hostElm ;
  useNativeShadowDom = !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) && !(cmpMeta.$flags$ & 128 /* shadowNeedsScopedCss */);
  {
    contentRef = hostElm["s-cr"];
    checkSlotFallbackVisibility = false;
  }
  patch(oldVNode, rootVnode, isInitialLoad);
  {
    plt.$flags$ |= 1 /* isTmpDisconnected */;
    if (checkSlotRelocate) {
      markSlotContentForRelocation(rootVnode.$elm$);
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        if (!nodeToRelocate["s-ol"] && win.document) {
          const orgLocationNode = win.document.createTextNode("");
          orgLocationNode["s-nr"] = nodeToRelocate;
          insertBefore(nodeToRelocate.parentNode, nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
        }
      }
      for (const relocateData of relocateNodes) {
        const nodeToRelocate = relocateData.$nodeToRelocate$;
        const slotRefNode = relocateData.$slotRefNode$;
        if (slotRefNode) {
          const parentNodeRef = slotRefNode.parentNode;
          let insertBeforeNode = slotRefNode.nextSibling;
          {
            let orgLocationNode = (_a = nodeToRelocate["s-ol"]) == null ? void 0 : _a.previousSibling;
            while (orgLocationNode) {
              let refNode = (_b = orgLocationNode["s-nr"]) != null ? _b : null;
              if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === (refNode.__parentNode || refNode.parentNode)) {
                refNode = refNode.nextSibling;
                while (refNode === nodeToRelocate || (refNode == null ? void 0 : refNode["s-sr"])) {
                  refNode = refNode == null ? void 0 : refNode.nextSibling;
                }
                if (!refNode || !refNode["s-nr"]) {
                  insertBeforeNode = refNode;
                  break;
                }
              }
              orgLocationNode = orgLocationNode.previousSibling;
            }
          }
          const parent = nodeToRelocate.__parentNode || nodeToRelocate.parentNode;
          const nextSibling = nodeToRelocate.__nextSibling || nodeToRelocate.nextSibling;
          if (!insertBeforeNode && parentNodeRef !== parent || nextSibling !== insertBeforeNode) {
            if (nodeToRelocate !== insertBeforeNode) {
              if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
              }
              insertBefore(parentNodeRef, nodeToRelocate, insertBeforeNode);
              if (nodeToRelocate.nodeType === 1 /* ElementNode */ && nodeToRelocate.tagName !== "SLOT-FB") {
                nodeToRelocate.hidden = (_c = nodeToRelocate["s-ih"]) != null ? _c : false;
              }
            }
          }
          nodeToRelocate && typeof slotRefNode["s-rf"] === "function" && slotRefNode["s-rf"](slotRefNode);
        } else {
          if (nodeToRelocate.nodeType === 1 /* ElementNode */) {
            if (isInitialLoad) {
              nodeToRelocate["s-ih"] = (_d = nodeToRelocate.hidden) != null ? _d : false;
            }
            nodeToRelocate.hidden = true;
          }
        }
      }
    }
    if (checkSlotFallbackVisibility) {
      updateFallbackSlotVisibility(rootVnode.$elm$);
    }
    plt.$flags$ &= -2 /* isTmpDisconnected */;
    relocateNodes.length = 0;
  }
  contentRef = void 0;
};

// src/runtime/update-component.ts
var attachToAncestor = (hostRef, ancestorComponent) => {
  if (ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
    const index = ancestorComponent["s-p"].push(
      new Promise(
        (r) => hostRef.$onRenderResolve$ = () => {
          ancestorComponent["s-p"].splice(index - 1, 1);
          r();
        }
      )
    );
  }
};
var scheduleUpdate = (hostRef, isInitialLoad) => {
  {
    hostRef.$flags$ |= 16 /* isQueuedForUpdate */;
  }
  if (hostRef.$flags$ & 4 /* isWaitingForChildren */) {
    hostRef.$flags$ |= 512 /* needsRerender */;
    return;
  }
  attachToAncestor(hostRef, hostRef.$ancestorComponent$);
  const dispatch = () => dispatchHooks(hostRef, isInitialLoad);
  return writeTask(dispatch) ;
};
var dispatchHooks = (hostRef, isInitialLoad) => {
  const elm = hostRef.$hostElement$;
  const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
  const instance = hostRef.$lazyInstance$ ;
  if (!instance) {
    throw new Error(
      `Can't render component <${elm.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`
    );
  }
  let maybePromise;
  if (isInitialLoad) {
    {
      hostRef.$flags$ |= 256 /* isListenReady */;
      if (hostRef.$queuedListeners$) {
        hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event, elm));
        hostRef.$queuedListeners$ = void 0;
      }
    }
    maybePromise = safeCall(instance, "componentWillLoad", void 0, elm);
  } else {
    maybePromise = safeCall(instance, "componentWillUpdate", void 0, elm);
  }
  maybePromise = enqueue(maybePromise, () => safeCall(instance, "componentWillRender", void 0, elm));
  endSchedule();
  return enqueue(maybePromise, () => updateComponent(hostRef, instance, isInitialLoad));
};
var enqueue = (maybePromise, fn) => isPromisey(maybePromise) ? maybePromise.then(fn).catch((err2) => {
  console.error(err2);
  fn();
}) : fn();
var isPromisey = (maybePromise) => maybePromise instanceof Promise || maybePromise && maybePromise.then && typeof maybePromise.then === "function";
var updateComponent = async (hostRef, instance, isInitialLoad) => {
  var _a;
  const elm = hostRef.$hostElement$;
  const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
  const rc = elm["s-rc"];
  if (isInitialLoad) {
    attachStyles(hostRef);
  }
  const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
  {
    callRender(hostRef, instance, elm, isInitialLoad);
  }
  if (rc) {
    rc.map((cb) => cb());
    elm["s-rc"] = void 0;
  }
  endRender();
  endUpdate();
  {
    const childrenPromises = (_a = elm["s-p"]) != null ? _a : [];
    const postUpdate = () => postUpdateComponent(hostRef);
    if (childrenPromises.length === 0) {
      postUpdate();
    } else {
      Promise.all(childrenPromises).then(postUpdate);
      hostRef.$flags$ |= 4 /* isWaitingForChildren */;
      childrenPromises.length = 0;
    }
  }
};
var callRender = (hostRef, instance, elm, isInitialLoad) => {
  try {
    instance = instance.render() ;
    {
      hostRef.$flags$ &= -17 /* isQueuedForUpdate */;
    }
    {
      hostRef.$flags$ |= 2 /* hasRendered */;
    }
    {
      {
        {
          renderVdom(hostRef, instance, isInitialLoad);
        }
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
  return null;
};
var postUpdateComponent = (hostRef) => {
  const tagName = hostRef.$cmpMeta$.$tagName$;
  const elm = hostRef.$hostElement$;
  const endPostUpdate = createTime("postUpdate", tagName);
  const instance = hostRef.$lazyInstance$ ;
  const ancestorComponent = hostRef.$ancestorComponent$;
  safeCall(instance, "componentDidRender", void 0, elm);
  if (!(hostRef.$flags$ & 64 /* hasLoadedComponent */)) {
    hostRef.$flags$ |= 64 /* hasLoadedComponent */;
    {
      addHydratedFlag(elm);
    }
    safeCall(instance, "componentDidLoad", void 0, elm);
    endPostUpdate();
    {
      hostRef.$onReadyResolve$(elm);
      if (!ancestorComponent) {
        appDidLoad();
      }
    }
  } else {
    safeCall(instance, "componentDidUpdate", void 0, elm);
    endPostUpdate();
  }
  {
    hostRef.$onInstanceResolve$(elm);
  }
  {
    if (hostRef.$onRenderResolve$) {
      hostRef.$onRenderResolve$();
      hostRef.$onRenderResolve$ = void 0;
    }
    if (hostRef.$flags$ & 512 /* needsRerender */) {
      nextTick(() => scheduleUpdate(hostRef, false));
    }
    hostRef.$flags$ &= -517;
  }
};
var appDidLoad = (who) => {
  nextTick(() => emitEvent(win, "appload", { detail: { namespace: NAMESPACE } }));
};
var safeCall = (instance, method, arg, elm) => {
  if (instance && instance[method]) {
    try {
      return instance[method](arg);
    } catch (e) {
      consoleError(e, elm);
    }
  }
  return void 0;
};
var addHydratedFlag = (elm) => {
  var _a;
  return elm.classList.add((_a = BUILD.hydratedSelectorName) != null ? _a : "hydrated") ;
};

// src/runtime/set-value.ts
var getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta) => {
  const hostRef = getHostRef(ref);
  if (!hostRef) {
    throw new Error(
      `Couldn't find host element for "${cmpMeta.$tagName$}" as it is unknown to this Stencil runtime. This usually happens when integrating a 3rd party Stencil component with another Stencil component or application. Please reach out to the maintainers of the 3rd party Stencil component or report this on the Stencil Discord server (https://chat.stenciljs.com) or comment on this similar [GitHub issue](https://github.com/stenciljs/core/issues/5457).`
    );
  }
  const elm = hostRef.$hostElement$ ;
  const oldVal = hostRef.$instanceValues$.get(propName);
  const flags = hostRef.$flags$;
  const instance = hostRef.$lazyInstance$ ;
  newVal = parsePropertyValue(
    newVal,
    cmpMeta.$members$[propName][0]);
  const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
  const didValueChange = newVal !== oldVal && !areBothNaN;
  if ((!(flags & 8 /* isConstructingInstance */) || oldVal === void 0) && didValueChange) {
    hostRef.$instanceValues$.set(propName, newVal);
    if (instance) {
      if (cmpMeta.$watchers$ && flags & 128 /* isWatchReady */) {
        const watchMethods = cmpMeta.$watchers$[propName];
        if (watchMethods) {
          watchMethods.map((watchMethodName) => {
            try {
              instance[watchMethodName](newVal, oldVal, propName);
            } catch (e) {
              consoleError(e, elm);
            }
          });
        }
      }
      if ((flags & (2 /* hasRendered */ | 16 /* isQueuedForUpdate */)) === 2 /* hasRendered */) {
        if (instance.componentShouldUpdate) {
          if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
            return;
          }
        }
        scheduleUpdate(hostRef, false);
      }
    }
  }
};

// src/runtime/proxy-component.ts
var proxyComponent = (Cstr, cmpMeta, flags) => {
  var _a, _b;
  const prototype = Cstr.prototype;
  if (cmpMeta.$members$ || (cmpMeta.$watchers$ || Cstr.watchers)) {
    if (Cstr.watchers && !cmpMeta.$watchers$) {
      cmpMeta.$watchers$ = Cstr.watchers;
    }
    const members = Object.entries((_a = cmpMeta.$members$) != null ? _a : {});
    members.map(([memberName, [memberFlags]]) => {
      if ((memberFlags & 31 /* Prop */ || (flags & 2 /* proxyState */) && memberFlags & 32 /* State */)) {
        const { get: origGetter, set: origSetter } = Object.getOwnPropertyDescriptor(prototype, memberName) || {};
        if (origGetter) cmpMeta.$members$[memberName][0] |= 2048 /* Getter */;
        if (origSetter) cmpMeta.$members$[memberName][0] |= 4096 /* Setter */;
        if (flags & 1 /* isElementConstructor */ || !origGetter) {
          Object.defineProperty(prototype, memberName, {
            get() {
              {
                if ((cmpMeta.$members$[memberName][0] & 2048 /* Getter */) === 0) {
                  return getValue(this, memberName);
                }
                const ref = getHostRef(this);
                const instance = ref ? ref.$lazyInstance$ : prototype;
                if (!instance) return;
                return instance[memberName];
              }
            },
            configurable: true,
            enumerable: true
          });
        }
        Object.defineProperty(prototype, memberName, {
          set(newValue) {
            const ref = getHostRef(this);
            if (origSetter) {
              const currentValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];
              if (typeof currentValue === "undefined" && ref.$instanceValues$.get(memberName)) {
                newValue = ref.$instanceValues$.get(memberName);
              } else if (!ref.$instanceValues$.get(memberName) && currentValue) {
                ref.$instanceValues$.set(memberName, currentValue);
              }
              origSetter.apply(this, [
                parsePropertyValue(
                  newValue,
                  memberFlags)
              ]);
              newValue = memberFlags & 32 /* State */ ? this[memberName] : ref.$hostElement$[memberName];
              setValue(this, memberName, newValue, cmpMeta);
              return;
            }
            {
              if ((flags & 1 /* isElementConstructor */) === 0 || (cmpMeta.$members$[memberName][0] & 4096 /* Setter */) === 0) {
                setValue(this, memberName, newValue, cmpMeta);
                if (flags & 1 /* isElementConstructor */ && !ref.$lazyInstance$) {
                  ref.$onReadyPromise$.then(() => {
                    if (cmpMeta.$members$[memberName][0] & 4096 /* Setter */ && ref.$lazyInstance$[memberName] !== ref.$instanceValues$.get(memberName)) {
                      ref.$lazyInstance$[memberName] = newValue;
                    }
                  });
                }
                return;
              }
              const setterSetVal = () => {
                const currentValue = ref.$lazyInstance$[memberName];
                if (!ref.$instanceValues$.get(memberName) && currentValue) {
                  ref.$instanceValues$.set(memberName, currentValue);
                }
                ref.$lazyInstance$[memberName] = parsePropertyValue(
                  newValue,
                  memberFlags);
                setValue(this, memberName, ref.$lazyInstance$[memberName], cmpMeta);
              };
              if (ref.$lazyInstance$) {
                setterSetVal();
              } else {
                ref.$onReadyPromise$.then(() => setterSetVal());
              }
            }
          }
        });
      } else if (flags & 1 /* isElementConstructor */ && memberFlags & 64 /* Method */) {
        Object.defineProperty(prototype, memberName, {
          value(...args) {
            var _a2;
            const ref = getHostRef(this);
            return (_a2 = ref == null ? void 0 : ref.$onInstancePromise$) == null ? void 0 : _a2.then(() => {
              var _a3;
              return (_a3 = ref.$lazyInstance$) == null ? void 0 : _a3[memberName](...args);
            });
          }
        });
      }
    });
    if ((flags & 1 /* isElementConstructor */)) {
      const attrNameToPropName = /* @__PURE__ */ new Map();
      prototype.attributeChangedCallback = function(attrName, oldValue, newValue) {
        plt.jmp(() => {
          var _a2;
          const propName = attrNameToPropName.get(attrName);
          if (this.hasOwnProperty(propName) && BUILD.lazyLoad) {
            newValue = this[propName];
            delete this[propName];
          } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && // cast type to number to avoid TS compiler issues
          this[propName] == newValue) {
            return;
          } else if (propName == null) {
            const hostRef = getHostRef(this);
            const flags2 = hostRef == null ? void 0 : hostRef.$flags$;
            if (flags2 && !(flags2 & 8 /* isConstructingInstance */) && flags2 & 128 /* isWatchReady */ && newValue !== oldValue) {
              const instance = hostRef.$lazyInstance$ ;
              const entry = (_a2 = cmpMeta.$watchers$) == null ? void 0 : _a2[attrName];
              entry == null ? void 0 : entry.forEach((callbackName) => {
                if (instance[callbackName] != null) {
                  instance[callbackName].call(instance, newValue, oldValue, attrName);
                }
              });
            }
            return;
          }
          const propDesc = Object.getOwnPropertyDescriptor(prototype, propName);
          newValue = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
          if (newValue !== this[propName] && (!propDesc.get || !!propDesc.set)) {
            this[propName] = newValue;
          }
        });
      };
      Cstr.observedAttributes = Array.from(
        /* @__PURE__ */ new Set([
          ...Object.keys((_b = cmpMeta.$watchers$) != null ? _b : {}),
          ...members.filter(([_, m]) => m[0] & 15 /* HasAttribute */).map(([propName, m]) => {
            var _a2;
            const attrName = m[1] || propName;
            attrNameToPropName.set(attrName, propName);
            if (m[0] & 512 /* ReflectAttr */) {
              (_a2 = cmpMeta.$attrsToReflect$) == null ? void 0 : _a2.push([propName, attrName]);
            }
            return attrName;
          })
        ])
      );
    }
  }
  return Cstr;
};

// src/runtime/initialize-component.ts
var initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId) => {
  let Cstr;
  if ((hostRef.$flags$ & 32 /* hasInitializedComponent */) === 0) {
    hostRef.$flags$ |= 32 /* hasInitializedComponent */;
    const bundleId = cmpMeta.$lazyBundleId$;
    if (bundleId) {
      const CstrImport = loadModule(cmpMeta, hostRef);
      if (CstrImport && "then" in CstrImport) {
        const endLoad = uniqueTime();
        Cstr = await CstrImport;
        endLoad();
      } else {
        Cstr = CstrImport;
      }
      if (!Cstr) {
        throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
      }
      if (!Cstr.isProxied) {
        {
          cmpMeta.$watchers$ = Cstr.watchers;
        }
        proxyComponent(Cstr, cmpMeta, 2 /* proxyState */);
        Cstr.isProxied = true;
      }
      const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
      {
        hostRef.$flags$ |= 8 /* isConstructingInstance */;
      }
      try {
        new Cstr(hostRef);
      } catch (e) {
        consoleError(e, elm);
      }
      {
        hostRef.$flags$ &= -9 /* isConstructingInstance */;
      }
      {
        hostRef.$flags$ |= 128 /* isWatchReady */;
      }
      endNewInstance();
      fireConnectedCallback(hostRef.$lazyInstance$, elm);
    } else {
      Cstr = elm.constructor;
      const cmpTag = elm.localName;
      customElements.whenDefined(cmpTag).then(() => hostRef.$flags$ |= 128 /* isWatchReady */);
    }
    if (Cstr && Cstr.style) {
      let style;
      if (typeof Cstr.style === "string") {
        style = Cstr.style;
      }
      const scopeId2 = getScopeId(cmpMeta);
      if (!styles.has(scopeId2)) {
        const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
        registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */));
        endRegisterStyles();
      }
    }
  }
  const ancestorComponent = hostRef.$ancestorComponent$;
  const schedule = () => scheduleUpdate(hostRef, true);
  if (ancestorComponent && ancestorComponent["s-rc"]) {
    ancestorComponent["s-rc"].push(schedule);
  } else {
    schedule();
  }
};
var fireConnectedCallback = (instance, elm) => {
  {
    safeCall(instance, "connectedCallback", void 0, elm);
  }
};

// src/runtime/connected-callback.ts
var connectedCallback = (elm) => {
  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
    const hostRef = getHostRef(elm);
    const cmpMeta = hostRef.$cmpMeta$;
    const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
    if (!(hostRef.$flags$ & 1 /* hasConnected */)) {
      hostRef.$flags$ |= 1 /* hasConnected */;
      let hostId;
      {
        hostId = elm.getAttribute(HYDRATE_ID);
        if (hostId) {
          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
            const scopeId2 = addStyle(elm.shadowRoot, cmpMeta);
            elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
          }
          initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
        }
      }
      if (!hostId) {
        if (// TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
        cmpMeta.$flags$ & (4 /* hasSlotRelocation */ | 8 /* needsShadowDomShim */)) {
          setContentReference(elm);
        }
      }
      {
        let ancestorComponent = elm;
        while (ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host) {
          if (ancestorComponent.nodeType === 1 /* ElementNode */ && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
            attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
            break;
          }
        }
      }
      if (cmpMeta.$members$) {
        Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {
          if (memberFlags & 31 /* Prop */ && elm.hasOwnProperty(memberName)) {
            const value = elm[memberName];
            delete elm[memberName];
            elm[memberName] = value;
          }
        });
      }
      {
        initializeComponent(elm, hostRef, cmpMeta);
      }
    } else {
      addHostEventListeners(elm, hostRef, cmpMeta.$listeners$);
      if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
        fireConnectedCallback(hostRef.$lazyInstance$, elm);
      } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
        hostRef.$onReadyPromise$.then(() => fireConnectedCallback(hostRef.$lazyInstance$, elm));
      }
    }
    endConnected();
  }
};
var setContentReference = (elm) => {
  if (!win.document) {
    return;
  }
  const contentRefElm = elm["s-cr"] = win.document.createComment(
    ""
  );
  contentRefElm["s-cn"] = true;
  insertBefore(elm, contentRefElm, elm.firstChild);
};
var disconnectInstance = (instance, elm) => {
  {
    safeCall(instance, "disconnectedCallback", void 0, elm || instance);
  }
};
var disconnectedCallback = async (elm) => {
  if ((plt.$flags$ & 1 /* isTmpDisconnected */) === 0) {
    const hostRef = getHostRef(elm);
    {
      if (hostRef.$rmListeners$) {
        hostRef.$rmListeners$.map((rmListener) => rmListener());
        hostRef.$rmListeners$ = void 0;
      }
    }
    if (hostRef == null ? void 0 : hostRef.$lazyInstance$) {
      disconnectInstance(hostRef.$lazyInstance$, elm);
    } else if (hostRef == null ? void 0 : hostRef.$onReadyPromise$) {
      hostRef.$onReadyPromise$.then(() => disconnectInstance(hostRef.$lazyInstance$, elm));
    }
  }
  if (rootAppliedStyles.has(elm)) {
    rootAppliedStyles.delete(elm);
  }
  if (elm.shadowRoot && rootAppliedStyles.has(elm.shadowRoot)) {
    rootAppliedStyles.delete(elm.shadowRoot);
  }
};

// src/runtime/bootstrap-lazy.ts
var bootstrapLazy = (lazyBundles, options = {}) => {
  var _a;
  if (!win.document) {
    console.warn("Stencil: No document found. Skipping bootstrapping lazy components.");
    return;
  }
  const endBootstrap = createTime();
  const cmpTags = [];
  const exclude = options.exclude || [];
  const customElements2 = win.customElements;
  const head = win.document.head;
  const metaCharset = /* @__PURE__ */ head.querySelector("meta[charset]");
  const dataStyles = /* @__PURE__ */ win.document.createElement("style");
  const deferredConnectedCallbacks = [];
  let appLoadFallback;
  let isBootstrapping = true;
  Object.assign(plt, options);
  plt.$resourcesUrl$ = new URL(options.resourcesUrl || "./", win.document.baseURI).href;
  {
    plt.$flags$ |= 2 /* appLoaded */;
  }
  {
    hydrateScopedToShadow();
  }
  let hasSlotRelocation = false;
  lazyBundles.map((lazyBundle) => {
    lazyBundle[1].map((compactMeta) => {
      var _a2;
      const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1],
        $members$: compactMeta[2],
        $listeners$: compactMeta[3]
      };
      if (cmpMeta.$flags$ & 4 /* hasSlotRelocation */) {
        hasSlotRelocation = true;
      }
      {
        cmpMeta.$members$ = compactMeta[2];
      }
      {
        cmpMeta.$listeners$ = compactMeta[3];
      }
      {
        cmpMeta.$attrsToReflect$ = [];
      }
      {
        cmpMeta.$watchers$ = (_a2 = compactMeta[4]) != null ? _a2 : {};
      }
      const tagName = cmpMeta.$tagName$;
      const HostElement = class extends HTMLElement {
        // StencilLazyHost
        constructor(self) {
          super(self);
          this.hasRegisteredEventListeners = false;
          self = this;
          registerHost(self, cmpMeta);
          if (cmpMeta.$flags$ & 1 /* shadowDomEncapsulation */) {
            {
              if (!self.shadowRoot) {
                createShadowRoot.call(self, cmpMeta);
              } else {
                if (self.shadowRoot.mode !== "open") {
                  throw new Error(
                    `Unable to re-use existing shadow root for ${cmpMeta.$tagName$}! Mode is set to ${self.shadowRoot.mode} but Stencil only supports open shadow roots.`
                  );
                }
              }
            }
          }
        }
        connectedCallback() {
          const hostRef = getHostRef(this);
          if (!this.hasRegisteredEventListeners) {
            this.hasRegisteredEventListeners = true;
            addHostEventListeners(this, hostRef, cmpMeta.$listeners$);
          }
          if (appLoadFallback) {
            clearTimeout(appLoadFallback);
            appLoadFallback = null;
          }
          if (isBootstrapping) {
            deferredConnectedCallbacks.push(this);
          } else {
            plt.jmp(() => connectedCallback(this));
          }
        }
        disconnectedCallback() {
          plt.jmp(() => disconnectedCallback(this));
          plt.raf(() => {
            var _a3;
            const hostRef = getHostRef(this);
            const i2 = deferredConnectedCallbacks.findIndex((host) => host === this);
            if (i2 > -1) {
              deferredConnectedCallbacks.splice(i2, 1);
            }
            if (((_a3 = hostRef == null ? void 0 : hostRef.$vnode$) == null ? void 0 : _a3.$elm$) instanceof Node && !hostRef.$vnode$.$elm$.isConnected) {
              delete hostRef.$vnode$.$elm$;
            }
          });
        }
        componentOnReady() {
          return getHostRef(this).$onReadyPromise$;
        }
      };
      cmpMeta.$lazyBundleId$ = lazyBundle[0];
      if (!exclude.includes(tagName) && !customElements2.get(tagName)) {
        cmpTags.push(tagName);
        customElements2.define(
          tagName,
          proxyComponent(HostElement, cmpMeta, 1 /* isElementConstructor */)
        );
      }
    });
  });
  if (cmpTags.length > 0) {
    if (hasSlotRelocation) {
      dataStyles.textContent += SLOT_FB_CSS;
    }
    {
      dataStyles.textContent += cmpTags.sort() + HYDRATED_CSS;
    }
    if (dataStyles.innerHTML.length) {
      dataStyles.setAttribute("data-styles", "");
      const nonce = (_a = plt.$nonce$) != null ? _a : queryNonceMetaTagContent(win.document);
      if (nonce != null) {
        dataStyles.setAttribute("nonce", nonce);
      }
      head.insertBefore(dataStyles, metaCharset ? metaCharset.nextSibling : head.firstChild);
    }
  }
  isBootstrapping = false;
  if (deferredConnectedCallbacks.length) {
    deferredConnectedCallbacks.map((host) => host.connectedCallback());
  } else {
    {
      plt.jmp(() => appLoadFallback = setTimeout(appDidLoad, 30));
    }
  }
  endBootstrap();
};

// src/runtime/fragment.ts
var Fragment = (_, children) => children;
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {
  if (listeners && win.document) {
    listeners.map(([flags, name, method]) => {
      const target = getHostListenerTarget(win.document, elm, flags) ;
      const handler = hostListenerProxy(hostRef, method);
      const opts = hostListenerOpts(flags);
      plt.ael(target, name, handler, opts);
      (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));
    });
  }
};
var hostListenerProxy = (hostRef, methodName) => (ev) => {
  var _a;
  try {
    {
      if (hostRef.$flags$ & 256 /* isListenReady */) {
        (_a = hostRef.$lazyInstance$) == null ? void 0 : _a[methodName](ev);
      } else {
        (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);
      }
    }
  } catch (e) {
    consoleError(e, hostRef.$hostElement$);
  }
};
var getHostListenerTarget = (doc, elm, flags) => {
  if (flags & 4 /* TargetDocument */) {
    return doc;
  }
  if (flags & 8 /* TargetWindow */) {
    return win;
  }
  return elm;
};
var hostListenerOpts = (flags) => supportsListenerOptions ? {
  passive: (flags & 1 /* Passive */) !== 0,
  capture: (flags & 2 /* Capture */) !== 0
} : (flags & 2 /* Capture */) !== 0;

// src/runtime/nonce.ts
var setNonce = (nonce) => plt.$nonce$ = nonce;

export { Fragment as F, Host as H, getElement as a, bootstrapLazy as b, createEvent as c, getDefaultExportFromCjs as d, require_root as e, requireIsObject as f, globalScripts as g, h, requireIsSymbol as i, axios as j, promiseResolve as p, registerInstance as r, setNonce as s };
